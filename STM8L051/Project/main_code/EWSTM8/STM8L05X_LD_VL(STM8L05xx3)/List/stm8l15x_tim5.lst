###############################################################################
#
# IAR C/C++ Compiler V2.10.2.149 for STM8                 16/Jun/2015  16:46:12
# Copyright 2010-2014 IAR Systems AB.
#
#    Source file  =  
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_tim5.c
#    Command line =  
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_tim5.c
#        -e -Ohz --debug --code_model small --data_model medium -o
#        "C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\STM8L05X_LD_VL(STM8L05xx3)\Obj\"
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\stm8\LIB\dlstm8smn.h" -D USE_STM8L1526_EVAL -D STM8L05X_LD_VL -lC
#        "C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\STM8L05X_LD_VL(STM8L05xx3)\List\"
#        -lA
#        "C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\STM8L05X_LD_VL(STM8L05xx3)\List\"
#        -I
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\..\
#        -I
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\..\..\..\Libraries\STM8L15x_StdPeriph_Driver\inc\
#        -I
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\..\..\..\Utilities\STM8_EVAL\
#        -I
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\..\..\..\Utilities\STM8_EVAL\STM8L1526_EVAL\
#        -I
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\..\..\..\Utilities\STM8_EVAL\Common\
#        -I
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\..\..\..\Utilities\Misc\
#        --require_prototypes --vregs 16
#    List file    =  
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\STM8L05X_LD_VL(STM8L05xx3)\List\stm8l15x_tim5.lst
#    Object file  =  
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\STM8L05X_LD_VL(STM8L05xx3)\Obj\stm8l15x_tim5.o
#
###############################################################################

C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_tim5.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_tim5.c
      4            * @author  MCD Application Team
      5            * @version V1.6.0
      6            * @date    28-June-2013
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the TIM5 peripheral:
      9            *            - TimeBase management
     10            *            - Output Compare management
     11            *            - Input Capture management
     12            *            - Interrupts, DMA and flags management
     13            *            - Clocks management
     14            *            - Synchronization management
     15            *            - Specific interface management
     16            *              
     17            *  @verbatim
     18            *  
     19            *          ===================================================================
     20            *                                 How to use this driver
     21            *          ===================================================================
     22            *          This driver provides functions to configure and initialise the TIM5
     23            *          peripheral
     24            *          These functions are split in 7 groups: 
     25            *   
     26            *          1. TIM5 TimeBase management: this group includes all needed functions 
     27            *             to configure the TIM Timebase unit:
     28            *                   - Set/Get Prescaler
     29            *                   - Set/Get Autoreload  
     30            *                   - Counter modes configuration
     31            *                   - Select the One Pulse mode
     32            *                   - Update Request Configuration
     33            *                   - Update Disable Configuration
     34            *                   - Auto-Preload Configuration 
     35            *                   - Enable/Disable the counter
     36            *                 
     37            *          2. TIM5 Output Compare management: this group includes all needed 
     38            *             functions to configure the Capture/Compare unit used in Output 
     39            *             compare mode: 
     40            *                   - Configure each channel, independently, in Output Compare mode
     41            *                   - Select the output compare modes
     42            *                   - Select the Polarities of each channel
     43            *                   - Set/Get the Capture/Compare register values
     44            *                   - Select the Output Compare Fast mode 
     45            *                   - Select the Output Compare Forced mode  
     46            *                   - Output Compare-Preload Configuration 
     47            *                   - Enable/Disable the Capture/Compare Channels    
     48            *                   
     49            *          3. TIM5 Input Capture management: this group includes all needed 
     50            *             functions to configure the Capture/Compare unit used in 
     51            *             Input Capture mode:
     52            *                   - Configure each channel in input capture mode
     53            *                   - Configure Channel1/2 in PWM Input mode
     54            *                   - Set the Input Capture Prescaler
     55            *                   - Get the Capture/Compare values      
     56            *        
     57            *          4. TIM5 interrupts, DMA and flags management
     58            *                   - Enable/Disable interrupt sources
     59            *                   - Get flags status
     60            *                   - Clear flags/ Pending bits
     61            *                   - Enable/Disable DMA requests 
     62            *                   - Select CaptureCompare DMA request  
     63            *              
     64            *          5. TIM5 clocks management: this group includes all needed functions 
     65            *             to configure the clock controller unit:
     66            *                   - Select internal/External clock
     67            *                   - Select the external clock mode: ETR(Mode1/Mode2) or TIx
     68            *         
     69            *          6. TIM5 synchronization management: this group includes all needed 
     70            *             functions to configure the Synchronization unit:
     71            *                   - Select Input Trigger  
     72            *                   - Select Output Trigger  
     73            *                   - Select Master Slave Mode 
     74            *                   - ETR Configuration when used as external trigger   
     75            *     
     76            *          7. TIM5 specific interface management, this group includes all 
     77            *             needed functions to use the specific TIM5 interface:
     78            *                   - Encoder Interface Configuration
     79            *                   - Select Hall Sensor        
     80            *   
     81            *  @endverbatim
     82            *    
     83            ******************************************************************************
     84            *
     85            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     86            * You may not use this file except in compliance with the License.
     87            * You may obtain a copy of the License at:
     88            *
     89            *        http://www.st.com/software_license_agreement_liberty_v2
     90            *
     91            * Unless required by applicable law or agreed to in writing, software 
     92            * distributed under the License is distributed on an "AS IS" BASIS, 
     93            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     94            * See the License for the specific language governing permissions and
     95            * limitations under the License.
     96            *
     97            ****************************************************************************** 
     98            */
     99          
    100          /* Includes ------------------------------------------------------------------*/
    101          #include "stm8l15x_TIM5.h"
    102          
    103          /** @addtogroup STM8L15x_StdPeriph_Driver
    104            * @{
    105            */
    106          
    107          /** @defgroup TIM5 
    108            * @brief TIM5 driver modules
    109            * @{
    110            */
    111            
    112          /* Private typedef -----------------------------------------------------------*/
    113          /* Private define ------------------------------------------------------------*/
    114          /* Private macro -------------------------------------------------------------*/
    115          /* Private variables ---------------------------------------------------------*/
    116          /* Private function prototypes -----------------------------------------------*/
    117          static void TI1_Config(TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
    118                                 TIM5_ICSelection_TypeDef TIM5_ICSelection,
    119                                 uint8_t TIM5_ICFilter);
    120          static void TI2_Config(TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
    121                                 TIM5_ICSelection_TypeDef TIM5_ICSelection,
    122                                 uint8_t TIM5_ICFilter);
    123          
    124          
    125          /** @defgroup TIM5_Private_Functions
    126            * @{
    127            */
    128          
    129          /** @defgroup TIM5_Group1 TimeBase management functions
    130           *  @brief   TimeBase management functions 
    131           *
    132          @verbatim   
    133           ===============================================================================
    134                                 TimeBase management functions
    135           ===============================================================================  
    136            
    137                 ===================================================================      
    138                        TIM5 Driver: how to use it in Timing(Time base) Mode
    139                 =================================================================== 
    140                 To use the Timer in Timing(Time base) mode, the following steps are mandatory:
    141                 
    142                 1. Enable TIM5 clock using CLK_PeripheralClockConfig(CLK_Peripheral_TIM5, ENABLE) function.
    143                  
    144                 2. Call TIM5_TimeBaseInit() to configure the Time Base unit with the
    145                    corresponding configuration.
    146                    
    147                 3. Enable global interrupts if you need to generate the update interrupt.
    148                    
    149                 4. Enable the corresponding interrupt using the function TIM5_ITConfig(TIM5_IT_Update) 
    150                    
    151                 5. Call the TIM5_Cmd(ENABLE) function to enable the TIM5 counter.
    152                 
    153                 Note1: All other functions can be used separately to modify, if needed,
    154                    a specific feature of the Timer. 
    155          
    156          @endverbatim
    157            * @{
    158            */
    159          
    160          /**
    161            * @brief  Deinitialize the TIM5 peripheral registers to their default reset values.
    162            * @param  None
    163            * @retval None
    164            */

   \                                 In section .near_func.text, align 1
    165          void TIM5_DeInit(void)
    166          {
    167            TIM5->CR1 = TIM_CR1_RESET_VALUE;
   \                     TIM5_DeInit:
   \   000000 725F 5300    CLR       L:0x5300
    168            TIM5->CR2 = TIM_CR2_RESET_VALUE;
   \   000004 725F 5301    CLR       L:0x5301
    169            TIM5->SMCR = TIM_SMCR_RESET_VALUE;
   \   000008 725F 5302    CLR       L:0x5302
    170            TIM5->ETR = TIM_ETR_RESET_VALUE;
   \   00000C 725F 5303    CLR       L:0x5303
    171            TIM5->IER = TIM_IER_RESET_VALUE;
   \   000010 725F 5305    CLR       L:0x5305
    172            TIM5->SR2 = TIM_SR2_RESET_VALUE;
   \   000014 725F 5307    CLR       L:0x5307
    173          
    174            /* Disable channels */
    175            TIM5->CCER1 = TIM_CCER1_RESET_VALUE;
   \   000018 725F 530B    CLR       L:0x530b
    176            /* Configure channels as inputs: it is necessary if lock level is equal to 2 or 3 */
    177            TIM5->CCMR1 = 0x01;/*TIM5_ICxSource_TIxFPx */
   \   00001C 35 01 5309   MOV       L:0x5309, #0x1
    178            TIM5->CCMR2 = 0x01;/*TIM5_ICxSource_TIxFPx */
   \   000020 35 01 530A   MOV       L:0x530a, #0x1
    179          
    180            /* Then reset channel registers: it also works if lock level is equal to 2 or 3 */
    181            TIM5->CCER1 = TIM_CCER1_RESET_VALUE;
   \   000024 725F 530B    CLR       L:0x530b
    182            TIM5->CCMR1 = TIM_CCMR1_RESET_VALUE;
   \   000028 725F 5309    CLR       L:0x5309
    183            TIM5->CCMR2 = TIM_CCMR2_RESET_VALUE;
   \   00002C 725F 530A    CLR       L:0x530a
    184          
    185            TIM5->CNTRH = TIM_CNTRH_RESET_VALUE;
   \   000030 725F 530C    CLR       L:0x530c
    186            TIM5->CNTRL = TIM_CNTRL_RESET_VALUE;
   \   000034 725F 530D    CLR       L:0x530d
    187          
    188            TIM5->PSCR = TIM_PSCR_RESET_VALUE;
   \   000038 725F 530E    CLR       L:0x530e
    189          
    190            TIM5->ARRH = TIM_ARRH_RESET_VALUE;
   \   00003C 35 FF 530F   MOV       L:0x530f, #0xff
    191            TIM5->ARRL = TIM_ARRL_RESET_VALUE;
   \   000040 35 FF 5310   MOV       L:0x5310, #0xff
    192          
    193            TIM5->CCR1H = TIM_CCR1H_RESET_VALUE;
   \   000044 725F 5311    CLR       L:0x5311
    194            TIM5->CCR1L = TIM_CCR1L_RESET_VALUE;
   \   000048 725F 5312    CLR       L:0x5312
    195            TIM5->CCR2H = TIM_CCR2H_RESET_VALUE;
   \   00004C 725F 5313    CLR       L:0x5313
    196            TIM5->CCR2L = TIM_CCR2L_RESET_VALUE;
   \   000050 725F 5314    CLR       L:0x5314
    197          
    198          
    199            TIM5->OISR = TIM_OISR_RESET_VALUE;
   \   000054 725F 5316    CLR       L:0x5316
    200            TIM5->EGR = 0x01;/* TIM_EGR_UG */
   \   000058 35 01 5308   MOV       L:0x5308, #0x1
    201            TIM5->BKR = TIM_BKR_RESET_VALUE;
   \   00005C 725F 5315    CLR       L:0x5315
    202            TIM5->SR1 = TIM_SR1_RESET_VALUE;
   \   000060 725F 5306    CLR       L:0x5306
    203          }
   \   000064 81           RET
    204          
    205          /**
    206            * @brief  Initializes the TIM5 Time Base Unit according to the specified  parameters.
    207            * @param  TIM5_Prescaler: Prescaler 
    208            *          This parameter can be one of the following values:
    209            *            @arg TIM5_Prescaler_1: Time base Prescaler = 1 (No effect)
    210            *            @arg TIM5_Prescaler_2: Time base Prescaler = 2
    211            *            @arg TIM5_Prescaler_4: Time base Prescaler = 4
    212            *            @arg TIM5_Prescaler_8: Time base Prescaler = 8
    213            *            @arg TIM5_Prescaler_16: Time base Prescaler = 16
    214            *            @arg TIM5_Prescaler_32: Time base Prescaler = 32
    215            *            @arg TIM5_Prescaler_64: Time base Prescaler = 64
    216            *            @arg TIM5_Prescaler_128: Time base Prescaler = 128                            
    217            * @param  TIM5_CounterMode: Counter mode
    218            *          This parameter can be one of the following values:
    219            *            @arg TIM5_CounterMode_Up: Counter Up Mode
    220            *            @arg TIM5_CounterMode_Down: Counter Down Mode
    221            *            @arg TIM5_CounterMode_CenterAligned1: Counter Central aligned Mode 1
    222            *            @arg TIM5_CounterMode_CenterAligned2: Counter Central aligned Mode 2
    223            *            @arg TIM5_CounterMode_CenterAligned3: Counter Central aligned Mode 3        
    224            * @param  TIM5_Period: This parameter must be a value between 0x0000 and 0xFFFF.
    225            * @retval None
    226            */
    227          

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine6:
   \   000000 9093         LDW       Y, X
   \   000002 4F           CLR       A
   \   000003 01           RRWA      X, A
   \   000004 9F           LD        A, XL
   \   000005 C7 530F      LD        L:0x530f, A
   \   000008 909F         LD        A, YL
   \   00000A C7 5310      LD        L:0x5310, A
   \   00000D 81           RET

   \                                 In section .near_func.text, align 1
    228          void TIM5_TimeBaseInit(TIM5_Prescaler_TypeDef TIM5_Prescaler,
    229                                 TIM5_CounterMode_TypeDef TIM5_CounterMode,
    230                                 uint16_t TIM5_Period)
    231          {
   \                     TIM5_TimeBaseInit:
   \   000000 B7 ..        LD        S:?b1, A
   \   000002 CD ....      CALL      L:?Subroutine6
    232          
    233            assert_param(IS_TIM5_PRESCALER(TIM5_Prescaler));
    234            assert_param(IS_TIM5_COUNTER_MODE(TIM5_CounterMode));
    235          
    236          
    237          
    238            /* Set the Autoreload value */
    239            TIM5->ARRH = (uint8_t)(TIM5_Period >> 8) ;
    240            TIM5->ARRL = (uint8_t)(TIM5_Period);
    241          
    242            /* Set the Prescaler value */
    243            TIM5->PSCR = (uint8_t)(TIM5_Prescaler);
   \                     ??CrossCallReturnLabel_14:
   \   000005 B6 ..        LD        A, S:?b1
   \   000007 C7 530E      LD        L:0x530e, A
    244          
    245            /* Select the Counter Mode */
    246            TIM5->CR1 &= (uint8_t)((uint8_t)(~TIM_CR1_CMS)) & ((uint8_t)(~TIM_CR1_DIR));
   \   00000A C6 5300      LD        A, L:0x5300
   \   00000D A4 8F        AND       A, #0x8f
   \   00000F C7 5300      LD        L:0x5300, A
    247            TIM5->CR1 |= (uint8_t)(TIM5_CounterMode);
   \   000012 B6 ..        LD        A, S:?b0
   \   000014 CA 5300      OR        A, L:0x5300
   \   000017 C7 5300      LD        L:0x5300, A
    248          
    249            /* Generate an update event to reload the Prescaler value immediately */
    250            TIM5->EGR = TIM5_EventSource_Update;
   \   00001A 35 01 5308   MOV       L:0x5308, #0x1
    251          }
   \   00001E 81           RET
    252          
    253          /**
    254            * @brief  Configures the TIM5 Prescaler.
    255            * @param  Prescaler: Specifies the Prescaler Register value
    256            *          This parameter can be one of the following values:
    257            *            @arg TIM5_Prescaler_1: Time base Prescaler = 1 (No effect)
    258            *            @arg TIM5_Prescaler_2: Time base Prescaler = 2
    259            *            @arg TIM5_Prescaler_4: Time base Prescaler = 4
    260            *            @arg TIM5_Prescaler_8: Time base Prescaler = 8
    261            *            @arg TIM5_Prescaler_16: Time base Prescaler = 16
    262            *            @arg TIM5_Prescaler_32: Time base Prescaler = 32
    263            *            @arg TIM5_Prescaler_64: Time base Prescaler = 64
    264            *            @arg TIM5_Prescaler_128: Time base Prescaler = 128  
    265            * @param  TIM5_PSCReloadMode: Specifies the TIM5 Prescaler Reload mode.
    266            *          This parameter can be one of the following values:
    267            *            @arg TIM5_PSCReloadMode_Update: Prescaler value is reloaded at every update
    268            *            @arg TIM5_PSCReloadMode_Immediate: Prescaler value is reloaded at every update  
    269            * @retval None
    270            */

   \                                 In section .near_func.text, align 1
    271          void TIM5_PrescalerConfig(TIM5_Prescaler_TypeDef Prescaler,
    272                                    TIM5_PSCReloadMode_TypeDef TIM5_PSCReloadMode)
    273          {
    274            /* Check the parameters */
    275            assert_param(IS_TIM5_PRESCALER(Prescaler));
    276            assert_param(IS_TIM5_PRESCALER_RELOAD(TIM5_PSCReloadMode));
    277          
    278            /* Set the Prescaler value */
    279            TIM5->PSCR = (uint8_t)(Prescaler);
   \                     TIM5_PrescalerConfig:
   \   000000 C7 530E      LD        L:0x530e, A
    280          
    281            /* Set or reset the UG Bit */
    282            if (TIM5_PSCReloadMode == TIM5_PSCReloadMode_Immediate)
   \   000003 B6 ..        LD        A, S:?b0
   \   000005 A1 01        CP        A, #0x1
   \   000007 26 05        JRNE      L:??TIM5_PrescalerConfig_0
    283            {
    284              TIM5->EGR |= TIM_EGR_UG ;
   \   000009 7210 5308    BSET      L:0x5308, #0x0
   \   00000D 81           RET
    285            }
    286            else
    287            {
    288              TIM5->EGR &= (uint8_t)(~TIM_EGR_UG) ;
   \                     ??TIM5_PrescalerConfig_0:
   \   00000E 7211 5308    BRES      L:0x5308, #0x0
    289            }
    290          }
   \   000012 81           RET
    291          
    292          /**
    293            * @brief  Specifies the TIM5 Counter Mode to be used.
    294            * @param  TIM5_CounterMode: Specifies the Counter Mode to be used
    295            *          This parameter can be one of the following values:
    296            *            @arg TIM5_CounterMode_Up: Counter Up Mode
    297            *            @arg TIM5_CounterMode_Down: Counter Down Mode
    298            *            @arg TIM5_CounterMode_CenterAligned1: Counter Central aligned Mode 1
    299            *            @arg TIM5_CounterMode_CenterAligned2: Counter Central aligned Mode 2
    300            *            @arg TIM5_CounterMode_CenterAligned3: Counter Central aligned Mode 3      
    301            * @retval None
    302            */

   \                                 In section .near_func.text, align 1
    303          void TIM5_CounterModeConfig(TIM5_CounterMode_TypeDef TIM5_CounterMode)
    304          {
   \                     TIM5_CounterModeConfig:
   \   000000 B7 ..        LD        S:?b0, A
    305            uint8_t tmpcr1 = 0;
    306          
    307            /* Check the parameters */
    308            assert_param(IS_TIM5_COUNTER_MODE(TIM5_CounterMode));
    309          
    310            tmpcr1 = TIM5->CR1;
   \   000002 C6 5300      LD        A, L:0x5300
    311          
    312            /* Reset the CMS and DIR Bits */
    313            tmpcr1 &= (uint8_t)((uint8_t)(~TIM_CR1_CMS) & (uint8_t)(~TIM_CR1_DIR));
    314          
    315            /* Set the Counter Mode */
    316            tmpcr1 |= (uint8_t)TIM5_CounterMode;
    317          
    318            TIM5->CR1 = tmpcr1;
   \   000005 A4 8F        AND       A, #0x8f
   \   000007 BA ..        OR        A, S:?b0
   \   000009 C7 5300      LD        L:0x5300, A
    319          }
   \   00000C 81           RET
    320          
    321          /**
    322            * @brief  Sets the TIM5 Counter Register value.
    323            * @param  Counter: Specifies the Counter register new value.
    324            *          This parameter is between 0x0000 and 0xFFFF.
    325            * @retval None
    326            */

   \                                 In section .near_func.text, align 1
    327          void TIM5_SetCounter(uint16_t Counter)
    328          {
   \                     TIM5_SetCounter:
   \   000000 9093         LDW       Y, X
    329          
    330            /* Set the Counter Register value */
    331            TIM5->CNTRH = (uint8_t)(Counter >> 8);
   \   000002 4F           CLR       A
   \   000003 01           RRWA      X, A
   \   000004 9F           LD        A, XL
   \   000005 C7 530C      LD        L:0x530c, A
    332            TIM5->CNTRL = (uint8_t)(Counter);
   \   000008 909F         LD        A, YL
   \   00000A C7 530D      LD        L:0x530d, A
    333          }
   \   00000D 81           RET
    334          
    335          /**
    336            * @brief  Sets the TIM5 Autoreload Register value.
    337            * @param  Autoreload: Specifies the Autoreload register new value.
    338            *          This parameter is between 0x0000 and 0xFFFF.
    339            * @retval None
    340            */

   \                                 In section .near_func.text, align 1
    341          void TIM5_SetAutoreload(uint16_t Autoreload)
    342          {
   \                     TIM5_SetAutoreload:
   \   000000 CD ....      CALL      L:?Subroutine6
    343            /* Set the Autoreload Register value */
    344            TIM5->ARRH = (uint8_t)(Autoreload >> 8);
    345            TIM5->ARRL = (uint8_t)(Autoreload);
    346          }
   \                     ??CrossCallReturnLabel_13:
   \   000003 81           RET
    347          
    348          /**
    349            * @brief  Gets the TIM5 Counter value.
    350            * @param  None
    351            * @retval Counter Register value.
    352            */

   \                                 In section .near_func.text, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000 B7 ..        LD        S:?b0, A
   \   000002 5F           CLRW      X
   \   000003 41           EXG       A, XL
   \   000004 B6 ..        LD        A, S:?b1
   \   000006 41           EXG       A, XL
   \   000007 4F           CLR       A
   \   000008 02           RLWA      X, A
   \   000009 905F         CLRW      Y
   \   00000B B6 ..        LD        A, S:?b0
   \   00000D 61           EXG       A, YL
   \   00000E BF ..        LDW       S:?w0, X
   \   000010 93           LDW       X, Y
   \   000011 02           RLWA      X, A
   \   000012 BA ..        OR        A, S:?b0
   \   000014 01           RRWA      X, A
   \   000015 81           RET

   \                                 In section .near_func.text, align 1
    353          uint16_t TIM5_GetCounter(void)
    354          {
    355            uint16_t tmpcnt = 0;
    356            uint8_t tmpcntrl, tmpcntrh;
    357          
    358            tmpcntrh = TIM5->CNTRH;
   \                     TIM5_GetCounter:
   \   000000 C6 530C      LD        A, L:0x530c
   \   000003 B7 ..        LD        S:?b1, A
    359            tmpcntrl = TIM5->CNTRL;
   \   000005 C6 530D      LD        A, L:0x530d
   \   000008 CD ....      CALL      L:?Subroutine0
    360          
    361            tmpcnt = (uint16_t)(tmpcntrl);
    362            tmpcnt |= (uint16_t)((uint16_t)tmpcntrh << 8);
    363            /* Get the Counter Register value */
    364            return ((uint16_t)tmpcnt);
   \                     ??CrossCallReturnLabel_2:
   \   00000B 81           RET
    365          }
    366          
    367          /**
    368            * @brief  Gets the TIM5 Prescaler value.
    369            * @param  None
    370            * @retval TIM5 Prescaler, it can be one of the following values:
    371            *            - TIM5_Prescaler_1: Time base Prescaler = 1 (No effect)
    372            *            - TIM5_Prescaler_2: Time base Prescaler = 2
    373            *            - TIM5_Prescaler_4: Time base Prescaler = 4
    374            *            - TIM5_Prescaler_8: Time base Prescaler = 8
    375            *            - TIM5_Prescaler_16: Time base Prescaler = 16
    376            *            - TIM5_Prescaler_32: Time base Prescaler = 32
    377            *            - TIM5_Prescaler_64: Time base Prescaler = 64
    378            *            - TIM5_Prescaler_128: Time base Prescaler = 128    
    379            */

   \                                 In section .near_func.text, align 1
    380          TIM5_Prescaler_TypeDef TIM5_GetPrescaler(void)
    381          {
    382            /* Get the Prescaler Register value */
    383            return ((TIM5_Prescaler_TypeDef)TIM5->PSCR);
   \                     TIM5_GetPrescaler:
   \   000000 C6 530E      LD        A, L:0x530e
   \   000003 81           RET
    384          }
    385          
    386          /**
    387            * @brief  Enables or Disables the TIM5 Update event.
    388            * @param  NewState: The new state of the TIM5 peripheral Preload register.
    389            *          This parameter can be ENABLE or DISABLE
    390            * @retval None
    391            */
    392          

   \                                 In section .near_func.text, align 1
    393          void TIM5_UpdateDisableConfig(FunctionalState NewState)
    394          {
    395            /* Check the parameters */
    396            assert_param(IS_FUNCTIONAL_STATE(NewState));
    397          
    398            /* Set or Reset the UDIS Bit */
    399            if (NewState != DISABLE)
   \                     TIM5_UpdateDisableConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM5_UpdateDisableConfig_0
    400            {
    401              TIM5->CR1 |= TIM_CR1_UDIS;
   \   000003 7212 5300    BSET      L:0x5300, #0x1
   \   000007 81           RET
    402            }
    403            else
    404            {
    405              TIM5->CR1 &= (uint8_t)(~TIM_CR1_UDIS);
   \                     ??TIM5_UpdateDisableConfig_0:
   \   000008 7213 5300    BRES      L:0x5300, #0x1
    406            }
    407          }
   \   00000C 81           RET
    408          
    409          /**
    410            * @brief  Selects the TIM5 Update Request Interrupt source.
    411            * @param  TIM5_UpdateSource: Specifies the Update source.
    412            *          This parameter can be one of the following values:
    413            *            @arg TIM5_UpdateSource_Global: Global Update request source
    414            *            @arg TIM5_UpdateSource_Regular: Regular Update request source 
    415            * @retval None
    416            */

   \                                 In section .near_func.text, align 1
    417          void TIM5_UpdateRequestConfig(TIM5_UpdateSource_TypeDef TIM5_UpdateSource)
    418          {
    419            /* Check the parameters */
    420            assert_param(IS_TIM5_UPDATE_SOURCE(TIM5_UpdateSource));
    421          
    422            /* Set or Reset the URS Bit */
    423            if (TIM5_UpdateSource == TIM5_UpdateSource_Regular)
   \                     TIM5_UpdateRequestConfig:
   \   000000 A1 01        CP        A, #0x1
   \   000002 26 05        JRNE      L:??TIM5_UpdateRequestConfig_0
    424            {
    425              TIM5->CR1 |= TIM_CR1_URS ;
   \   000004 7214 5300    BSET      L:0x5300, #0x2
   \   000008 81           RET
    426            }
    427            else
    428            {
    429              TIM5->CR1 &= (uint8_t)(~TIM_CR1_URS);
   \                     ??TIM5_UpdateRequestConfig_0:
   \   000009 7215 5300    BRES      L:0x5300, #0x2
    430            }
    431          }
   \   00000D 81           RET
    432          
    433          /**
    434            * @brief  Enables or disables TIM5 peripheral Preload register on ARR.
    435            * @param  NewState: The new state of the TIM5 peripheral Preload register.
    436            *          This parameter can be ENABLE or DISABLE
    437            * @retval None
    438            */

   \                                 In section .near_func.text, align 1
    439          void TIM5_ARRPreloadConfig(FunctionalState NewState)
    440          {
    441            /* Check the parameters */
    442            assert_param(IS_FUNCTIONAL_STATE(NewState));
    443          
    444            /* Set or Reset the ARPE Bit */
    445            if (NewState != DISABLE)
   \                     TIM5_ARRPreloadConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM5_ARRPreloadConfig_0
    446            {
    447              TIM5->CR1 |= TIM_CR1_ARPE;
   \   000003 721E 5300    BSET      L:0x5300, #0x7
   \   000007 81           RET
    448            }
    449            else
    450            {
    451              TIM5->CR1 &= (uint8_t)(~TIM_CR1_ARPE);
   \                     ??TIM5_ARRPreloadConfig_0:
   \   000008 721F 5300    BRES      L:0x5300, #0x7
    452            }
    453          }
   \   00000C 81           RET
    454          
    455          /**
    456            * @brief  Selects the TIM’s One Pulse Mode.
    457            * @param  TIM5_OPMode: Specifies the OPM Mode to be used.
    458            *          This parameter can be one of the following values:
    459            *            @arg TIM5_OPMode_Single: Single one Pulse mode (OPM Active)
    460            *            @arg TIM5_OPMode_Repetitive: Single one Pulse mode (OPM Active)  
    461            * @retval None
    462            */

   \                                 In section .near_func.text, align 1
    463          void TIM5_SelectOnePulseMode(TIM5_OPMode_TypeDef TIM5_OPMode)
    464          {
    465            /* Check the parameters */
    466            assert_param(IS_TIM5_OPM_MODE(TIM5_OPMode));
    467          
    468            /* Set or Reset the OPM Bit */
    469            if (TIM5_OPMode == TIM5_OPMode_Single)
   \                     TIM5_SelectOnePulseMode:
   \   000000 A1 01        CP        A, #0x1
   \   000002 26 05        JRNE      L:??TIM5_SelectOnePulseMode_0
    470            {
    471              TIM5->CR1 |= TIM_CR1_OPM ;
   \   000004 7216 5300    BSET      L:0x5300, #0x3
   \   000008 81           RET
    472            }
    473            else
    474            {
    475              TIM5->CR1 &= (uint8_t)(~TIM_CR1_OPM);
   \                     ??TIM5_SelectOnePulseMode_0:
   \   000009 7217 5300    BRES      L:0x5300, #0x3
    476            }
    477          }
   \   00000D 81           RET
    478          
    479          /**
    480            * @brief  Enables or disables the TIM5 peripheral.
    481            * @param  NewState: The new state of the TIM5 peripheral.
    482            *          This parameter can be ENABLE or DISABLE
    483            * @retval None
    484            */

   \                                 In section .near_func.text, align 1
    485          void TIM5_Cmd(FunctionalState NewState)
    486          {
    487            /* Check the parameters */
    488            assert_param(IS_FUNCTIONAL_STATE(NewState));
    489          
    490            /* set or Reset the CEN Bit */
    491            if (NewState != DISABLE)
   \                     TIM5_Cmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM5_Cmd_0
    492            {
    493              TIM5->CR1 |= TIM_CR1_CEN;
   \   000003 7210 5300    BSET      L:0x5300, #0x0
   \   000007 81           RET
    494            }
    495            else
    496            {
    497              TIM5->CR1 &= (uint8_t)(~TIM_CR1_CEN);
   \                     ??TIM5_Cmd_0:
   \   000008 7211 5300    BRES      L:0x5300, #0x0
    498            }
    499          }
   \   00000C 81           RET
    500          
    501          /**
    502            * @}
    503            */
    504          
    505          /** @defgroup TIM5_Group2 Output Compare management functions
    506           *  @brief    Output Compare management functions 
    507           *
    508          @verbatim   
    509           ===============================================================================
    510                                  Output Compare management functions
    511           ===============================================================================  
    512             
    513                 ===================================================================      
    514                        TIM5 Driver: how to use it in Output Compare Mode
    515                 =================================================================== 
    516                 To use the Timer in Output Compare mode, the following steps are mandatory:
    517                 
    518                 1. Enable TIM5 clock using CLK_PeripheralClockConfig(CLK_Peripheral_TIM5, ENABLE) function.
    519                 
    520                 2. Configure the TIM5 pins in output mode by configuring the corresponding GPIO pins
    521                    
    522                 3. Configure the Time base unit as described in the first part of this driver, if needed,
    523                    otherwise the Timer will run with the default configuration:
    524                    - Autoreload value = 0xFFFF
    525                    - Prescaler value = 0x0000
    526                    - Counter mode = Up counting
    527                
    528                 4. Call TIM5_OCxInit() to configure the channel x with the desired parameters
    529                    including:
    530                    - TIM5 Output Compare mode: TIM5_OCMode
    531                    - TIM5 Output State: TIM5_OutputState
    532                    - TIM5 Pulse value: TIM5_Pulse
    533                    - TIM5 Output Compare Polarity: TIM5_OCPolarity
    534                    - TIM5 Output Idle State: TIM5_OCIdleState
    535                 
    536                 5. Call the TIM5_Cmd(ENABLE) function to enable the TIM5 counter.
    537                 
    538                 Note1: All other functions can be used separately to modify, if needed,
    539                    a specific feature of the Timer. 
    540                 
    541                 Note2: If the corresponding interrupt or DMA request are needed, the user should:
    542                        1. Enable global interrupts (or the DMA) to use the TIM5 interrupts (or DMA requests). 
    543                        2. Enable the corresponding interrupt (or DMA request) using the function 
    544                        TIM5_ITConfig(TIM5_IT_CCx) (or TIM5_DMACmd(TIM5_DMASource_CCx))   
    545          
    546          @endverbatim
    547            * @{
    548            */
    549          
    550          /**
    551            * @brief  Initializes the TIM5 Channel1 according to the specified parameters.
    552            * @param  TIM5_OCMode: Output Compare Mode 
    553            *          This parameter can be one of the following values:
    554            *            @arg TIM5_OCMode_Timing: Timing (Frozen) Mode
    555            *            @arg TIM5_OCMode_Active: Active Mode
    556            *            @arg TIM5_OCMode_Inactive: Inactive Mode
    557            *            @arg TIM5_OCMode_Toggle: Toggle Mode
    558            *            @arg TIM5_OCMode_PWM1: PWM Mode 1
    559            *            @arg TIM5_OCMode_PWM2: PWM Mode 2          
    560            * @param  TIM5_OutputState: Output state
    561            *          This parameter can be one of the following values:
    562            *            @arg TIM5_OutputState_Disable: Output compare State disabled (channel output disabled)
    563            *            @arg TIM5_OutputState_Enable: Output compare State enabled (channel output enabled)
    564            * @param  TIM5_Pulse: This parameter must be a value between 0x0000 and 0xFFFF.
    565            * @param  TIM5_OCPolarity: Polarity
    566            *          This parameter can be one of the following values:
    567            *            @arg TIM5_OCPolarity_High: Output compare polarity  = High
    568            *            @arg TIM5_OCPolarity_Low: Output compare polarity  = Low 
    569            * @param  TIM5_OCIdleState: Output Compare Idle State
    570            *          This parameter can be one of the following values:
    571            *            @arg TIM5_OCIdleState_Reset: Output Compare Idle state  = Reset
    572            *            @arg TIM5_OCIdleState_Set: Output Compare Idle state  = Set
    573            * @retval None
    574            */

   \                                 In section .near_func.text, align 1
    575          void TIM5_OC1Init(TIM5_OCMode_TypeDef TIM5_OCMode,
    576                            TIM5_OutputState_TypeDef TIM5_OutputState,
    577                            uint16_t TIM5_Pulse,
    578                            TIM5_OCPolarity_TypeDef TIM5_OCPolarity,
    579                            TIM5_OCIdleState_TypeDef TIM5_OCIdleState)
    580          {
   \                     TIM5_OC1Init:
   \   000000 B7 ..        LD        S:?b3, A
   \   000002 9093         LDW       Y, X
    581            uint8_t tmpccmr1 = 0;
    582          
    583            /* Check the parameters */
    584            assert_param(IS_TIM5_OC_MODE(TIM5_OCMode));
    585            assert_param(IS_TIM5_OUTPUT_STATE(TIM5_OutputState));
    586            assert_param(IS_TIM5_OC_POLARITY(TIM5_OCPolarity));
    587            assert_param(IS_TIM5_OCIDLE_STATE(TIM5_OCIdleState));
    588          
    589            tmpccmr1 = TIM5->CCMR1;
   \   000004 C6 5309      LD        A, L:0x5309
    590          
    591            /* Disable the Channel 1: Reset the CCE Bit */
    592            TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
   \   000007 7211 530B    BRES      L:0x530b, #0x0
    593            /* Reset the Output Compare Bits */
    594            tmpccmr1 &= (uint8_t)(~TIM_CCMR_OCM);
    595          
    596            /* Set the Output Compare Mode */
    597            tmpccmr1 |= (uint8_t)TIM5_OCMode;
    598          
    599            TIM5->CCMR1 = tmpccmr1;
   \   00000B A4 8F        AND       A, #0x8f
   \   00000D BA ..        OR        A, S:?b3
   \   00000F C7 5309      LD        L:0x5309, A
    600          
    601            /* Set the Output State */
    602            if (TIM5_OutputState == TIM5_OutputState_Enable)
   \   000012 B6 ..        LD        A, S:?b0
   \   000014 A1 01        CP        A, #0x1
   \   000016 26 06        JRNE      L:??TIM5_OC1Init_0
    603            {
    604              TIM5->CCER1 |= TIM_CCER1_CC1E;
   \   000018 7210 530B    BSET      L:0x530b, #0x0
   \   00001C 20 04        JRA       L:??TIM5_OC1Init_1
    605            }
    606            else
    607            {
    608              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
   \                     ??TIM5_OC1Init_0:
   \   00001E 7211 530B    BRES      L:0x530b, #0x0
    609            }
    610          
    611            /* Set the Output Polarity */
    612            if (TIM5_OCPolarity == TIM5_OCPolarity_Low)
   \                     ??TIM5_OC1Init_1:
   \   000022 B6 ..        LD        A, S:?b1
   \   000024 A1 01        CP        A, #0x1
   \   000026 26 06        JRNE      L:??TIM5_OC1Init_2
    613            {
    614              TIM5->CCER1 |= TIM_CCER1_CC1P;
   \   000028 7212 530B    BSET      L:0x530b, #0x1
   \   00002C 20 04        JRA       L:??TIM5_OC1Init_3
    615            }
    616            else
    617            {
    618              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P);
   \                     ??TIM5_OC1Init_2:
   \   00002E 7213 530B    BRES      L:0x530b, #0x1
    619            }
    620          
    621            /* Set the Output Idle state */
    622            if (TIM5_OCIdleState == TIM5_OCIdleState_Set)
   \                     ??TIM5_OC1Init_3:
   \   000032 B6 ..        LD        A, S:?b2
   \   000034 A1 01        CP        A, #0x1
   \   000036 26 06        JRNE      L:??TIM5_OC1Init_4
    623            {
    624              TIM5->OISR |= TIM_OISR_OIS1;
   \   000038 7210 5316    BSET      L:0x5316, #0x0
   \   00003C 20 04        JRA       L:??TIM5_OC1Init_5
    625            }
    626            else
    627            {
    628              TIM5->OISR &= (uint8_t)(~TIM_OISR_OIS1);
   \                     ??TIM5_OC1Init_4:
   \   00003E 7211 5316    BRES      L:0x5316, #0x0
    629            }
    630          
    631            /* Set the Pulse value */
    632            TIM5->CCR1H = (uint8_t)(TIM5_Pulse >> 8);
   \                     ??TIM5_OC1Init_5:
   \   000042 CD ....      CALL      L:?Subroutine5
    633            TIM5->CCR1L = (uint8_t)(TIM5_Pulse);
    634          }
   \                     ??CrossCallReturnLabel_12:
   \   000045 81           RET

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine5:
   \   000000 4F           CLR       A
   \   000001 01           RRWA      X, A
   \   000002 9F           LD        A, XL
   \   000003 C7 5311      LD        L:0x5311, A
   \   000006 909F         LD        A, YL
   \   000008 C7 5312      LD        L:0x5312, A
   \   00000B 81           RET
    635          
    636          /**
    637            * @brief  Initializes the TIM5 Channel2 according to the specified parameters.
    638            * @param  TIM5_OCMode: Output Compare Mode 
    639            *          This parameter can be one of the following values:
    640            *            @arg TIM5_OCMode_Timing: Timing (Frozen) Mode
    641            *            @arg TIM5_OCMode_Active: Active Mode
    642            *            @arg TIM5_OCMode_Inactive: Inactive Mode
    643            *            @arg TIM5_OCMode_Toggle: Toggle Mode
    644            *            @arg TIM5_OCMode_PWM1: PWM Mode 1
    645            *            @arg TIM5_OCMode_PWM2: PWM Mode 2          
    646            * @param  TIM5_OutputState: Output state
    647            *          This parameter can be one of the following values:
    648            *            @arg TIM5_OutputState_Disable: Output compare State disabled (channel output disabled)
    649            *            @arg TIM5_OutputState_Enable: Output compare State enabled (channel output enabled)
    650            * @param  TIM5_Pulse: This parameter must be a value between 0x0000 and 0xFFFF.
    651            * @param  TIM5_OCPolarity: Polarity
    652            *          This parameter can be one of the following values:
    653            *            @arg TIM5_OCPolarity_High: Output compare polarity  = High
    654            *            @arg TIM5_OCPolarity_Low: Output compare polarity  = Low 
    655            * @param  TIM5_OCIdleState: Output Compare Idle State
    656            *          This parameter can be one of the following values:
    657            *            @arg TIM5_OCIdleState_Reset: Output Compare Idle state  = Reset
    658            *            @arg TIM5_OCIdleState_Set: Output Compare Idle state  = Set
    659            * @retval None
    660            */

   \                                 In section .near_func.text, align 1
    661          void TIM5_OC2Init(TIM5_OCMode_TypeDef TIM5_OCMode,
    662                            TIM5_OutputState_TypeDef TIM5_OutputState,
    663                            uint16_t TIM5_Pulse,
    664                            TIM5_OCPolarity_TypeDef TIM5_OCPolarity,
    665                            TIM5_OCIdleState_TypeDef TIM5_OCIdleState)
    666          {
   \                     TIM5_OC2Init:
   \   000000 B7 ..        LD        S:?b3, A
   \   000002 9093         LDW       Y, X
    667            uint8_t tmpccmr2 = 0;
    668          
    669            /* Check the parameters */
    670            assert_param(IS_TIM5_OC_MODE(TIM5_OCMode));
    671            assert_param(IS_TIM5_OUTPUT_STATE(TIM5_OutputState));
    672            assert_param(IS_TIM5_OC_POLARITY(TIM5_OCPolarity));
    673            assert_param(IS_TIM5_OCIDLE_STATE(TIM5_OCIdleState));
    674          
    675            tmpccmr2 = TIM5->CCMR2;
   \   000004 C6 530A      LD        A, L:0x530a
    676          
    677            /* Disable the Channel 2: Reset the CCE Bit */
    678            TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
   \   000007 7219 530B    BRES      L:0x530b, #0x4
    679          
    680            /* Reset the Output Compare Bits */
    681            tmpccmr2 &= (uint8_t)(~TIM_CCMR_OCM);
    682          
    683            /* Set the Output Compare Mode */
    684            tmpccmr2 |= (uint8_t)TIM5_OCMode;
    685          
    686            TIM5->CCMR2 = tmpccmr2;
   \   00000B A4 8F        AND       A, #0x8f
   \   00000D BA ..        OR        A, S:?b3
   \   00000F C7 530A      LD        L:0x530a, A
    687          
    688            /* Set the Output State */
    689            if (TIM5_OutputState == TIM5_OutputState_Enable)
   \   000012 B6 ..        LD        A, S:?b0
   \   000014 A1 01        CP        A, #0x1
   \   000016 26 06        JRNE      L:??TIM5_OC2Init_0
    690            {
    691              TIM5->CCER1 |= TIM_CCER1_CC2E;
   \   000018 7218 530B    BSET      L:0x530b, #0x4
   \   00001C 20 04        JRA       L:??TIM5_OC2Init_1
    692            }
    693            else
    694            {
    695              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
   \                     ??TIM5_OC2Init_0:
   \   00001E 7219 530B    BRES      L:0x530b, #0x4
    696            }
    697          
    698            /* Set the Output Polarity */
    699            if (TIM5_OCPolarity == TIM5_OCPolarity_Low)
   \                     ??TIM5_OC2Init_1:
   \   000022 B6 ..        LD        A, S:?b1
   \   000024 A1 01        CP        A, #0x1
   \   000026 26 06        JRNE      L:??TIM5_OC2Init_2
    700            {
    701              TIM5->CCER1 |= TIM_CCER1_CC2P;
   \   000028 721A 530B    BSET      L:0x530b, #0x5
   \   00002C 20 04        JRA       L:??TIM5_OC2Init_3
    702            }
    703            else
    704            {
    705              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P);
   \                     ??TIM5_OC2Init_2:
   \   00002E 721B 530B    BRES      L:0x530b, #0x5
    706            }
    707          
    708          
    709            /* Set the Output Idle state */
    710            if (TIM5_OCIdleState == TIM5_OCIdleState_Set)
   \                     ??TIM5_OC2Init_3:
   \   000032 B6 ..        LD        A, S:?b2
   \   000034 A1 01        CP        A, #0x1
   \   000036 26 06        JRNE      L:??TIM5_OC2Init_4
    711            {
    712              TIM5->OISR |= TIM_OISR_OIS2;
   \   000038 7214 5316    BSET      L:0x5316, #0x2
   \   00003C 20 04        JRA       L:??TIM5_OC2Init_5
    713            }
    714            else
    715            {
    716              TIM5->OISR &= (uint8_t)(~TIM_OISR_OIS2);
   \                     ??TIM5_OC2Init_4:
   \   00003E 7215 5316    BRES      L:0x5316, #0x2
    717            }
    718          
    719            /* Set the Pulse value */
    720            TIM5->CCR2H = (uint8_t)(TIM5_Pulse >> 8);
   \                     ??TIM5_OC2Init_5:
   \   000042 CD ....      CALL      L:?Subroutine4
    721            TIM5->CCR2L = (uint8_t)(TIM5_Pulse);
    722          }
   \                     ??CrossCallReturnLabel_10:
   \   000045 81           RET

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine4:
   \   000000 4F           CLR       A
   \   000001 01           RRWA      X, A
   \   000002 9F           LD        A, XL
   \   000003 C7 5313      LD        L:0x5313, A
   \   000006 909F         LD        A, YL
   \   000008 C7 5314      LD        L:0x5314, A
   \   00000B 81           RET
    723          
    724          /**
    725            * @brief  Configures the Break feature, dead time, Lock level, the OSSI,
    726            *         and the AOE(automatic output enable).
    727            * @param  TIM5_OSSIState: Off-State Selection for Idle mode states.
    728            *          This parameter can be one of the following values:
    729            *            @arg TIM5_OSSIState_Enable: Off-State Selection for Idle mode enabled
    730            *            @arg TIM5_OSSIState_Disable: Off-State Selection for Idle mode disabled 
    731            * @param  TIM5_LockLevel: Lock level.
    732            *          This parameter can be one of the following values:
    733            *            @arg TIM5_LockLevel_Off: Lock option disabled
    734            *            @arg TIM5_LockLevel_1: Select Lock Level 1
    735            *            @arg TIM5_LockLevel_2: Select Lock Level 2
    736            *            @arg TIM5_LockLevel_3: Select Lock Level 3    
    737            * @param  TIM5_BreakState: Break Input enable/disable .
    738            *          This parameter can be one of the following values:
    739            *            @arg TIM5_BreakState_Disable: Break State disabled (break option disabled)
    740            *            @arg TIM5_BreakState_Enable: Break State enabled (break option enabled) 
    741            * @param  TIM5_BreakPolarity: Break Polarity.
    742            *          This parameter can be one of the following values:
    743            *            @arg TIM5_BreakPolarity_High: if Break, channel polarity = High
    744            *            @arg TIM5_BreakPolarity_Low: if Break, channel polarity = Low   
    745            * @param  TIM5_AutomaticOutput: TIM5 AOE Bit Set/Reset .
    746            *          This parameter can be one of the following values:
    747            *            @arg TIM5_AutomaticOutput_Enable: Automatic Output option enabled
    748            *            @arg TIM5_AutomaticOutput_Disable: Automatic Output option disabled
    749            * @retval None
    750            */

   \                                 In section .near_func.text, align 1
    751          void TIM5_BKRConfig(TIM5_OSSIState_TypeDef TIM5_OSSIState,
    752                              TIM5_LockLevel_TypeDef TIM5_LockLevel,
    753                              TIM5_BreakState_TypeDef TIM5_BreakState,
    754                              TIM5_BreakPolarity_TypeDef TIM5_BreakPolarity,
    755                              TIM5_AutomaticOutput_TypeDef TIM5_AutomaticOutput)
    756          
    757          {
   \                     TIM5_BKRConfig:
   \   000000 B7 ..        LD        S:?b4, A
   \   000002 B6 ..        LD        A, S:?b0
    758            /* Check the parameters */
    759            assert_param(IS_TIM5_OSSI_STATE(TIM5_OSSIState));
    760            assert_param(IS_TIM5_LOCK_LEVEL(TIM5_LockLevel));
    761            assert_param(IS_TIM5_BREAK_STATE(TIM5_BreakState));
    762            assert_param(IS_TIM5_BREAK_POLARITY(TIM5_BreakPolarity));
    763            assert_param(IS_TIM5_AUTOMATIC_OUTPUT_STATE(TIM5_AutomaticOutput));
    764          
    765          
    766          
    767            /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSI State,
    768            the dead time value and the Automatic Output Enable Bit */
    769            TIM5->BKR = (uint8_t)((uint8_t)((uint8_t)((uint8_t)((uint8_t)TIM5_OSSIState | (uint8_t)TIM5_LockLevel) | \
    770                                            (uint8_t)((uint8_t)TIM5_BreakState | (uint8_t)TIM5_BreakPolarity)) | \
    771                                            TIM5_AutomaticOutput));
   \   000004 BA ..        OR        A, S:?b4
   \   000006 BA ..        OR        A, S:?b1
   \   000008 BA ..        OR        A, S:?b2
   \   00000A BA ..        OR        A, S:?b3
   \   00000C C7 5315      LD        L:0x5315, A
    772          }
   \   00000F 81           RET
    773          
    774          /**
    775            * @brief  Enables or disables the TIM5 peripheral Main Outputs.
    776            * @param  NewState: The new state of the TIM5 peripheral.
    777            *          This parameter can be ENABLE or DISABLE
    778            * @retval None
    779            */

   \                                 In section .near_func.text, align 1
    780          void TIM5_CtrlPWMOutputs(FunctionalState NewState)
    781          {
    782            /* Check the parameters */
    783            assert_param(IS_FUNCTIONAL_STATE(NewState));
    784          
    785            /* Set or Reset the MOE Bit */
    786          
    787            if (NewState != DISABLE)
   \                     TIM5_CtrlPWMOutputs:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM5_CtrlPWMOutputs_0
    788            {
    789              TIM5->BKR |= TIM_BKR_MOE ;
   \   000003 721E 5315    BSET      L:0x5315, #0x7
   \   000007 81           RET
    790            }
    791            else
    792            {
    793              TIM5->BKR &= (uint8_t)(~TIM_BKR_MOE) ;
   \                     ??TIM5_CtrlPWMOutputs_0:
   \   000008 721F 5315    BRES      L:0x5315, #0x7
    794            }
    795          }
   \   00000C 81           RET
    796          
    797          /**
    798            * @brief  Selects the TIM5 Output Compare Mode. This function disables the
    799            *         selected channel before changing the Output Compare Mode. User has to
    800            *         enable this channel using TIM5_CCxCmd and TIM5_CCxNCmd functions.
    801            * @param  TIM5_Channel: Specifies the TIM5 Channel.
    802            *          This parameter can be one of the following values:
    803            *            @arg TIM5_Channel_1: Channel 1
    804            *            @arg TIM5_Channel_2: Channel 2  
    805            * @param  TIM5_OCMode: Specifies the TIM5 Output Compare Mode.
    806            *          This parameter can be one of the following values:
    807            *            @arg TIM5_OCMode_Timing: Timing (Frozen) Mode
    808            *            @arg TIM5_OCMode_Active: Active Mode
    809            *            @arg TIM5_OCMode_Inactive: Inactive Mode
    810            *            @arg TIM5_OCMode_Toggle: Toggle Mode
    811            *            @arg TIM5_OCMode_PWM1: PWM Mode 1
    812            *            @arg TIM5_OCMode_PWM2: PWM Mode 2    
    813            * @retval None
    814            */

   \                                 In section .near_func.text, align 1
    815          void TIM5_SelectOCxM(TIM5_Channel_TypeDef TIM5_Channel,
    816                               TIM5_OCMode_TypeDef TIM5_OCMode)
    817          {
    818            /* Check the parameters */
    819            assert_param(IS_TIM5_CHANNEL(TIM5_Channel));
    820            assert_param(IS_TIM5_OCM(TIM5_OCMode));
    821          
    822            if (TIM5_Channel == TIM5_Channel_1)
   \                     TIM5_SelectOCxM:
   \   000000 4D           TNZ       A
   \   000001 26 15        JRNE      L:??TIM5_SelectOCxM_0
    823            {
    824              /* Disable the Channel 1: Reset the CCE Bit */
    825              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
   \   000003 7211 530B    BRES      L:0x530b, #0x0
    826          
    827              /* Reset the Output Compare Bits */
    828              TIM5->CCMR1 &= (uint8_t)(~TIM_CCMR_OCM);
   \   000007 C6 5309      LD        A, L:0x5309
   \   00000A A4 8F        AND       A, #0x8f
   \   00000C C7 5309      LD        L:0x5309, A
    829          
    830              /* Set the Output Compare Mode */
    831              TIM5->CCMR1 |= (uint8_t)TIM5_OCMode;
   \   00000F B6 ..        LD        A, S:?b0
   \   000011 CA 5309      OR        A, L:0x5309
   \   000014 C7 5309      LD        L:0x5309, A
   \   000017 81           RET
    832            }
    833            else /* if (TIM5_Channel == TIM5_Channel_2) */
    834            {
    835              /* Disable the Channel 2: Reset the CCE Bit */
    836              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
   \                     ??TIM5_SelectOCxM_0:
   \   000018 7219 530B    BRES      L:0x530b, #0x4
    837          
    838              /* Reset the Output Compare Bits */
    839              TIM5->CCMR2 &= (uint8_t)(~TIM_CCMR_OCM);
   \   00001C C6 530A      LD        A, L:0x530a
   \   00001F A4 8F        AND       A, #0x8f
   \   000021 C7 530A      LD        L:0x530a, A
    840          
    841              /* Set the Output Compare Mode */
    842              TIM5->CCMR2 |= (uint8_t)TIM5_OCMode;
   \   000024 B6 ..        LD        A, S:?b0
   \   000026 CA 530A      OR        A, L:0x530a
   \   000029 C7 530A      LD        L:0x530a, A
    843            }
    844          }
   \   00002C 81           RET
    845          
    846          /**
    847            * @brief  Sets the TIM5 Capture Compare1 Register value.
    848            * @param  Compare: Specifies the Capture Compare1 register new value.
    849            *         This parameter is between 0x0000 and 0xFFFF.
    850            * @retval None
    851            */

   \                                 In section .near_func.text, align 1
    852          void TIM5_SetCompare1(uint16_t Compare)
    853          {
   \                     TIM5_SetCompare1:
   \   000000 9093         LDW       Y, X
    854            /* Set the Capture Compare1 Register value */
    855            TIM5->CCR1H = (uint8_t)(Compare >> 8);
   \   000002 CD ....      CALL      L:?Subroutine5
    856            TIM5->CCR1L = (uint8_t)(Compare);
    857          }
   \                     ??CrossCallReturnLabel_11:
   \   000005 81           RET
    858          
    859          /**
    860            * @brief  Sets the TIM5 Capture Compare2 Register value.
    861            * @param  Compare: Specifies the Capture Compare2 register new value.
    862            *         This parameter is between 0x0000 and 0xFFFF.
    863            * @retval None
    864            */

   \                                 In section .near_func.text, align 1
    865          void TIM5_SetCompare2(uint16_t Compare)
    866          {
   \                     TIM5_SetCompare2:
   \   000000 9093         LDW       Y, X
    867            /* Set the Capture Compare2 Register value */
    868            TIM5->CCR2H = (uint8_t)(Compare >> 8);
   \   000002 CD ....      CALL      L:?Subroutine4
    869            TIM5->CCR2L = (uint8_t)(Compare);
    870          }
   \                     ??CrossCallReturnLabel_9:
   \   000005 81           RET
    871          
    872          /**
    873            * @brief  Forces the TIM5 Channel1 output waveform to active or inactive level.
    874            * @param  TIM5_ForcedAction: Specifies the forced Action to be set to the output waveform.
    875            *          This parameter can be one of the following values:
    876            *            @arg TIM5_ForcedAction_Active: Output Reference is forced low 
    877            *            @arg TIM5_ForcedAction_Inactive: Output Reference is forced high 
    878            * @retval None
    879            */

   \                                 In section .near_func.text, align 1
    880          void TIM5_ForcedOC1Config(TIM5_ForcedAction_TypeDef TIM5_ForcedAction)
    881          {
   \                     TIM5_ForcedOC1Config:
   \   000000 B7 ..        LD        S:?b0, A
    882            uint8_t tmpccmr1 = 0;
    883          
    884            /* Check the parameters */
    885            assert_param(IS_TIM5_FORCED_ACTION(TIM5_ForcedAction));
    886          
    887            tmpccmr1 = TIM5->CCMR1;
   \   000002 C6 5309      LD        A, L:0x5309
    888          
    889            /* Reset the OCM Bits */
    890            tmpccmr1 &= (uint8_t)(~TIM_CCMR_OCM);
    891          
    892            /* Configure The Forced output Mode */
    893            tmpccmr1 |= (uint8_t)TIM5_ForcedAction;
    894          
    895            TIM5->CCMR1 = tmpccmr1;
   \   000005 A4 8F        AND       A, #0x8f
   \   000007 BA ..        OR        A, S:?b0
   \   000009 C7 5309      LD        L:0x5309, A
    896          }
   \   00000C 81           RET
    897          
    898          /**
    899            * @brief  Forces the TIM5 Channel2 output waveform to active or inactive level.
    900            * @param  TIM5_ForcedAction: Specifies the forced Action to be set to the output waveform.
    901            *          This parameter can be one of the following values:
    902            *            @arg TIM5_ForcedAction_Active: Output Reference is forced low 
    903            *            @arg TIM5_ForcedAction_Inactive: Output Reference is forced high 
    904            * @retval None
    905            */

   \                                 In section .near_func.text, align 1
    906          void TIM5_ForcedOC2Config(TIM5_ForcedAction_TypeDef TIM5_ForcedAction)
    907          {
   \                     TIM5_ForcedOC2Config:
   \   000000 B7 ..        LD        S:?b0, A
    908            uint8_t tmpccmr2 = 0;
    909          
    910            /* Check the parameters */
    911            assert_param(IS_TIM5_FORCED_ACTION(TIM5_ForcedAction));
    912          
    913            tmpccmr2 = TIM5->CCMR2;
   \   000002 C6 530A      LD        A, L:0x530a
    914          
    915            /* Reset the OCM Bits */
    916            tmpccmr2 &= (uint8_t)(~TIM_CCMR_OCM);
    917          
    918            /* Configure The Forced output Mode */
    919            tmpccmr2 |= (uint8_t)TIM5_ForcedAction;
    920          
    921            TIM5->CCMR2 = tmpccmr2;
   \   000005 A4 8F        AND       A, #0x8f
   \   000007 BA ..        OR        A, S:?b0
   \   000009 C7 530A      LD        L:0x530a, A
    922          }
   \   00000C 81           RET
    923          
    924          /**
    925            * @brief  Enables or disables the TIM5 peripheral Preload Register on CCR1.
    926            * @param  NewState: The new state of the Capture Compare Preload register.
    927            *          This parameter can be ENABLE or DISABLE
    928            * @retval None
    929            */

   \                                 In section .near_func.text, align 1
    930          void TIM5_OC1PreloadConfig(FunctionalState NewState)
    931          {
    932            /* Check the parameters */
    933            assert_param(IS_FUNCTIONAL_STATE(NewState));
    934          
    935            /* Set or Reset the OC1PE Bit */
    936            if (NewState != DISABLE)
   \                     TIM5_OC1PreloadConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM5_OC1PreloadConfig_0
    937            {
    938              TIM5->CCMR1 |= TIM_CCMR_OCxPE ;
   \   000003 7216 5309    BSET      L:0x5309, #0x3
   \   000007 81           RET
    939            }
    940            else
    941            {
    942              TIM5->CCMR1 &= (uint8_t)(~TIM_CCMR_OCxPE) ;
   \                     ??TIM5_OC1PreloadConfig_0:
   \   000008 7217 5309    BRES      L:0x5309, #0x3
    943            }
    944          }
   \   00000C 81           RET
    945          
    946          /**
    947            * @brief  Enables or disables the TIM5 peripheral Preload Register on CCR2.
    948            * @param  NewState: The new state of the Capture Compare Preload register.
    949            *          This parameter can be ENABLE or DISABLE
    950            * @retval None
    951            */

   \                                 In section .near_func.text, align 1
    952          void TIM5_OC2PreloadConfig(FunctionalState NewState)
    953          {
    954            /* Check the parameters */
    955            assert_param(IS_FUNCTIONAL_STATE(NewState));
    956          
    957            /* Set or Reset the OC2PE Bit */
    958            if (NewState != DISABLE)
   \                     TIM5_OC2PreloadConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM5_OC2PreloadConfig_0
    959            {
    960              TIM5->CCMR2 |= TIM_CCMR_OCxPE ;
   \   000003 7216 530A    BSET      L:0x530a, #0x3
   \   000007 81           RET
    961            }
    962            else
    963            {
    964              TIM5->CCMR2 &= (uint8_t)(~TIM_CCMR_OCxPE) ;
   \                     ??TIM5_OC2PreloadConfig_0:
   \   000008 7217 530A    BRES      L:0x530a, #0x3
    965            }
    966          }
   \   00000C 81           RET
    967          
    968          /**
    969            * @brief  Configures the TIM5 Capture Compare 1 Fast feature.
    970            * @param  NewState: The new state of the Output Compare Fast Enable bit.
    971            *          This parameter can be ENABLE or DISABLE
    972            * @retval None
    973            */

   \                                 In section .near_func.text, align 1
    974          void TIM5_OC1FastConfig(FunctionalState NewState)
    975          {
    976            /* Check the parameters */
    977            assert_param(IS_FUNCTIONAL_STATE(NewState));
    978          
    979            /* Set or Reset the OC1FE Bit */
    980            if (NewState != DISABLE)
   \                     TIM5_OC1FastConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM5_OC1FastConfig_0
    981            {
    982              TIM5->CCMR1 |= TIM_CCMR_OCxFE ;
   \   000003 7214 5309    BSET      L:0x5309, #0x2
   \   000007 81           RET
    983            }
    984            else
    985            {
    986              TIM5->CCMR1 &= (uint8_t)(~TIM_CCMR_OCxFE) ;
   \                     ??TIM5_OC1FastConfig_0:
   \   000008 7215 5309    BRES      L:0x5309, #0x2
    987            }
    988          }
   \   00000C 81           RET
    989          
    990          /**
    991            * @brief  Configures the TIM5 Capture Compare 2 Fast feature.
    992            * @param  NewState: The new state of the Output Compare Fast Enable bit.
    993            *          This parameter can be ENABLE or DISABLE
    994            * @retval None
    995            */
    996          

   \                                 In section .near_func.text, align 1
    997          void TIM5_OC2FastConfig(FunctionalState NewState)
    998          {
    999            /* Check the parameters */
   1000            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1001          
   1002            /* Set or Reset the OC2FE Bit */
   1003            if (NewState != DISABLE)
   \                     TIM5_OC2FastConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM5_OC2FastConfig_0
   1004            {
   1005              TIM5->CCMR2 |= TIM_CCMR_OCxFE ;
   \   000003 7214 530A    BSET      L:0x530a, #0x2
   \   000007 81           RET
   1006            }
   1007            else
   1008            {
   1009              TIM5->CCMR2 &= (uint8_t)(~TIM_CCMR_OCxFE) ;
   \                     ??TIM5_OC2FastConfig_0:
   \   000008 7215 530A    BRES      L:0x530a, #0x2
   1010            }
   1011          }
   \   00000C 81           RET
   1012          
   1013          /**
   1014            * @brief  Configures the TIM5 Channel 1 polarity.
   1015            * @param  TIM5_OCPolarity: Specifies the OC1 Polarity.
   1016            *          This parameter can be one of the following values:
   1017            *            @arg TIM5_OCPolarity_High: Output compare polarity  = High
   1018            *            @arg TIM5_OCPolarity_Low: Output compare polarity  = Low 
   1019            * @retval None
   1020            */

   \                                 In section .near_func.text, align 1
   1021          void TIM5_OC1PolarityConfig(TIM5_OCPolarity_TypeDef TIM5_OCPolarity)
   1022          {
   1023            /* Check the parameters */
   1024            assert_param(IS_TIM5_OC_POLARITY(TIM5_OCPolarity));
   1025          
   1026            /* Set or Reset the CC1P Bit */
   1027            if (TIM5_OCPolarity == TIM5_OCPolarity_Low)
   \                     TIM5_OC1PolarityConfig:
   \   000000 A1 01        CP        A, #0x1
   \   000002 26 05        JRNE      L:??TIM5_OC1PolarityConfig_0
   1028            {
   1029              TIM5->CCER1 |= TIM_CCER1_CC1P ;
   \   000004 7212 530B    BSET      L:0x530b, #0x1
   \   000008 81           RET
   1030            }
   1031            else
   1032            {
   1033              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P) ;
   \                     ??TIM5_OC1PolarityConfig_0:
   \   000009 7213 530B    BRES      L:0x530b, #0x1
   1034            }
   1035          }
   \   00000D 81           RET
   1036          
   1037          /**
   1038            * @brief  Configures the TIM5 Channel 2 polarity.
   1039            * @param  TIM5_OCPolarity: Specifies the OC2 Polarity.
   1040            *          This parameter can be one of the following values:
   1041            *            @arg TIM5_OCPolarity_High: Output compare polarity  = High
   1042            *            @arg TIM5_OCPolarity_Low: Output compare polarity  = Low 
   1043            * @retval None
   1044            */

   \                                 In section .near_func.text, align 1
   1045          void TIM5_OC2PolarityConfig(TIM5_OCPolarity_TypeDef TIM5_OCPolarity)
   1046          {
   1047            /* Check the parameters */
   1048            assert_param(IS_TIM5_OC_POLARITY(TIM5_OCPolarity));
   1049          
   1050            /* Set or Reset the CC2P Bit */
   1051            if (TIM5_OCPolarity == TIM5_OCPolarity_Low)
   \                     TIM5_OC2PolarityConfig:
   \   000000 A1 01        CP        A, #0x1
   \   000002 26 05        JRNE      L:??TIM5_OC2PolarityConfig_0
   1052            {
   1053              TIM5->CCER1 |= TIM_CCER1_CC2P ;
   \   000004 721A 530B    BSET      L:0x530b, #0x5
   \   000008 81           RET
   1054            }
   1055            else
   1056            {
   1057              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   \                     ??TIM5_OC2PolarityConfig_0:
   \   000009 721B 530B    BRES      L:0x530b, #0x5
   1058            }
   1059          }
   \   00000D 81           RET
   1060          
   1061          /**
   1062            * @brief  Enables or disables the TIM5 Capture Compare Channel x.
   1063            * @param  TIM5_Channel: Specifies the TIM5 Channel.
   1064            *          This parameter can be one of the following values:
   1065            *            @arg TIM5_Channel_1: Channel 1
   1066            *            @arg TIM5_Channel_2: Channel 2  
   1067            * @param  NewState: Specifies the TIM5 Channel CCxE bit new state.
   1068            *          This parameter can be ENABLE or DISABLE
   1069            * @retval None
   1070            */

   \                                 In section .near_func.text, align 1
   1071          void TIM5_CCxCmd(TIM5_Channel_TypeDef TIM5_Channel,
   1072                           FunctionalState NewState)
   1073          {
   1074            /* Check the parameters */
   1075            assert_param(IS_TIM5_CHANNEL(TIM5_Channel));
   1076            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1077          
   1078            if (TIM5_Channel == TIM5_Channel_1)
   \                     TIM5_CCxCmd:
   \   000000 4D           TNZ       A
   \   000001 26 0E        JRNE      L:??TIM5_CCxCmd_0
   1079            {
   1080              /* Set or Reset the CC1E Bit */
   1081              if (NewState != DISABLE)
   \   000003 3D ..        TNZ       S:?b0
   \   000005 27 05        JREQ      L:??TIM5_CCxCmd_1
   1082              {
   1083                TIM5->CCER1 |= TIM_CCER1_CC1E ;
   \   000007 7210 530B    BSET      L:0x530b, #0x0
   \   00000B 81           RET
   1084              }
   1085              else
   1086              {
   1087                TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E) ;
   \                     ??TIM5_CCxCmd_1:
   \   00000C 7211 530B    BRES      L:0x530b, #0x0
   \   000010 81           RET
   1088              }
   1089          
   1090            }
   1091            else /* if (TIM5_Channel == TIM5_Channel_2) */
   1092            {
   1093              /* Set or Reset the CC2E Bit */
   1094              if (NewState != DISABLE)
   \                     ??TIM5_CCxCmd_0:
   \   000011 3D ..        TNZ       S:?b0
   \   000013 27 05        JREQ      L:??TIM5_CCxCmd_2
   1095              {
   1096                TIM5->CCER1 |= TIM_CCER1_CC2E;
   \   000015 7218 530B    BSET      L:0x530b, #0x4
   \   000019 81           RET
   1097              }
   1098              else
   1099              {
   1100                TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E) ;
   \                     ??TIM5_CCxCmd_2:
   \   00001A 7219 530B    BRES      L:0x530b, #0x4
   1101              }
   1102            }
   1103          }
   \   00001E 81           RET
   1104          
   1105          /** @defgroup TIM5_Group3 Input Capture management functions
   1106           *  @brief    Input Capture management functions 
   1107           *
   1108          @verbatim   
   1109           ===============================================================================
   1110                                Input Capture management functions
   1111           ===============================================================================  
   1112             
   1113                 ===================================================================      
   1114                        TIM5 Driver: how to use it in Input Capture Mode
   1115                 =================================================================== 
   1116                 To use the Timer in Input Capture mode, the following steps are mandatory:
   1117                 
   1118                 1. Enable TIM5 clock using CLK_PeripheralClockConfig(CLK_Peripheral_TIM5, ENABLE) function.
   1119                 
   1120                 2. Configure the TIM5 pins in input mode by configuring the corresponding GPIO pins
   1121                 
   1122                 3. Configure the Time base unit as described in the first part of this driver, if needed,
   1123                    otherwise the Timer will run with the default configuration:
   1124                    - Autoreload value = 0xFFFF
   1125                    - Prescaler value = 0x0
   1126                    - Counter mode = Up counting
   1127                 
   1128                 4. Call TIM5_ICInit() to configure the desired channel to measure only 
   1129                    frequency or duty cycle of the input signal using the corresponding configuration: 
   1130                    - TIM5 Channel: TIM5_Channel
   1131                    - TIM5 Input Capture polarity: TIM5_ICPolarity
   1132                    - TIM5 Input Capture selection: TIM5_ICSelection
   1133                    - TIM5 Input Capture Prescaler: TIM5_ICPSC
   1134                    - TIM5 Input Capture filter value
   1135                    or,
   1136                    Call TIM5_PWMIConfig() to configure the desired channels with the 
   1137                    corresponding configuration and to measure the frequency and the duty
   1138                    cycle of the input signal.
   1139                    
   1140                 5. Enable global interrupts or the DMA to read the measured frequency. 
   1141                    
   1142                 6. Enable the corresponding interrupt (or DMA request) to read the captured value,
   1143                    using the function TIM5_ITConfig(TIM5_IT_CCx) (or TIM5_DMACmd(TIM5_DMASource_CCx))
   1144                 
   1145                 7. Call the TIM5_Cmd(ENABLE) function to enable the TIM5 counter.
   1146                 
   1147                 8. Use TIM5_GetCapturex() to read the captured value corresponding to
   1148                    channel x.
   1149                 
   1150                 Note1: All other functions can be used separately to modify, if needed,
   1151                    a specific feature of the Timer. 
   1152          
   1153          @endverbatim
   1154            * @{
   1155            */
   1156          
   1157          /**
   1158            * @brief  Initializes the TIM5 peripheral according to the specified parameters.
   1159            * @param  TIM5_Channel: TIM5 Channel
   1160            *          This parameter can be one of the following values:
   1161            *            @arg TIM5_Channel_1: Channel 1
   1162            *            @arg TIM5_Channel_2: Channel 2     
   1163            * @param  TIM5_ICPolarity: Input Capture Polarity
   1164            *          This parameter can be one of the following values:
   1165            *            @arg TIM5_ICPolarity_Rising: Input Capture on Rising Edge
   1166            *            @arg TIM5_ICPolarity_Falling: Input Capture on Falling Edge  
   1167            * @param  TIM5_ICSelection: Input Capture Selection
   1168            *          This parameter can be one of the following values:
   1169            *            @arg TIM5_ICSelection_DirectTI: Input Capture mapped on the direct input
   1170            *            @arg TIM5_ICSelection_IndirectTI: Input Capture mapped on the indirect input
   1171            *            @arg TIM5_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
   1172            * @param  TIM5_ICPrescaler: Input Capture Prescaler
   1173            *          This parameter can be one of the following values:
   1174            *            @arg TIM5_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1175            *            @arg TIM5_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1176            *            @arg TIM5_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1177            *            @arg TIM5_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events)   
   1178            * @param  TIM5_ICFilter: This parameter must be a value between 0x00 and 0x0F.
   1179            * @retval None
   1180            */

   \                                 In section .near_func.text, align 1
   1181          void TIM5_ICInit(TIM5_Channel_TypeDef TIM5_Channel,
   1182                           TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
   1183                           TIM5_ICSelection_TypeDef TIM5_ICSelection,
   1184                           TIM5_ICPSC_TypeDef TIM5_ICPrescaler,
   1185                           uint8_t TIM5_ICFilter)
   1186          {
   \                     TIM5_ICInit:
   \   000000 45 .. ..     MOV       S:?b4, S:?b0
   \   000003 45 .. ..     MOV       S:?b0, S:?b1
   \   000006 45 .. ..     MOV       S:?b5, S:?b2
   \   000009 45 .. ..     MOV       S:?b1, S:?b3
   1187            /* Check the parameters */
   1188            assert_param(IS_TIM5_CHANNEL(TIM5_Channel));
   1189          
   1190            if (TIM5_Channel == TIM5_Channel_1)
   \   00000C 4D           TNZ       A
   \   00000D 26 0A        JRNE      L:??TIM5_ICInit_0
   1191            {
   1192              /* TI1 Configuration */
   1193              TI1_Config(TIM5_ICPolarity, TIM5_ICSelection, TIM5_ICFilter);
   \   00000F B6 ..        LD        A, S:?b4
   \   000011 CD ....      CALL      L:TI1_Config
   1194          
   1195              /* Set the Input Capture Prescaler value */
   1196              TIM5_SetIC1Prescaler(TIM5_ICPrescaler);
   \   000014 B6 ..        LD        A, S:?b5
   \   000016 CC ....      JP        L:TIM5_SetIC1Prescaler
   1197            }
   1198            else /* if (TIM5_Channel == TIM5_Channel_2) */
   1199            {
   1200              /* TI2 Configuration */
   1201              TI2_Config(TIM5_ICPolarity, TIM5_ICSelection, TIM5_ICFilter);
   \                     ??TIM5_ICInit_0:
   \   000019 B6 ..        LD        A, S:?b4
   \   00001B CD ....      CALL      L:TI2_Config
   1202          
   1203              /* Set the Input Capture Prescaler value */
   1204              TIM5_SetIC2Prescaler(TIM5_ICPrescaler);
   \   00001E B6 ..        LD        A, S:?b5
   \   000020 CC ....      JP        L:TIM5_SetIC2Prescaler
   1205            }
   1206          }
   1207          
   1208          /**
   1209            * @brief  Configures the TIM5 peripheral in PWM Input Mode according to the
   1210            *         specified parameters.
   1211            * @param  TIM5_Channel: TIM5 Channel
   1212            *          This parameter can be one of the following values:
   1213            *            @arg TIM5_Channel_1: Channel 1
   1214            *            @arg TIM5_Channel_2: Channel 2     
   1215            * @param  TIM5_ICPolarity: Input Capture Polarity
   1216            *          This parameter can be one of the following values:
   1217            *            @arg TIM5_ICPolarity_Rising: Input Capture on Rising Edge
   1218            *            @arg TIM5_ICPolarity_Falling: Input Capture on Falling Edge  
   1219            * @param  TIM5_ICSelection: Input Capture Selection
   1220            *          This parameter can be one of the following values:
   1221            *            @arg TIM5_ICSelection_DirectTI: Input Capture mapped on the direct input
   1222            *            @arg TIM5_ICSelection_IndirectTI: Input Capture mapped on the indirect input
   1223            *            @arg TIM5_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
   1224            * @param  TIM5_ICPrescaler: Input Capture Prescaler
   1225            *          This parameter can be one of the following values:
   1226            *            @arg TIM5_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1227            *            @arg TIM5_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1228            *            @arg TIM5_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1229            *            @arg TIM5_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events) 
   1230            * @retval None
   1231            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1232          void TIM5_PWMIConfig(TIM5_Channel_TypeDef TIM5_Channel,
   1233                               TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
   1234                               TIM5_ICSelection_TypeDef TIM5_ICSelection,
   1235                               TIM5_ICPSC_TypeDef TIM5_ICPrescaler,
   1236                               uint8_t TIM5_ICFilter)
   1237          {
   \                     TIM5_PWMIConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b6, A
   \   000005 45 .. ..     MOV       S:?b7, S:?b0
   \   000008 B6 ..        LD        A, S:?b1
   \   00000A 45 .. ..     MOV       S:?b8, S:?b2
   1238            uint8_t icpolarity = TIM5_ICPolarity_Rising;
   \   00000D 3F ..        CLR       S:?b5
   1239            uint8_t icselection = TIM5_ICSelection_DirectTI;
   \   00000F 35 01 ....   MOV       S:?b4, #0x1
   1240          
   1241            /* Check the parameters */
   1242            assert_param(IS_TIM5_CHANNEL(TIM5_Channel));
   1243          
   1244            /* Select the Opposite Input Polarity */
   1245            if (TIM5_ICPolarity == TIM5_ICPolarity_Rising)
   \   000013 3D ..        TNZ       S:?b7
   \   000015 26 04        JRNE      L:??TIM5_PWMIConfig_0
   1246            {
   1247              icpolarity = TIM5_ICPolarity_Falling;
   \   000017 35 01 ....   MOV       S:?b5, #0x1
   1248            }
   1249            else
   1250            {
   1251              icpolarity = TIM5_ICPolarity_Rising;
   1252            }
   1253          
   1254            /* Select the Opposite Input */
   1255            if (TIM5_ICSelection == TIM5_ICSelection_DirectTI)
   \                     ??TIM5_PWMIConfig_0:
   \   00001B A1 01        CP        A, #0x1
   \   00001D 26 04        JRNE      L:??TIM5_PWMIConfig_1
   1256            {
   1257              icselection = TIM5_ICSelection_IndirectTI;
   \   00001F 35 02 ....   MOV       S:?b4, #0x2
   1258            }
   1259            else
   1260            {
   1261              icselection = TIM5_ICSelection_DirectTI;
   1262            }
   1263          
   1264            if (TIM5_Channel == TIM5_Channel_1)
   \                     ??TIM5_PWMIConfig_1:
   \   000023 3D ..        TNZ       S:?b6
   \   000025 45 .. ..     MOV       S:?b1, S:?b3
   \   000028 26 0F        JRNE      L:??TIM5_PWMIConfig_2
   1265            {
   1266              /* TI1 Configuration */
   1267              TI1_Config(TIM5_ICPolarity, TIM5_ICSelection,
   1268                         TIM5_ICFilter);
   \   00002A B7 ..        LD        S:?b0, A
   \   00002C B6 ..        LD        A, S:?b7
   \   00002E CD ....      CALL      L:?Subroutine8
   1269          
   1270              /* Set the Input Capture Prescaler value */
   1271              TIM5_SetIC1Prescaler(TIM5_ICPrescaler);
   1272          
   1273              /* TI2 Configuration */
   1274              TI2_Config((TIM5_ICPolarity_TypeDef)icpolarity, (TIM5_ICSelection_TypeDef)icselection, TIM5_ICFilter);
   \                     ??CrossCallReturnLabel_18:
   \   000031 CD ....      CALL      L:?Subroutine9
   1275          
   1276              /* Set the Input Capture Prescaler value */
   1277              TIM5_SetIC2Prescaler(TIM5_ICPrescaler);
   1278            }
   \                     ??CrossCallReturnLabel_19:
   \   000034 CD ....      CALL      L:?Subroutine7
   \                     ??CrossCallReturnLabel_16:
   \   000037 20 0D        JRA       L:??CrossCallReturnLabel_17
   1279            else
   1280            {
   1281              /* TI2 Configuration */
   1282              TI2_Config(TIM5_ICPolarity, TIM5_ICSelection,
   1283                         TIM5_ICFilter);
   \                     ??TIM5_PWMIConfig_2:
   \   000039 B7 ..        LD        S:?b0, A
   \   00003B B6 ..        LD        A, S:?b7
   \   00003D CD ....      CALL      L:?Subroutine7
   1284          
   1285              /* Set the Input Capture Prescaler value */
   1286              TIM5_SetIC2Prescaler(TIM5_ICPrescaler);
   1287          
   1288              /* TI1 Configuration */
   1289              TI1_Config((TIM5_ICPolarity_TypeDef)icpolarity, (TIM5_ICSelection_TypeDef)icselection, TIM5_ICFilter);
   \                     ??CrossCallReturnLabel_15:
   \   000040 CD ....      CALL      L:?Subroutine9
   1290          
   1291              /* Set the Input Capture Prescaler value */
   1292              TIM5_SetIC1Prescaler(TIM5_ICPrescaler);
   1293            }
   \                     ??CrossCallReturnLabel_20:
   \   000043 CD ....      CALL      L:?Subroutine8
   1294          }
   \                     ??CrossCallReturnLabel_17:
   \   000046 32 ....      POP       S:?b8
   \   000049 81           RET

   \                                 In section .near_func.text, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000 45 .. ..     MOV       S:?b1, S:?b3
   \   000003 45 .. ..     MOV       S:?b0, S:?b4
   \   000006 B6 ..        LD        A, S:?b5
   \   000008 81           RET

   \                                 In section .near_func.text, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000 CD ....      CALL      L:TI1_Config
   \   000003 B6 ..        LD        A, S:?b8
   \   000005 CC ....      JP        L:TIM5_SetIC1Prescaler

   \                                 In section .near_func.text, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000 CD ....      CALL      L:TI2_Config
   \   000003 B6 ..        LD        A, S:?b8
   \   000005 CC ....      JP        L:TIM5_SetIC2Prescaler
   1295          
   1296          /**
   1297            * @brief  Gets the TIM5 Input Capture 1 value.
   1298            * @param  None
   1299            * @retval Capture Compare 1 Register value.
   1300            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1301          uint16_t TIM5_GetCapture1(void)
   1302          {
   1303            uint16_t tmpccr1 = 0;
   1304            uint8_t tmpccr1l, tmpccr1h;
   1305          
   1306            tmpccr1h = TIM5->CCR1H;
   \                     TIM5_GetCapture1:
   \   000000 C6 5311      LD        A, L:0x5311
   \   000003 B7 ..        LD        S:?b1, A
   1307            tmpccr1l = TIM5->CCR1L;
   \   000005 C6 5312      LD        A, L:0x5312
   \   000008 CD ....      CALL      L:?Subroutine0
   1308          
   1309            tmpccr1 = (uint16_t)(tmpccr1l);
   1310            tmpccr1 |= (uint16_t)((uint16_t)tmpccr1h << 8);
   1311            /* Get the Capture 1 Register value */
   1312            return ((uint16_t)tmpccr1);
   \                     ??CrossCallReturnLabel_1:
   \   00000B 81           RET
   1313          }
   1314          
   1315          /**
   1316            * @brief  Gets the TIM5 Input Capture 2 value.
   1317            * @param  None
   1318            * @retval Capture Compare 2 Register value.
   1319            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1320          uint16_t TIM5_GetCapture2(void)
   1321          {
   1322            uint16_t tmpccr2 = 0;
   1323            uint8_t tmpccr2l, tmpccr2h;
   1324          
   1325            tmpccr2h = TIM5->CCR2H;
   \                     TIM5_GetCapture2:
   \   000000 C6 5313      LD        A, L:0x5313
   \   000003 B7 ..        LD        S:?b1, A
   1326            tmpccr2l = TIM5->CCR2L;
   \   000005 C6 5314      LD        A, L:0x5314
   \   000008 CD ....      CALL      L:?Subroutine0
   1327          
   1328            tmpccr2 = (uint16_t)(tmpccr2l);
   1329            tmpccr2 |= (uint16_t)((uint16_t)tmpccr2h << 8);
   1330            /* Get the Capture 2 Register value */
   1331            return ((uint16_t)tmpccr2);
   \                     ??CrossCallReturnLabel_0:
   \   00000B 81           RET
   1332          }
   1333          
   1334          /**
   1335            * @brief  Sets the TIM5 Input Capture 1 prescaler.
   1336            * @param  TIM5_IC1Prescaler: Specifies the Input Capture prescaler new value
   1337            *          This parameter can be one of the following values:
   1338            *            @arg TIM5_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1339            *            @arg TIM5_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1340            *            @arg TIM5_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1341            *            @arg TIM5_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events) 
   1342            * @retval None
   1343            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1344          void TIM5_SetIC1Prescaler(TIM5_ICPSC_TypeDef TIM5_IC1Prescaler)
   1345          {
   \                     TIM5_SetIC1Prescaler:
   \   000000 B7 ..        LD        S:?b0, A
   1346            uint8_t tmpccmr1 = 0;
   1347          
   1348            /* Check the parameters */
   1349            assert_param(IS_TIM5_IC_PRESCALER(TIM5_IC1Prescaler));
   1350          
   1351            tmpccmr1 = TIM5->CCMR1;
   \   000002 C6 5309      LD        A, L:0x5309
   1352          
   1353            /* Reset the IC1PSC Bits */
   1354            tmpccmr1 &= (uint8_t)(~TIM_CCMR_ICxPSC);
   1355          
   1356            /* Set the IC1PSC value */
   1357            tmpccmr1 |= (uint8_t)TIM5_IC1Prescaler;
   1358          
   1359            TIM5->CCMR1 = tmpccmr1;
   \   000005 A4 F3        AND       A, #0xf3
   \   000007 BA ..        OR        A, S:?b0
   \   000009 C7 5309      LD        L:0x5309, A
   1360          }
   \   00000C 81           RET
   1361          
   1362          /**
   1363            * @brief  Sets the TIM5 Input Capture 2 prescaler.
   1364            * @param  TIM5_IC2Prescaler: Specifies the Input Capture prescaler new value
   1365            *          This parameter can be one of the following values:
   1366            *            @arg TIM5_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1367            *            @arg TIM5_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1368            *            @arg TIM5_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1369            *            @arg TIM5_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events) 
   1370            * @retval None
   1371            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1372          void TIM5_SetIC2Prescaler(TIM5_ICPSC_TypeDef TIM5_IC2Prescaler)
   1373          {
   \                     TIM5_SetIC2Prescaler:
   \   000000 B7 ..        LD        S:?b0, A
   1374            uint8_t tmpccmr2 = 0;
   1375          
   1376            /* Check the parameters */
   1377            assert_param(IS_TIM5_IC_PRESCALER(TIM5_IC2Prescaler));
   1378          
   1379            tmpccmr2 = TIM5->CCMR2;
   \   000002 C6 530A      LD        A, L:0x530a
   1380          
   1381            /* Reset the IC2PSC Bits */
   1382            tmpccmr2 &= (uint8_t)(~TIM_CCMR_ICxPSC);
   1383          
   1384            /* Set the IC2PSC value */
   1385            tmpccmr2 |= (uint8_t)TIM5_IC2Prescaler;
   1386          
   1387            TIM5->CCMR2 = tmpccmr2;
   \   000005 A4 F3        AND       A, #0xf3
   \   000007 BA ..        OR        A, S:?b0
   \   000009 C7 530A      LD        L:0x530a, A
   1388          }
   \   00000C 81           RET
   1389          
   1390          /**
   1391            * @}
   1392            */
   1393          
   1394          /** @defgroup TIM5_Group4 Interrupts DMA and flags management functions
   1395           *  @brief    Interrupts, DMA and flags management functions 
   1396           *
   1397          @verbatim   
   1398           ===============================================================================
   1399                           Interrupts, DMA and flags management functions
   1400           ===============================================================================  
   1401          
   1402          @endverbatim
   1403            * @{
   1404            */
   1405          
   1406          /**
   1407            * @brief  Enables or disables the specified TIM5 interrupts.
   1408            * @param  TIM5_IT: Specifies the TIM5 interrupts sources to be enabled or disabled.
   1409            *          This parameter can be any combination of the following values:
   1410            *            @arg TIM5_IT_Update: Update
   1411            *            @arg TIM5_IT_CC1: Capture Compare Channel1
   1412            *            @arg TIM5_IT_CC2: Capture Compare Channel2 
   1413            *            @arg TIM5_IT_Trigger: Trigger 
   1414            *            @arg TIM5_IT_Break: Break  
   1415            * @param  NewState: The new state of the TIM5 peripheral.
   1416            *          This parameter can be ENABLE or DISABLE
   1417            * @retval None
   1418            */

   \                                 In section .near_func.text, align 1
   1419          void TIM5_ITConfig(TIM5_IT_TypeDef TIM5_IT, FunctionalState NewState)
   1420          {
   1421            /* Check the parameters */
   1422            assert_param(IS_TIM5_IT(TIM5_IT));
   1423            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1424          
   1425            if (NewState != DISABLE)
   \                     TIM5_ITConfig:
   \   000000 3D ..        TNZ       S:?b0
   \   000002 27 05        JREQ      L:??TIM5_ITConfig_0
   1426            {
   1427              /* Enable the Interrupt sources */
   1428              TIM5->IER |= (uint8_t)TIM5_IT;
   \   000004 CA 5305      OR        A, L:0x5305
   \   000007 20 04        JRA       L:??TIM5_ITConfig_1
   1429            }
   1430            else
   1431            {
   1432              /* Disable the Interrupt sources */
   1433              TIM5->IER &= (uint8_t)(~(uint8_t)TIM5_IT);
   \                     ??TIM5_ITConfig_0:
   \   000009 43           CPL       A
   \   00000A C4 5305      AND       A, L:0x5305
   \                     ??TIM5_ITConfig_1:
   \   00000D C7 5305      LD        L:0x5305, A
   1434            }
   1435          }
   \   000010 81           RET
   1436          
   1437          /**
   1438            * @brief  Configures the TIM5 event to be generated by software.
   1439            * @param  TIM5_EventSource: Specifies the event source.
   1440            *          This parameter can be any combination of the following values:
   1441            *            @arg TIM5_EventSource_Update: Update
   1442            *            @arg TIM5_EventSource_CC1: Capture Compare Channel1
   1443            *            @arg TIM5_EventSource_CC2: Capture Compare Channel2 
   1444            *            @arg TIM5_EventSource_Trigger: Trigger 
   1445            *            @arg TIM5_EventSource_Break: Break  
   1446            * @retval None
   1447            */

   \                                 In section .near_func.text, align 1
   1448          void TIM5_GenerateEvent(TIM5_EventSource_TypeDef TIM5_EventSource)
   1449          {
   1450            /* Check the parameters */
   1451            assert_param(IS_TIM5_EVENT_SOURCE((uint8_t)TIM5_EventSource));
   1452          
   1453            /* Set the event sources */
   1454            TIM5->EGR |= (uint8_t)TIM5_EventSource;
   \                     TIM5_GenerateEvent:
   \   000000 CA 5308      OR        A, L:0x5308
   \   000003 C7 5308      LD        L:0x5308, A
   1455          }
   \   000006 81           RET
   1456          
   1457          /**
   1458            * @brief  Checks whether the specified TIM5 flag is set or not.
   1459            * @param  TIM5_FLAG: Specifies the flag to check.
   1460            *          This parameter can be any combination of the following values:
   1461            *            @arg TIM5_FLAG_Update: Update
   1462            *            @arg TIM5_FLAG_CC1: Capture Compare Channel1
   1463            *            @arg TIM5_FLAG_CC2: Capture Compare Channel2 
   1464            *            @arg TIM5_FLAG_Trigger: Trigger 
   1465            *            @arg TIM5_FLAG_Break: Break  
   1466            *            @arg TIM5_FLAG_CC1OF: Capture compare 1 over capture
   1467            *            @arg TIM5_FLAG_CC2OF: Capture compare 2 over capture   
   1468            * @retval FlagStatus: The new state of TIM5_FLAG (SET or RESET)
   1469            */

   \                                 In section .near_func.text, align 1
   1470          FlagStatus TIM5_GetFlagStatus(TIM5_FLAG_TypeDef TIM5_FLAG)
   1471          {
   \                     TIM5_GetFlagStatus:
   \   000000 9093         LDW       Y, X
   1472            FlagStatus bitstatus = RESET;
   \   000002 3F ..        CLR       S:?b0
   1473            uint8_t tim5_flag_l = 0, tim5_flag_h = 0;
   1474          
   1475            /* Check the parameters */
   1476            assert_param(IS_TIM5_GET_FLAG(TIM5_FLAG));
   1477          
   1478            tim5_flag_l = (uint8_t)(TIM5->SR1 & (uint8_t)(TIM5_FLAG));
   \   000004 C6 5306      LD        A, L:0x5306
   \   000007 B7 ..        LD        S:?b2, A
   1479            tim5_flag_h = (uint8_t)(TIM5->SR2 & (uint8_t)((uint16_t)TIM5_FLAG >> 8));
   \   000009 C6 5307      LD        A, L:0x5307
   \   00000C B7 ..        LD        S:?b1, A
   1480          
   1481            if ((uint8_t)(tim5_flag_l | tim5_flag_h) != 0)
   \   00000E 4F           CLR       A
   \   00000F 01           RRWA      X, A
   \   000010 9F           LD        A, XL
   \   000011 B4 ..        AND       A, S:?b1
   \   000013 88           PUSH      A
   \   000014 909F         LD        A, YL
   \   000016 B4 ..        AND       A, S:?b2
   \   000018 B7 ..        LD        S:?b2, A
   \   00001A 84           POP       A
   \   00001B BA ..        OR        A, S:?b2
   \   00001D 27 04        JREQ      L:??TIM5_GetFlagStatus_0
   1482            {
   1483              bitstatus = SET;
   \   00001F 35 01 ....   MOV       S:?b0, #0x1
   1484            }
   1485            else
   1486            {
   1487              bitstatus = RESET;
   1488            }
   1489            return ((FlagStatus)bitstatus);
   \                     ??TIM5_GetFlagStatus_0:
   \   000023 B6 ..        LD        A, S:?b0
   \   000025 81           RET
   1490          }
   1491          
   1492          /**
   1493            * @brief  Clears the TIM’s pending flags.
   1494            * @param  TIM5_FLAG: Specifies the flag to clear.
   1495            *          This parameter can be any combination of the following values:
   1496            *            @arg TIM5_FLAG_Update: Update
   1497            *            @arg TIM5_FLAG_CC1: Capture Compare Channel1
   1498            *            @arg TIM5_FLAG_CC2: Capture Compare Channel2 
   1499            *            @arg TIM5_FLAG_Trigger: Trigger 
   1500            *            @arg TIM5_FLAG_Break: Break  
   1501            * @retval None
   1502            */

   \                                 In section .near_func.text, align 1
   1503          void TIM5_ClearFlag(TIM5_FLAG_TypeDef TIM5_FLAG)
   1504          {
   1505            /* Check the parameters */
   1506            assert_param(IS_TIM5_CLEAR_FLAG((uint16_t)TIM5_FLAG));
   1507            /* Clear the flags (rc_w0) clear this bit by writing 0. Writing ‘1’ has no effect*/
   1508            TIM5->SR1 = (uint8_t)(~(uint8_t)(TIM5_FLAG));
   \                     TIM5_ClearFlag:
   \   000000 9F           LD        A, XL
   \   000001 43           CPL       A
   \   000002 C7 5306      LD        L:0x5306, A
   1509            TIM5->SR2 = (uint8_t)(~(uint8_t)((uint16_t)TIM5_FLAG >> 8));
   \   000005 4F           CLR       A
   \   000006 01           RRWA      X, A
   \   000007 9F           LD        A, XL
   \   000008 43           CPL       A
   \   000009 C7 5307      LD        L:0x5307, A
   1510          }
   \   00000C 81           RET
   1511          
   1512          /**
   1513            * @brief  Checks whether the TIM5 interrupt has occurred or not.
   1514            * @param  TIM5_IT: Specifies the TIM5 interrupt source to check.
   1515            *          This parameter can be any combination of the following values:
   1516            *            @arg TIM5_IT_Update: Update
   1517            *            @arg TIM5_IT_CC1: Capture Compare Channel1
   1518            *            @arg TIM5_IT_CC2: Capture Compare Channel2 
   1519            *            @arg TIM5_IT_Trigger: Trigger 
   1520            *            @arg TIM5_IT_Break: Break  
   1521            * @retval ITStatus: The new state of the TIM5_IT (SET or RESET)
   1522            */

   \                                 In section .near_func.text, align 1
   1523          ITStatus TIM5_GetITStatus(TIM5_IT_TypeDef TIM5_IT)
   1524          {
   \                     TIM5_GetITStatus:
   \   000000 B7 ..        LD        S:?b1, A
   1525            ITStatus bitstatus = RESET;
   \   000002 3F ..        CLR       S:?b0
   1526          
   1527            uint8_t TIM5_itStatus = 0x0, TIM5_itEnable = 0x0;
   1528          
   1529            /* Check the parameters */
   1530            assert_param(IS_TIM5_GET_IT(TIM5_IT));
   1531          
   1532            TIM5_itStatus = (uint8_t)(TIM5->SR1 & (uint8_t)TIM5_IT);
   \   000004 C6 5306      LD        A, L:0x5306
   \   000007 B7 ..        LD        S:?b3, A
   1533          
   1534            TIM5_itEnable = (uint8_t)(TIM5->IER & (uint8_t)TIM5_IT);
   \   000009 B6 ..        LD        A, S:?b1
   \   00000B C4 5305      AND       A, L:0x5305
   \   00000E B7 ..        LD        S:?b2, A
   1535          
   1536            if ((TIM5_itStatus != (uint8_t)RESET ) && (TIM5_itEnable != (uint8_t)RESET))
   \   000010 B6 ..        LD        A, S:?b1
   \   000012 B5 ..        BCP       A, S:?b3
   \   000014 27 08        JREQ      L:??TIM5_GetITStatus_0
   \   000016 3D ..        TNZ       S:?b2
   \   000018 27 04        JREQ      L:??TIM5_GetITStatus_0
   1537            {
   1538              bitstatus = (ITStatus)SET;
   \   00001A 35 01 ....   MOV       S:?b0, #0x1
   1539            }
   1540            else
   1541            {
   1542              bitstatus = (ITStatus)RESET;
   1543            }
   1544            return ((ITStatus)bitstatus);
   \                     ??TIM5_GetITStatus_0:
   \   00001E B6 ..        LD        A, S:?b0
   \   000020 81           RET
   1545          }
   1546          
   1547          /**
   1548            * @brief  Clears the TIM's interrupt pending bits.
   1549            * @param  TIM5_IT: Specifies the pending bit to clear.
   1550            *          This parameter can be any combination of the following values:
   1551            *            @arg TIM5_IT_Update: Update
   1552            *            @arg TIM5_IT_CC1: Capture Compare Channel1
   1553            *            @arg TIM5_IT_CC2: Capture Compare Channel2 
   1554            *            @arg TIM5_IT_Trigger: Trigger 
   1555            *            @arg TIM5_IT_Break: Break  
   1556            * @retval None
   1557            */

   \                                 In section .near_func.text, align 1
   1558          void TIM5_ClearITPendingBit(TIM5_IT_TypeDef TIM5_IT)
   1559          {
   1560            /* Check the parameters */
   1561            assert_param(IS_TIM5_IT(TIM5_IT));
   1562          
   1563            /* Clear the IT pending Bit */
   1564            TIM5->SR1 = (uint8_t)(~(uint8_t)TIM5_IT);
   \                     TIM5_ClearITPendingBit:
   \   000000 43           CPL       A
   \   000001 C7 5306      LD        L:0x5306, A
   1565          }
   \   000004 81           RET
   1566          
   1567          /**
   1568            * @brief  Enables or disables the TIM5 DMA Requests.
   1569            * @param  TIM5_DMASource: specifies the DMA Request sources.
   1570            *          This parameter can be any combination of the following values:
   1571            *            @arg TIM5_DMASource_Update: TIM5 DMA Update Request
   1572            *            @arg TIM5_DMASource_CC1: TIM5 DMA CC1 Request
   1573            *            @arg TIM5_DMASource_CC2: TIM5 DMA CC2 Request 
   1574            * @param  NewState: new state of the DMA Request sources.
   1575            *          This parameter can be: ENABLE or DISABLE.
   1576            * @retval None
   1577            */

   \                                 In section .near_func.text, align 1
   1578          void TIM5_DMACmd( TIM5_DMASource_TypeDef TIM5_DMASource, FunctionalState NewState)
   1579          {
   1580            /* Check the parameters */
   1581            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1582            assert_param(IS_TIM5_DMA_SOURCE(TIM5_DMASource));
   1583          
   1584            if (NewState != DISABLE)
   \                     TIM5_DMACmd:
   \   000000 3D ..        TNZ       S:?b0
   \   000002 27 05        JREQ      L:??TIM5_DMACmd_0
   1585            {
   1586              /* Enable the DMA sources */
   1587              TIM5->DER |= TIM5_DMASource;
   \   000004 CA 5304      OR        A, L:0x5304
   \   000007 20 04        JRA       L:??TIM5_DMACmd_1
   1588            }
   1589            else
   1590            {
   1591              /* Disable the DMA sources */
   1592              TIM5->DER &= (uint8_t)(~TIM5_DMASource);
   \                     ??TIM5_DMACmd_0:
   \   000009 43           CPL       A
   \   00000A C4 5304      AND       A, L:0x5304
   \                     ??TIM5_DMACmd_1:
   \   00000D C7 5304      LD        L:0x5304, A
   1593            }
   1594          }
   \   000010 81           RET
   1595          
   1596          /**
   1597            * @brief  Selects the TIM5 peripheral Capture Compare DMA source.
   1598            * @param   NewState: new state of the Capture Compare DMA source.
   1599            *           This parameter can be: ENABLE or DISABLE.
   1600            * @retval None
   1601            */

   \                                 In section .near_func.text, align 1
   1602          void TIM5_SelectCCDMA(FunctionalState NewState)
   1603          {
   1604            /* Check the parameters */
   1605            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1606          
   1607            if (NewState != DISABLE)
   \                     TIM5_SelectCCDMA:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM5_SelectCCDMA_0
   1608            {
   1609              /* Set the CCDS Bit */
   1610              TIM5->CR2 |= TIM_CR2_CCDS;
   \   000003 7216 5301    BSET      L:0x5301, #0x3
   \   000007 81           RET
   1611            }
   1612            else
   1613            {
   1614              /* Reset the CCDS Bit */
   1615              TIM5->CR2 &= (uint8_t)(~TIM_CR2_CCDS);
   \                     ??TIM5_SelectCCDMA_0:
   \   000008 7217 5301    BRES      L:0x5301, #0x3
   1616            }
   1617          }
   \   00000C 81           RET
   1618          
   1619          /**
   1620            * @}
   1621            */
   1622          
   1623          /** @defgroup TIM5_Group5 Clocks management functions
   1624           *  @brief    Clocks management functions
   1625           *
   1626          @verbatim   
   1627           ===============================================================================
   1628                                   Clocks management functions
   1629           ===============================================================================  
   1630          
   1631          @endverbatim
   1632            * @{
   1633            */
   1634          
   1635          /**
   1636            * @brief  Enables the TIM5 internal Clock.
   1637            * @par Parameters:
   1638            * None
   1639            * @retval None
   1640            */

   \                                 In section .near_func.text, align 1
   1641          void TIM5_InternalClockConfig(void)
   1642          {
   1643            /* Disable slave mode to clock the prescaler directly with the internal clock */
   1644            TIM5->SMCR &=  (uint8_t)(~TIM_SMCR_SMS);
   \                     TIM5_InternalClockConfig:
   \   000000 CD ....      CALL      L:?Subroutine2
   1645          }
   \                     ??CrossCallReturnLabel_6:
   \   000003 81           RET

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine2:
   \   000000 C6 5302      LD        A, L:0x5302
   \   000003 A4 F8        AND       A, #0xf8
   \   000005 C7 5302      LD        L:0x5302, A
   \   000008 81           RET
   1646          
   1647          /**
   1648            * @brief  Configures the TIM5 Trigger as External Clock.
   1649            * @param  TIM5_TIxExternalCLKSource: Specifies Trigger source.
   1650            *          This parameter can be one of the following values:
   1651            *            @arg TIM5_TIxExternalCLK1Source_TI1ED: External Clock mode 1 source = TI1ED
   1652            *            @arg TIM5_TIxExternalCLK1Source_TI1: External Clock mode 1 source = TI1 
   1653            *            @arg TIM5_TIxExternalCLK1Source_TI2: External Clock mode 1 source = TI2  
   1654            * @param  TIM5_ICPolarity: Specifies the TIx Polarity.
   1655            *          This parameter can be one of the following values:
   1656            *            @arg TIM5_ICPolarity_Rising: Input Capture on Rising Edge
   1657            *            @arg TIM5_ICPolarity_Falling: Input Capture on Falling Edge  
   1658            * @param  ICFilter: Specifies the filter value.
   1659            *          This parameter must be a value between 0x00 and 0x0F
   1660            * @retval None
   1661            */

   \                                 In section .near_func.text, align 1
   1662          void TIM5_TIxExternalClockConfig(TIM5_TIxExternalCLK1Source_TypeDef TIM5_TIxExternalCLKSource,
   1663                                           TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
   1664                                           uint8_t ICFilter)
   1665          {
   \                     TIM5_TIxExternalClockConfig:
   \   000000 B7 ..        LD        S:?b3, A
   \   000002 45 .. ..     MOV       S:?b2, S:?b0
   1666            /* Check the parameters */
   1667            assert_param(IS_TIM5_TIXCLK_SOURCE(TIM5_TIxExternalCLKSource));
   1668            assert_param(IS_TIM5_IC_POLARITY(TIM5_ICPolarity));
   1669            assert_param(IS_TIM5_IC_FILTER(ICFilter));
   1670          
   1671            /* Configure the TIM5 Input Clock Source */
   1672            if (TIM5_TIxExternalCLKSource == TIM5_TIxExternalCLK1Source_TI2)
   \   000005 A1 60        CP        A, #0x60
   \   000007 35 01 ....   MOV       S:?b0, #0x1
   \   00000B 26 07        JRNE      L:??TIM5_TIxExternalClockConfig_0
   1673            {
   1674              TI2_Config(TIM5_ICPolarity, TIM5_ICSelection_DirectTI, ICFilter);
   \   00000D B6 ..        LD        A, S:?b2
   \   00000F CD ....      CALL      L:TI2_Config
   \   000012 20 05        JRA       L:??TIM5_TIxExternalClockConfig_1
   1675            }
   1676            else
   1677            {
   1678              TI1_Config(TIM5_ICPolarity, TIM5_ICSelection_DirectTI, ICFilter);
   \                     ??TIM5_TIxExternalClockConfig_0:
   \   000014 B6 ..        LD        A, S:?b2
   \   000016 CD ....      CALL      L:TI1_Config
   1679            }
   1680          
   1681            /* Select the Trigger source */
   1682            TIM5_SelectInputTrigger((TIM5_TRGSelection_TypeDef)TIM5_TIxExternalCLKSource);
   \                     ??TIM5_TIxExternalClockConfig_1:
   \   000019 B6 ..        LD        A, S:?b3
   \   00001B CD ....      CALL      L:TIM5_SelectInputTrigger
   1683          
   1684            /* Select the External clock mode1 */
   1685            TIM5->SMCR |= (uint8_t)(TIM5_SlaveMode_External1);
   \   00001E CD ....      CALL      L:?Subroutine3
   1686          }
   \                     ??CrossCallReturnLabel_8:
   \   000021 81           RET

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine3:
   \   000000 C6 5302      LD        A, L:0x5302
   \   000003 AA 07        OR        A, #0x7
   \   000005 C7 5302      LD        L:0x5302, A
   \   000008 81           RET
   1687          
   1688          /**
   1689            * @brief  Configures the TIM5 External clock Mode1.
   1690            * @param  TIM5_ExtTRGPrescaler: Specifies the external Trigger Prescaler.
   1691            *          This parameter can be one of the following values:
   1692            *            @arg TIM5_ExtTRGPSC_OFF: No External Trigger prescaler
   1693            *            @arg TIM5_ExtTRGPSC_DIV2: External Trigger prescaler = 2 (ETRP frequency divided by 2)
   1694            *            @arg TIM5_ExtTRGPSC_DIV4: External Trigger prescaler = 4 (ETRP frequency divided by 4) 
   1695            *            @arg TIM5_ExtTRGPSC_DIV8: External Trigger prescaler = 8 (ETRP frequency divided by 8)   
   1696            * @param  TIM5_ExtTRGPolarity: Specifies the external Trigger Polarity.
   1697            *          This parameter can be one of the following values:
   1698            *            @arg TIM5_ExtTRGPolarity_Inverted: External Trigger Polarity = inverted
   1699            *            @arg TIM5_ExtTRGPolarity_NonInverted: External Trigger Polarity = non inverted
   1700            * @param  ExtTRGFilter: Specifies the External Trigger Filter.
   1701            *          This parameter must be a value between 0x00 and 0x0F
   1702            * @retval None
   1703            */

   \                                 In section .near_func.text, align 1
   1704          void TIM5_ETRClockMode1Config(TIM5_ExtTRGPSC_TypeDef TIM5_ExtTRGPrescaler,
   1705                                        TIM5_ExtTRGPolarity_TypeDef TIM5_ExtTRGPolarity,
   1706                                        uint8_t ExtTRGFilter)
   1707          {
   1708            /* Configure the ETR Clock source */
   1709            TIM5_ETRConfig(TIM5_ExtTRGPrescaler, TIM5_ExtTRGPolarity, ExtTRGFilter);
   \                     TIM5_ETRClockMode1Config:
   \   000000 CD ....      CALL      L:TIM5_ETRConfig
   1710          
   1711            /* Select the External clock mode1 */
   1712            TIM5->SMCR &= (uint8_t)(~TIM_SMCR_SMS);
   \   000003 CD ....      CALL      L:?Subroutine2
   1713            TIM5->SMCR |= (uint8_t)(TIM5_SlaveMode_External1);
   \                     ??CrossCallReturnLabel_5:
   \   000006 CD ....      CALL      L:?Subroutine3
   1714          
   1715            /* Select the Trigger selection: ETRF */
   1716            TIM5->SMCR &= (uint8_t)(~TIM_SMCR_TS);
   \                     ??CrossCallReturnLabel_7:
   \   000009 C6 5302      LD        A, L:0x5302
   \   00000C A4 8F        AND       A, #0x8f
   \   00000E C7 5302      LD        L:0x5302, A
   1717            TIM5->SMCR |= (uint8_t)((TIM5_TRGSelection_TypeDef)TIM5_TRGSelection_ETRF);
   \   000011 C6 5302      LD        A, L:0x5302
   \   000014 AA 70        OR        A, #0x70
   \   000016 C7 5302      LD        L:0x5302, A
   1718          }
   \   000019 81           RET
   1719          
   1720          /**
   1721            * @brief  Configures the TIM5 External clock Mode2.
   1722            * @param  TIM5_ExtTRGPrescaler: Specifies the external Trigger Prescaler.
   1723            *          This parameter can be one of the following values:
   1724            *            @arg TIM5_ExtTRGPSC_OFF: No External Trigger prescaler
   1725            *            @arg TIM5_ExtTRGPSC_DIV2: External Trigger prescaler = 2 (ETRP frequency divided by 2)
   1726            *            @arg TIM5_ExtTRGPSC_DIV4: External Trigger prescaler = 4 (ETRP frequency divided by 4) 
   1727            *            @arg TIM5_ExtTRGPSC_DIV8: External Trigger prescaler = 8 (ETRP frequency divided by 8) 
   1728            * @param  TIM5_ExtTRGPolarity: Specifies the external Trigger Polarity.
   1729            *          This parameter can be one of the following values:
   1730            *            @arg TIM5_ExtTRGPolarity_Inverted: External Trigger Polarity = inverted
   1731            *            @arg TIM5_ExtTRGPolarity_NonInverted: External Trigger Polarity = non inverted
   1732            * @param  ExtTRGFilter: Specifies the External Trigger Filter.
   1733            *          This parameter must be a value between 0x00 and 0x0F
   1734            * @retval None
   1735            */

   \                                 In section .near_func.text, align 1
   1736          void TIM5_ETRClockMode2Config(TIM5_ExtTRGPSC_TypeDef TIM5_ExtTRGPrescaler,
   1737                                        TIM5_ExtTRGPolarity_TypeDef TIM5_ExtTRGPolarity,
   1738                                        uint8_t ExtTRGFilter)
   1739          {
   1740            /* Configure the ETR Clock source */
   1741            TIM5_ETRConfig(TIM5_ExtTRGPrescaler, TIM5_ExtTRGPolarity, ExtTRGFilter);
   \                     TIM5_ETRClockMode2Config:
   \   000000 CD ....      CALL      L:TIM5_ETRConfig
   1742          
   1743            /* Enable the External clock mode2 */
   1744            TIM5->ETR |= TIM_ETR_ECE ;
   \   000003 721C 5303    BSET      L:0x5303, #0x6
   1745          }
   \   000007 81           RET
   1746          
   1747          /**
   1748            * @}
   1749            */
   1750          
   1751          /** @defgroup TIM5_Group6 Synchronization management functions
   1752           *  @brief    Synchronization management functions 
   1753           *
   1754          @verbatim   
   1755           ===============================================================================
   1756                                 Synchronization management functions
   1757           ===============================================================================  
   1758                             
   1759                 ===================================================================      
   1760                        TIM5 Driver: how to use it in synchronization Mode
   1761                 =================================================================== 
   1762                 Case of two/several Timers
   1763                 **************************
   1764                 1. If TIM5 is used as master to other timers use the following functions:
   1765                    - TIM5_SelectOutputTrigger()
   1766                    - TIM5_SelectMasterSlaveMode()
   1767                 2. If TIM5 is used as slave to other timers use the following functions:
   1768                    - TIM5_SelectInputTrigger()
   1769                    - TIM5_SelectSlaveMode()
   1770                    
   1771                 Case of Timers and external trigger (TRIG pin)
   1772                 ********************************************       
   1773                 1. Configure the External trigger using TIM5_ETRConfig()
   1774                 2. Configure the Slave Timer using the following functions:
   1775                    - TIM5_SelectInputTrigger()
   1776                    - TIM5_SelectSlaveMode()
   1777          
   1778          @endverbatim
   1779            * @{
   1780            */
   1781          
   1782          /**
   1783            * @brief  Selects the TIM5 Input Trigger source.
   1784            * @param  TIM5_InputTriggerSource: Specifies Input Trigger source.
   1785            *          This parameter can be one of the following values:
   1786            *            @arg TIM5_TRGSelection_TIM4: TRIG Input source =  TIM TRIG Output
   1787            *            @arg TIM5_TRGSelection_TIM1: TRIG Input source =  TIM TRIG Output
   1788            *            @arg TIM5_TRGSelection_TIM3: TRIG Input source =  TIM TRIG Output
   1789            *            @arg TIM5_TRGSelection_TIM2: TRIG Input source =  TIM TRIG Output
   1790            *            @arg TIM5_TRGSelection_TI1F_ED: TRIG Input source = TI1F_ED (TI1 Edge Detector)
   1791            *            @arg TIM5_TRGSelection_TI1FP1: TRIG Input source = TI1FP1 (Filtred Timer Input 1)
   1792            *            @arg TIM5_TRGSelection_TI2FP2: TRIG Input source = TI2FP2 (Filtred Timer Input 2)
   1793            *            @arg TIM5_TRGSelection_ETRF: TRIG Input source =  ETRF (External Trigger Input )      
   1794            * @retval None
   1795            */

   \                                 In section .near_func.text, align 1
   1796          void TIM5_SelectInputTrigger(TIM5_TRGSelection_TypeDef TIM5_InputTriggerSource)
   1797          {
   \                     TIM5_SelectInputTrigger:
   \   000000 B7 ..        LD        S:?b0, A
   1798            uint8_t tmpsmcr = 0;
   1799          
   1800            /* Check the parameters */
   1801            assert_param(IS_TIM5_TRIGGER_SELECTION(TIM5_InputTriggerSource));
   1802          
   1803            tmpsmcr = TIM5->SMCR;
   \   000002 C6 5302      LD        A, L:0x5302
   1804          
   1805            /* Select the Trigger Source */
   1806            tmpsmcr &= (uint8_t)(~TIM_SMCR_TS);
   1807            tmpsmcr |= (uint8_t)TIM5_InputTriggerSource;
   1808          
   1809            TIM5->SMCR = (uint8_t)tmpsmcr;
   \   000005 A4 8F        AND       A, #0x8f
   \   000007 BA ..        OR        A, S:?b0
   \   000009 C7 5302      LD        L:0x5302, A
   1810          }
   \   00000C 81           RET
   1811          
   1812          /**
   1813            * @brief  Selects the TIM5 Trigger Output Mode.
   1814            * @param  TIM5_TRGOSource: Specifies the Trigger Output source.
   1815            *          This parameter can be one of the following values:
   1816            *            @arg TIM5_TRGOSource_Reset: Trigger Output source = Reset 
   1817            *            @arg TIM5_TRGOSource_Enable: Trigger Output source = TIM5 is enabled 
   1818            *            @arg TIM5_TRGOSource_Update: Trigger Output source = Update event
   1819            *            @arg TIM5_TRGOSource_OC1: Trigger Output source = output compare channel1
   1820            *            @arg TIM5_TRGOSource_OC1REF: Trigger Output source = output compare channel 1 reference
   1821            *            @arg TIM5_TRGOSource_OC2REF: Trigger Output source = output compare channel 2 reference   
   1822            * @retval None
   1823            */

   \                                 In section .near_func.text, align 1
   1824          void TIM5_SelectOutputTrigger(TIM5_TRGOSource_TypeDef TIM5_TRGOSource)
   1825          {
   \                     TIM5_SelectOutputTrigger:
   \   000000 B7 ..        LD        S:?b0, A
   1826            uint8_t tmpcr2 = 0;
   1827          
   1828            /* Check the parameters */
   1829            assert_param(IS_TIM5_TRGO_SOURCE(TIM5_TRGOSource));
   1830          
   1831            tmpcr2 = TIM5->CR2;
   \   000002 C6 5301      LD        A, L:0x5301
   1832          
   1833            /* Reset the MMS Bits */
   1834            tmpcr2 &= (uint8_t)(~TIM_CR2_MMS);
   1835          
   1836            /* Select the TRGO source */
   1837            tmpcr2 |=  (uint8_t)TIM5_TRGOSource;
   1838          
   1839            TIM5->CR2 = tmpcr2;
   \   000005 A4 8F        AND       A, #0x8f
   \   000007 BA ..        OR        A, S:?b0
   \   000009 C7 5301      LD        L:0x5301, A
   1840          }
   \   00000C 81           RET
   1841          
   1842          /**
   1843            * @brief  Selects the TIM5 Slave Mode.
   1844            * @param  TIM5_SlaveMode: Specifies the TIM5 Slave Mode.
   1845            *          This parameter can be one of the following values:
   1846            *            @arg TIM5_SlaveMode_Reset: Slave Mode Selection  = Reset
   1847            *            @arg TIM5_SlaveMode_Gated: Slave Mode Selection  = Gated
   1848            *            @arg TIM5_SlaveMode_Trigger: Slave Mode Selection  = Trigger
   1849            *            @arg TIM5_SlaveMode_External1: Slave Mode Selection  = External 1  
   1850            * @retval None
   1851            */

   \                                 In section .near_func.text, align 1
   1852          void TIM5_SelectSlaveMode(TIM5_SlaveMode_TypeDef TIM5_SlaveMode)
   1853          {
   \                     TIM5_SelectSlaveMode:
   \   000000 B7 ..        LD        S:?b0, A
   1854            uint8_t tmpsmcr = 0;
   1855          
   1856            /* Check the parameters */
   1857            assert_param(IS_TIM5_SLAVE_MODE(TIM5_SlaveMode));
   1858          
   1859            tmpsmcr = TIM5->SMCR;
   \   000002 C6 5302      LD        A, L:0x5302
   1860          
   1861            /* Reset the SMS Bits */
   1862            tmpsmcr &= (uint8_t)(~TIM_SMCR_SMS);
   1863          
   1864            /* Select the Slave Mode */
   1865            tmpsmcr |= (uint8_t)TIM5_SlaveMode;
   1866          
   1867            TIM5->SMCR = tmpsmcr;
   \   000005 A4 F8        AND       A, #0xf8
   \   000007 BA ..        OR        A, S:?b0
   \   000009 C7 5302      LD        L:0x5302, A
   1868          }
   \   00000C 81           RET
   1869          
   1870          /**
   1871            * @brief  Sets or Resets the TIM5 Master/Slave Mode.
   1872            * @param  NewState: The new state of the synchronization between TIM5 and its slaves (through TRGO).
   1873            *          This parameter can be ENABLE or DISABLE
   1874            * @retval None
   1875            */

   \                                 In section .near_func.text, align 1
   1876          void TIM5_SelectMasterSlaveMode(FunctionalState NewState)
   1877          {
   1878            /* Check the parameters */
   1879            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1880          
   1881            /* Set or Reset the MSM Bit */
   1882            if (NewState != DISABLE)
   \                     TIM5_SelectMasterSlaveMode:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM5_SelectMasterSlaveMode_0
   1883            {
   1884              TIM5->SMCR |= TIM_SMCR_MSM;
   \   000003 721E 5302    BSET      L:0x5302, #0x7
   \   000007 81           RET
   1885            }
   1886            else
   1887            {
   1888              TIM5->SMCR &= (uint8_t)(~TIM_SMCR_MSM);
   \                     ??TIM5_SelectMasterSlaveMode_0:
   \   000008 721F 5302    BRES      L:0x5302, #0x7
   1889            }
   1890          }
   \   00000C 81           RET
   1891          
   1892          /**
   1893            * @brief  Configures the TIM5 External Trigger.
   1894            * @param  TIM5_ExtTRGPrescaler: Specifies the external Trigger Prescaler.
   1895            *          This parameter can be one of the following values:
   1896            *            @arg TIM5_ExtTRGPSC_OFF: No External Trigger prescaler
   1897            *            @arg TIM5_ExtTRGPSC_DIV2: External Trigger prescaler = 2 (ETRP frequency divided by 2)
   1898            *            @arg TIM5_ExtTRGPSC_DIV4: External Trigger prescaler = 4 (ETRP frequency divided by 4)
   1899            *            @arg TIM5_ExtTRGPSC_DIV8: External Trigger prescaler = 8 (ETRP frequency divided by 8)    
   1900            * @param  TIM5_ExtTRGPolarity: Specifies the external Trigger Polarity.
   1901            *          This parameter can be one of the following values:
   1902            *            @arg TIM5_ExtTRGPolarity_Inverted: External Trigger Polarity = inverted
   1903            *            @arg TIM5_ExtTRGPolarity_NonInverted: External Trigger Polarity = non inverted
   1904            * @param  ExtTRGFilter: Specifies the External Trigger Filter.
   1905            *          This parameter must be a value between 0x00 and 0x0F
   1906            * @retval None
   1907            */

   \                                 In section .near_func.text, align 1
   1908          void TIM5_ETRConfig(TIM5_ExtTRGPSC_TypeDef TIM5_ExtTRGPrescaler,
   1909                              TIM5_ExtTRGPolarity_TypeDef TIM5_ExtTRGPolarity,
   1910                              uint8_t ExtTRGFilter)
   1911          {
   \                     TIM5_ETRConfig:
   \   000000 B7 ..        LD        S:?b2, A
   \   000002 B6 ..        LD        A, S:?b0
   1912            /* Check the parameters */
   1913            assert_param(IS_TIM5_EXT_PRESCALER(TIM5_ExtTRGPrescaler));
   1914            assert_param(IS_TIM5_EXT_POLARITY(TIM5_ExtTRGPolarity));
   1915            assert_param(IS_TIM5_EXT_FILTER(ExtTRGFilter));
   1916          
   1917            /* Set the Prescaler, the Filter value and the Polarity */
   1918            TIM5->ETR |= (uint8_t)((uint8_t)((uint8_t)TIM5_ExtTRGPrescaler | (uint8_t)TIM5_ExtTRGPolarity)
   1919                                   | (uint8_t)ExtTRGFilter);
   \   000004 BA ..        OR        A, S:?b2
   \   000006 BA ..        OR        A, S:?b1
   \   000008 CA 5303      OR        A, L:0x5303
   \   00000B C7 5303      LD        L:0x5303, A
   1920          }
   \   00000E 81           RET
   1921          
   1922          /**
   1923            * @}
   1924            */
   1925          
   1926          /** @defgroup TIM5_Group7 Specific interface management functions
   1927           *  @brief    Specific interface management functions 
   1928           *
   1929          @verbatim   
   1930           ===============================================================================
   1931                              Specific interface management functions
   1932           ===============================================================================  
   1933          
   1934          @endverbatim
   1935            * @{
   1936            */
   1937          
   1938          /**
   1939            * @brief  Configures the TIM5 Encoder Interface.
   1940            * @param  TIM5_EncoderMode: Specifies the TIM5 Encoder Mode.
   1941            *          This parameter can be one of the following values:
   1942            *            @arg TIM5_EncoderMode_TI1: Encoder mode 1
   1943            *            @arg TIM5_EncoderMode_TI2: Encoder mode 2
   1944            *            @arg TIM5_EncoderMode_TI12: Encoder mode 3   
   1945            * @param  TIM5_IC1Polarity: Specifies the IC1 Polarity.
   1946            *          This parameter can be one of the following values:
   1947            *            @arg TIM5_ICPolarity_Rising: Input Capture on Rising Edge
   1948            *            @arg TIM5_ICPolarity_Falling: Input Capture on Falling Edge  
   1949            * @param  TIM5_IC2Polarity: Specifies the IC2 Polarity.
   1950            *          This parameter can be one of the following values:
   1951            *            @arg TIM5_ICPolarity_Rising: Input Capture on Rising Edge
   1952            *            @arg TIM5_ICPolarity_Falling: Input Capture on Falling Edge  
   1953            * @retval None
   1954            */

   \                                 In section .near_func.text, align 1
   1955          void TIM5_EncoderInterfaceConfig(TIM5_EncoderMode_TypeDef TIM5_EncoderMode,
   1956                                           TIM5_ICPolarity_TypeDef TIM5_IC1Polarity,
   1957                                           TIM5_ICPolarity_TypeDef TIM5_IC2Polarity)
   1958          {
   \                     TIM5_EncoderInterfaceConfig:
   \   000000 B7 ..        LD        S:?b4, A
   1959            uint8_t tmpsmcr = 0;
   1960            uint8_t tmpccmr1 = 0;
   1961            uint8_t tmpccmr2 = 0;
   1962          
   1963            /* Check the parameters */
   1964            assert_param(IS_TIM5_ENCODER_MODE(TIM5_EncoderMode));
   1965            assert_param(IS_TIM5_IC_POLARITY(TIM5_IC1Polarity));
   1966            assert_param(IS_TIM5_IC_POLARITY(TIM5_IC2Polarity));
   1967          
   1968            tmpsmcr = TIM5->SMCR;
   \   000002 C6 5302      LD        A, L:0x5302
   \   000005 B7 ..        LD        S:?b2, A
   1969            tmpccmr1 = TIM5->CCMR1;
   \   000007 C6 5309      LD        A, L:0x5309
   \   00000A B7 ..        LD        S:?b3, A
   1970            tmpccmr2 = TIM5->CCMR2;
   \   00000C C6 530A      LD        A, L:0x530a
   \   00000F B7 ..        LD        S:?b5, A
   1971          
   1972            /* Set the encoder Mode */
   1973            tmpsmcr &= (uint8_t)(TIM_SMCR_MSM | TIM_SMCR_TS)  ;
   1974            tmpsmcr |= (uint8_t)TIM5_EncoderMode;
   \   000011 B6 ..        LD        A, S:?b2
   \   000013 A4 F0        AND       A, #0xf0
   \   000015 BA ..        OR        A, S:?b4
   \   000017 B7 ..        LD        S:?b4, A
   1975          
   1976            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   1977            tmpccmr1 &= (uint8_t)(~TIM_CCMR_CCxS);
   1978            tmpccmr2 &= (uint8_t)(~TIM_CCMR_CCxS);
   1979            tmpccmr1 |= TIM_CCMR_TIxDirect_Set;
   \   000019 B6 ..        LD        A, S:?b3
   \   00001B A4 FC        AND       A, #0xfc
   \   00001D AA 01        OR        A, #0x1
   \   00001F B7 ..        LD        S:?b3, A
   1980            tmpccmr2 |= TIM_CCMR_TIxDirect_Set;
   \   000021 B6 ..        LD        A, S:?b5
   \   000023 A4 FC        AND       A, #0xfc
   \   000025 AA 01        OR        A, #0x1
   \   000027 B7 ..        LD        S:?b2, A
   1981          
   1982            /* Set the TI1 and the TI2 Polarities */
   1983            if (TIM5_IC1Polarity == TIM5_ICPolarity_Falling)
   \   000029 B6 ..        LD        A, S:?b0
   \   00002B A1 01        CP        A, #0x1
   \   00002D 26 06        JRNE      L:??TIM5_EncoderInterfaceConfig_0
   1984            {
   1985              TIM5->CCER1 |= TIM_CCER1_CC1P ;
   \   00002F 7212 530B    BSET      L:0x530b, #0x1
   \   000033 20 04        JRA       L:??TIM5_EncoderInterfaceConfig_1
   1986            }
   1987            else
   1988            {
   1989              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P) ;
   \                     ??TIM5_EncoderInterfaceConfig_0:
   \   000035 7213 530B    BRES      L:0x530b, #0x1
   1990            }
   1991          
   1992            if (TIM5_IC2Polarity == TIM5_ICPolarity_Falling)
   \                     ??TIM5_EncoderInterfaceConfig_1:
   \   000039 B6 ..        LD        A, S:?b1
   \   00003B A1 01        CP        A, #0x1
   \   00003D 26 06        JRNE      L:??TIM5_EncoderInterfaceConfig_2
   1993            {
   1994              TIM5->CCER1 |= TIM_CCER1_CC2P ;
   \   00003F 721A 530B    BSET      L:0x530b, #0x5
   \   000043 20 04        JRA       L:??TIM5_EncoderInterfaceConfig_3
   1995            }
   1996            else
   1997            {
   1998              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   \                     ??TIM5_EncoderInterfaceConfig_2:
   \   000045 721B 530B    BRES      L:0x530b, #0x5
   1999            }
   2000          
   2001            TIM5->SMCR = tmpsmcr;
   \                     ??TIM5_EncoderInterfaceConfig_3:
   \   000049 B6 ..        LD        A, S:?b4
   \   00004B C7 5302      LD        L:0x5302, A
   2002            TIM5->CCMR1 = tmpccmr1;
   \   00004E B6 ..        LD        A, S:?b3
   \   000050 C7 5309      LD        L:0x5309, A
   2003            TIM5->CCMR2 = tmpccmr2;
   \   000053 B6 ..        LD        A, S:?b2
   \   000055 C7 530A      LD        L:0x530a, A
   2004          }
   \   000058 81           RET
   2005          
   2006          /**
   2007            * @brief  Enables or Disables the TIM’s Hall sensor interface.
   2008            * @param  NewState: The new state of the TIM5 Hall sensor interface.
   2009            *          This parameter can be ENABLE or DISABLE
   2010            * @retval None
   2011            */

   \                                 In section .near_func.text, align 1
   2012          void TIM5_SelectHallSensor(FunctionalState NewState)
   2013          {
   2014            /* Check the parameters */
   2015            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2016          
   2017            /* Set or Reset the TI1S Bit */
   2018            if (NewState != DISABLE)
   \                     TIM5_SelectHallSensor:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM5_SelectHallSensor_0
   2019            {
   2020              TIM5->CR2 |= TIM_CR2_TI1S;
   \   000003 721E 5301    BSET      L:0x5301, #0x7
   \   000007 81           RET
   2021            }
   2022            else
   2023            {
   2024              TIM5->CR2 &= (uint8_t)(~TIM_CR2_TI1S);
   \                     ??TIM5_SelectHallSensor_0:
   \   000008 721F 5301    BRES      L:0x5301, #0x7
   2025            }
   2026          }
   \   00000C 81           RET
   2027          
   2028          /**
   2029            * @}
   2030            */
   2031          
   2032          /**
   2033            * @brief  Configure the TI1 as Input.
   2034            * @param  TIM5_ICPolarity: Input Capture Polarity
   2035            *          This parameter can be one of the following values:
   2036            *            @arg TIM5_ICPolarity_Rising: Input Capture on Rising Edge
   2037            *            @arg TIM5_ICPolarity_Falling: Input Capture on Falling Edge  
   2038            * @param  TIM5_ICSelection: Specifies the input to be used.
   2039            *          This parameter can be one of the following values:
   2040            *            @arg TIM5_ICSelection_DirectTI: Input Capture mapped on the direct input
   2041            *            @arg TIM5_ICSelection_IndirectTI: Input Capture mapped on the indirect input
   2042            *            @arg TIM5_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
   2043            * @param  TIM5_ICFilter: Specifies the Input Capture Filter.
   2044            *          This parameter must be a value between 0x00 and 0x0F.
   2045            * @retval None
   2046            */

   \                                 In section .near_func.text, align 1
   2047          static void TI1_Config(TIM5_ICPolarity_TypeDef TIM5_ICPolarity, \
   2048                                 TIM5_ICSelection_TypeDef TIM5_ICSelection, \
   2049                                 uint8_t TIM5_ICFilter)
   2050          {
   \                     TI1_Config:
   \   000000 B7 ..        LD        S:?b2, A
   2051            uint8_t tmpccmr1 = 0;
   2052            uint8_t tmpicpolarity = TIM5_ICPolarity;
   2053            tmpccmr1 = TIM5->CCMR1;
   \   000002 C6 5309      LD        A, L:0x5309
   2054          
   2055            /* Check the parameters */
   2056            assert_param(IS_TIM5_IC_POLARITY(TIM5_ICPolarity));
   2057            assert_param(IS_TIM5_IC_SELECTION(TIM5_ICSelection));
   2058            assert_param(IS_TIM5_IC_FILTER(TIM5_ICFilter));
   2059          
   2060            /* Disable the Channel 1: Reset the CCE Bit */
   2061            TIM5->CCER1 &=  (uint8_t)(~TIM_CCER1_CC1E);
   \   000005 7211 530B    BRES      L:0x530b, #0x0
   2062          
   2063            /* Select the Input and set the filter */
   2064            tmpccmr1 &= (uint8_t)(~TIM_CCMR_CCxS) & (uint8_t)(~TIM_CCMR_ICxF);
   2065            tmpccmr1 |= (uint8_t)(((uint8_t)(TIM5_ICSelection)) | ((uint8_t)(TIM5_ICFilter << 4)));
   2066          
   2067            TIM5->CCMR1 = tmpccmr1;
   \   000009 CD ....      CALL      L:?Subroutine1
   \                     ??CrossCallReturnLabel_4:
   \   00000C C7 5309      LD        L:0x5309, A
   2068          
   2069            /* Select the Polarity */
   2070            if (tmpicpolarity == (uint8_t)(TIM5_ICPolarity_Falling))
   \   00000F B6 ..        LD        A, S:?b2
   \   000011 A1 01        CP        A, #0x1
   \   000013 26 06        JRNE      L:??TI1_Config_0
   2071            {
   2072              TIM5->CCER1 |= TIM_CCER1_CC1P;
   \   000015 7212 530B    BSET      L:0x530b, #0x1
   \   000019 20 04        JRA       L:??TI1_Config_1
   2073            }
   2074            else
   2075            {
   2076              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P);
   \                     ??TI1_Config_0:
   \   00001B 7213 530B    BRES      L:0x530b, #0x1
   2077            }
   2078          
   2079            /* Set the CCE Bit */
   2080            TIM5->CCER1 |=  TIM_CCER1_CC1E;
   \                     ??TI1_Config_1:
   \   00001F 7210 530B    BSET      L:0x530b, #0x0
   2081          }
   \   000023 81           RET

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine1:
   \   000000 A4 0C        AND       A, #0xc
   \   000002 BA ..        OR        A, S:?b0
   \   000004 B7 ..        LD        S:?b0, A
   \   000006 B6 ..        LD        A, S:?b1
   \   000008 4E           SWAP      A
   \   000009 A4 F0        AND       A, #0xf0
   \   00000B BA ..        OR        A, S:?b0
   \   00000D 81           RET
   2082          
   2083          /**
   2084            * @brief  Configure the TI2 as Input.
   2085            * @param  TIM5_ICPolarity: Input Capture Polarity
   2086            *          This parameter can be one of the following values:
   2087            *            @arg TIM5_ICPolarity_Rising: Input Capture on Rising Edge
   2088            *            @arg TIM5_ICPolarity_Falling: Input Capture on Falling Edge  
   2089            * @param  TIM5_ICSelection: Specifies the input to be used.
   2090            *          This parameter can be one of the following values:
   2091            *            @arg TIM5_ICSelection_DirectTI: Input Capture mapped on the direct input
   2092            *            @arg TIM5_ICSelection_IndirectTI: Input Capture mapped on the indirect input
   2093            *            @arg TIM5_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
   2094            * @param  TIM5_ICFilter: Specifies the Input Capture Filter.
   2095            *          This parameter must be a value between 0x00 and 0x0F.
   2096            * @retval None
   2097            */

   \                                 In section .near_func.text, align 1
   2098          static void TI2_Config(TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
   2099                                 TIM5_ICSelection_TypeDef TIM5_ICSelection,
   2100                                 uint8_t TIM5_ICFilter)
   2101          {
   \                     TI2_Config:
   \   000000 B7 ..        LD        S:?b2, A
   2102            uint8_t tmpccmr2 = 0;
   2103            uint8_t tmpicpolarity = TIM5_ICPolarity;
   2104          
   2105            /* Check the parameters */
   2106            assert_param(IS_TIM5_IC_POLARITY(TIM5_ICPolarity));
   2107            assert_param(IS_TIM5_IC_SELECTION(TIM5_ICSelection));
   2108            assert_param(IS_TIM5_IC_FILTER(TIM5_ICFilter));
   2109          
   2110            tmpccmr2 = TIM5->CCMR2;
   \   000002 C6 530A      LD        A, L:0x530a
   2111          
   2112            /* Disable the Channel 2: Reset the CCE Bit */
   2113            TIM5->CCER1 &=  (uint8_t)(~TIM_CCER1_CC2E);
   \   000005 7219 530B    BRES      L:0x530b, #0x4
   2114          
   2115            /* Select the Input and set the filter */
   2116            tmpccmr2 &= (uint8_t)(~TIM_CCMR_CCxS) & (uint8_t)(~TIM_CCMR_ICxF);
   2117            tmpccmr2 |= (uint8_t)(((uint8_t)(TIM5_ICSelection)) | ((uint8_t)(TIM5_ICFilter << 4)));
   2118          
   2119            TIM5->CCMR2 = tmpccmr2;
   \   000009 CD ....      CALL      L:?Subroutine1
   \                     ??CrossCallReturnLabel_3:
   \   00000C C7 530A      LD        L:0x530a, A
   2120          
   2121            /* Select the Polarity */
   2122            if (tmpicpolarity == TIM5_ICPolarity_Falling)
   \   00000F B6 ..        LD        A, S:?b2
   \   000011 A1 01        CP        A, #0x1
   \   000013 26 06        JRNE      L:??TI2_Config_0
   2123            {
   2124              TIM5->CCER1 |= TIM_CCER1_CC2P ;
   \   000015 721A 530B    BSET      L:0x530b, #0x5
   \   000019 20 04        JRA       L:??TI2_Config_1
   2125            }
   2126            else
   2127            {
   2128              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   \                     ??TI2_Config_0:
   \   00001B 721B 530B    BRES      L:0x530b, #0x5
   2129            }
   2130          
   2131            /* Set the CCE Bit */
   2132            TIM5->CCER1 |=  TIM_CCER1_CC2E;
   \                     ??TI2_Config_1:
   \   00001F 7218 530B    BSET      L:0x530b, #0x4
   2133          }
   \   000023 81           RET
   2134          
   2135          /**
   2136            * @}
   2137            */ 
   2138          
   2139          /**
   2140            * @}
   2141            */ 
   2142            
   2143          /**
   2144            * @}
   2145            */
   2146          
   2147          /**
   2148            * @}
   2149            */
   2150          
   2151          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      22  ?Subroutine0
      14  ?Subroutine1
       9  ?Subroutine2
       9  ?Subroutine3
      12  ?Subroutine4
      12  ?Subroutine5
      14  ?Subroutine6
       8  ?Subroutine7
       8  ?Subroutine8
       9  ?Subroutine9
      36  TI1_Config
      36  TI2_Config
      13  TIM5_ARRPreloadConfig
      16  TIM5_BKRConfig
      31  TIM5_CCxCmd
      13  TIM5_ClearFlag
       5  TIM5_ClearITPendingBit
      13  TIM5_Cmd
      13  TIM5_CounterModeConfig
      13  TIM5_CtrlPWMOutputs
      17  TIM5_DMACmd
     101  TIM5_DeInit
      26  TIM5_ETRClockMode1Config
       8  TIM5_ETRClockMode2Config
      15  TIM5_ETRConfig
      89  TIM5_EncoderInterfaceConfig
      13  TIM5_ForcedOC1Config
      13  TIM5_ForcedOC2Config
       7  TIM5_GenerateEvent
      12  TIM5_GetCapture1
      12  TIM5_GetCapture2
      12  TIM5_GetCounter
      38  TIM5_GetFlagStatus
      33  TIM5_GetITStatus
       4  TIM5_GetPrescaler
      35  TIM5_ICInit
      17  TIM5_ITConfig
       4  TIM5_InternalClockConfig
      13  TIM5_OC1FastConfig
      70  TIM5_OC1Init
      14  TIM5_OC1PolarityConfig
      13  TIM5_OC1PreloadConfig
      13  TIM5_OC2FastConfig
      70  TIM5_OC2Init
      14  TIM5_OC2PolarityConfig
      13  TIM5_OC2PreloadConfig
      74  TIM5_PWMIConfig
      19  TIM5_PrescalerConfig
      13  TIM5_SelectCCDMA
      13  TIM5_SelectHallSensor
      13  TIM5_SelectInputTrigger
      13  TIM5_SelectMasterSlaveMode
      45  TIM5_SelectOCxM
      14  TIM5_SelectOnePulseMode
      13  TIM5_SelectOutputTrigger
      13  TIM5_SelectSlaveMode
       4  TIM5_SetAutoreload
       6  TIM5_SetCompare1
       6  TIM5_SetCompare2
      14  TIM5_SetCounter
      13  TIM5_SetIC1Prescaler
      13  TIM5_SetIC2Prescaler
      34  TIM5_TIxExternalClockConfig
      31  TIM5_TimeBaseInit
      13  TIM5_UpdateDisableConfig
      14  TIM5_UpdateRequestConfig

 
 1 360 bytes in section .near_func.text
 
 1 360 bytes of CODE memory

Errors: none
Warnings: none
