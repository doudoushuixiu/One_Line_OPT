###############################################################################
#
# IAR C/C++ Compiler V2.10.2.149 for STM8                 16/Jun/2015  16:46:10
# Copyright 2010-2014 IAR Systems AB.
#
#    Source file  =  
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_rtc.c
#    Command line =  
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_rtc.c
#        -e -Ohz --debug --code_model small --data_model medium -o
#        "C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\STM8L05X_LD_VL(STM8L05xx3)\Obj\"
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\stm8\LIB\dlstm8smn.h" -D USE_STM8L1526_EVAL -D STM8L05X_LD_VL -lC
#        "C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\STM8L05X_LD_VL(STM8L05xx3)\List\"
#        -lA
#        "C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\STM8L05X_LD_VL(STM8L05xx3)\List\"
#        -I
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\..\
#        -I
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\..\..\..\Libraries\STM8L15x_StdPeriph_Driver\inc\
#        -I
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\..\..\..\Utilities\STM8_EVAL\
#        -I
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\..\..\..\Utilities\STM8_EVAL\STM8L1526_EVAL\
#        -I
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\..\..\..\Utilities\STM8_EVAL\Common\
#        -I
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\..\..\..\Utilities\Misc\
#        --require_prototypes --vregs 16
#    List file    =  
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\STM8L05X_LD_VL(STM8L05xx3)\List\stm8l15x_rtc.lst
#    Object file  =  
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\STM8L05X_LD_VL(STM8L05xx3)\Obj\stm8l15x_rtc.o
#
###############################################################################

C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_rtc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_rtc.c
      4            * @author  MCD Application Team
      5            * @version V1.6.0
      6            * @date    28-June-2013
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Real-Time Clock (RTC) peripheral:           
      9            *           - Initialization
     10            *           - Calendar (Time and Date) configuration
     11            *           - Alarm configuration
     12            *           - WakeUp Timer configuration
     13            *           - Daylight Saving configuration
     14            *           - Output pin Configuration
     15            *           - Smooth Calibration configuration
     16            *           - Tampers configuration
     17            *           - Output Type configuration
     18            *           - Interrupts and flags management       
     19            *                     
     20            *  @verbatim
     21            *       
     22            *          ===================================================================      
     23            *                                    RTC Domain Reset
     24            *          ===================================================================          
     25            *          After power-on reset, the RTC domain (RTC registers) is reset.        
     26            *         
     27            *          ===================================================================      
     28            *                                  RTC Operating Condition      
     29            *          ===================================================================            
     30            *          As long as the supply voltage remains in the operating range, 
     31            *          the RTC never stops, regardless of the device status (Run mode, 
     32            *          low power modes or under reset).
     33            *              
     34            *          ===================================================================      
     35            *                                   RTC Domain Access     
     36            *          ===================================================================         
     37            *          After reset, the RTC domain (RTC registers) is protected against 
     38            *          possible stray write accesses. 
     39            *          To enable access to the RTC registers, proceed as follows:
     40            *            - Select the RTC clock source using the CLK_RTCClockConfig()
     41            *              function : HSE, HSI, LSE or LSI.
     42            *              CLK_RTCClockConfig(CLK_RTCCLKSource_HSI, CLK_RTCCLKDiv_1)    
     43            *            - Enable RTC Clock using the CLK_PeripheralClockConfig() function 
     44            *               : CLK_PeripheralClockConfig(CLK_Peripheral_RTC, ENABLE).
     45            *              
     46            *          ===================================================================      
     47            *                                   RTC Driver: how to use it
     48            *          ===================================================================          
     49            *            - Enable the RTC domain access (see description in the section above)
     50            *            - Configure the RTC Prescaler (Asynchronous and Synchronous) and
     51            *              RTC hour format using the RTC_Init() function.
     52            *                
     53            *          Time and Date configuration
     54            *          ===========================    
     55            *            - To configure the RTC Calendar (Time and Date) use the RTC_SetTime()
     56            *              and RTC_SetDate() functions.
     57            *            - To read the RTC Calendar, use the RTC_GetTime() and RTC_GetDate()
     58            *              functions.
     59            *            - Use the RTC_DayLightSavingConfig() function to add or sub 1hour
     60            *              to the RTC Calendar.    
     61            *                
     62            *          Alarm configuration
     63            *          ===================    
     64            *            - To configure the RTC Alarm use the RTC_SetAlarm() function.
     65            *            - Enable the selected RTC Alarm using the RTC_AlarmCmd() function  
     66            *            - To read the RTC Alarm, use the RTC_GetAlarm() function.
     67            *              
     68            *          RTC Wakeup configuration
     69            *          ========================    
     70            *            - Configure the RTC Wakeup Clock source use the RTC_WakeUpClockConfig()
     71            *              function.
     72            *            - Configure the RTC WakeUp Counter using the RTC_SetWakeUpCounter() 
     73            *              function  
     74            *            - Enable the RTC WakeUp using the RTC_WakeUpCmd() function  
     75            *            - To read the RTC WakeUp Counter register, use the RTC_GetWakeUpCounter() 
     76            *              function.
     77            *                
     78            *          Outputs configuration
     79            *          =====================  
     80            *          The RTC has 2 different outputs:
     81            *            - AFO_ALARM: this output is used to manage the RTC Alarm and 
     82            *              WaKeUp signals.          
     83            *              To output the selected RTC signal on RTC_ALARM pin, use the 
     84            *              RTC_OutputConfig() function.                
     85            *            - AFO_CALIB: this output is used to manage the RTC Clock divided 
     86            *              by 64 (512Hz) signal or divided by 32768 (1Hz) which can be 
     87            *              configured using RTC_CalibOutputConfig() function.
     88            *              To output the RTC Clock on RTC_CALIB pin, use the 
     89            *              RTC_CalibOutputCmd() function.                
     90            *                                                           
     91            *          Smooth Calibration configuration                    
     92            *          =================================    
     93            *            - Configure the RTC Smooth Calibration Value and the corresponding
     94            *              sign using the RTC_SmoothCalibConfig() function.
     95          
     96            *                
     97            *
     98            *          Tamper configuration                     
     99            *          ====================    
    100            *            - Configure the RTC Tamper Level using the RTC_TamperConfig() 
    101            *              function.
    102            *            - Enable the RTC Tamper using the RTC_TamperCmd() function.
    103            *
    104            *                                  
    105            *          ===================================================================      
    106            *                                  RTC and low power modes
    107            *          =================================================================== 
    108            *           The MCU can be woken up from a low power mode by an RTC alternate 
    109            *           function.
    110            *           The RTC alternate functions are the RTC alarms, 
    111            *           RTC wakeup and RTC tamper event detection.
    112            *           These RTC alternate functions can wake up the system from the 
    113            *           lowpower modes.
    114            *           The system can also wake up from low power modes without depending 
    115            *           on an external interrupt (Auto-wakeup mode), by using the RTC alarm 
    116            *           or the RTC wakeup events.
    117            *           The RTC provides a programmable time base for waking up from the 
    118            *           halt or wfe or wfi modes at regular intervals.
    119            *           
    120            *                         
    121            *  @endverbatim
    122            *                      
    123            ******************************************************************************
    124            *
    125            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
    126            * You may not use this file except in compliance with the License.
    127            * You may obtain a copy of the License at:
    128            *
    129            *        http://www.st.com/software_license_agreement_liberty_v2
    130            *
    131            * Unless required by applicable law or agreed to in writing, software 
    132            * distributed under the License is distributed on an "AS IS" BASIS, 
    133            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    134            * See the License for the specific language governing permissions and
    135            * limitations under the License.
    136            *
    137            ****************************************************************************** 
    138            */    
    139          
    140          /* Includes ------------------------------------------------------------------*/
    141          #include "stm8l15x_rtc.h"
    142          
    143          /** @addtogroup STM8L15x_StdPeriph_Driver
    144            * @{
    145            */
    146            
    147          /** @defgroup RTC 
    148            * @brief RTC driver modules
    149            * @{
    150            */
    151            
    152          /* Private typedef -----------------------------------------------------------*/
    153          /* Private define ------------------------------------------------------------*/
    154          #define INIT_TIMEOUT       ((uint16_t)0xFFFF)
    155          #define RSF_TIMEOUT        ((uint16_t)0xFFFF)
    156          #define INITF_TIMEOUT      ((uint16_t)0xFFFF)
    157          #define WUTWF_TIMEOUT      ((uint16_t)0xFFFF)
    158          #define ALRAWF_TIMEOUT     ((uint16_t)0xFFFF)
    159          #define RECALPF_TIMEOUT    ((uint16_t)0xFFFF)
    160          #define SHPF_TIMEOUT       ((uint16_t)0xFFFF)
    161          
    162          #define TEN_VALUE_BCD      ((uint8_t)0x10)
    163          #define TEN_VALUE_BIN      ((uint8_t)0x0A)
    164          
    165          /* Private macro -------------------------------------------------------------*/
    166          /* Private variables ---------------------------------------------------------*/
    167          
    168          /** @defgroup RTC_Private_Functions_Prototype
    169            * @{
    170            */
    171          static uint8_t ByteToBcd2(uint8_t Value);
    172          static uint8_t Bcd2ToByte(uint8_t Value);
    173          
    174          /**
    175           * @}
    176           */
    177          
    178          /** @defgroup RTC_Private_Functions
    179            * @{
    180            */
    181          
    182          /** @defgroup RTC_Group1 Initialization and Configuration functions
    183           *  @brief   Initialization and Configuration functions 
    184           *
    185          @verbatim   
    186           ===============================================================================
    187                           Initialization and Configuration functions
    188           ===============================================================================  
    189          
    190            This section provide functions allowing to initialize and configure the RTC
    191            Prescaler (Synchronous and Asynchronous), RTC Hour format, disable RTC registers
    192            Write protection, enter and exit the RTC initialization mode, RTC registers
    193            synchronization check and reference clock detection enable.
    194            
    195            1. The RTC Prescaler is programmed to generate the RTC 1Hz time base. It is
    196               split into 2 programmable prescaler to minimize power consumption.
    197               - A 7-bit asynchronous prescaler and A 13-bit or 15-bit synchronous 
    198                 prescaler depending to density of the mcu package.
    199               - When both prescaler are used, it is recommended to configure the 
    200                 asynchronous prescaler to a high value to minimize consumption.
    201          
    202            2. All RTC registers are Write protected. Writing to the RTC registers
    203               is enabled by writing a key into the Write Protection register, RTC_WPR.
    204          
    205            3. To Configure the RTC Calendar, user application should enter initialization
    206               mode. In this mode, the Calendar counter is stopped and its value can be 
    207               updated. When the initialization sequence is complete, the Calendar restarts 
    208               counting after 4 RTCCLK cycles.
    209          
    210            4. To read the Calendar through the shadow registers after Calendar initialization,
    211               Calendar update or after wakeup from low power modes the software must first 
    212               clear the RSF flag. The software must then wait until it is set again before 
    213               reading the Calendar, which means that the Calendar registers have been 
    214               correctly copied into the RTC_TR and RTC_DR shadow registers.
    215               The RTC_WaitForSynchro() function implements the above software sequence 
    216               (RSF clear and RSF check).
    217          
    218          @endverbatim
    219            * @{
    220            */
    221          /**
    222          * @brief  Deinitializes the RTC registers to their default reset values.
    223          * @note   This function doesn't reset the RTC Clock source.  
    224          * @param  None
    225          * @retval An ErrorStatus enumeration value:
    226          *          - SUCCESS: RTC registers are deinitialized
    227          *          - ERROR: RTC registers are not deinitialized
    228          */

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine17:
   \   000000 35 CA 5159   MOV       L:0x5159, #0xca
   \   000004 35 53 5159   MOV       L:0x5159, #0x53
   \   000008 81           RET

   \                                 In section .near_func.text, align 1
   \                     ??Subroutine19_0:
   \   000000 35 FF 5159   MOV       L:0x5159, #0xff
   \   000004 81           RET

   \                                 In section .near_func.text, align 1
    229          ErrorStatus RTC_DeInit(void)
    230          {
    231            ErrorStatus status = ERROR;
   \                     RTC_DeInit:
   \   000000 3F ..        CLR       S:?b0
    232            uint16_t wutwfcount = 0;
    233            uint16_t recalpfcount = 0;
   \   000002 905F         CLRW      Y
    234          
    235            /* Disable the write protection for RTC registers */
    236            RTC->WPR = 0xCA;
   \   000004 CD ....      CALL      L:?Subroutine9
    237            RTC->WPR = 0x53;
    238          
    239            /* Set Initialization mode */
    240            if (RTC_EnterInitMode() == ERROR)
   \                     ??CrossCallReturnLabel_25:
   \   000007 26 03        JRNE      ??lb_0
   \   000009 CC ....      JP        L:??RTC_DeInit_0
    241            {
    242              status = ERROR;
    243              /* Enable the write protection for RTC registers */
    244              RTC->WPR = 0xFF; 
    245            }
    246            else
    247            {
    248              /* Reset TR registers */
    249              RTC->TR1 = RTC_TR1_RESET_VALUE;
   \                     ??lb_0:
   \   00000C 725F 5140    CLR       L:0x5140
    250              RTC->TR2 = RTC_TR2_RESET_VALUE;
   \   000010 725F 5141    CLR       L:0x5141
    251              RTC->TR3 = RTC_TR3_RESET_VALUE;
   \   000014 725F 5142    CLR       L:0x5142
    252          
    253              /* Reset DR registers */
    254              RTC->DR1 = RTC_DR1_RESET_VALUE;
   \   000018 35 01 5144   MOV       L:0x5144, #0x1
    255              RTC->DR2 = RTC_DR2_RESET_VALUE;
   \   00001C 35 21 5145   MOV       L:0x5145, #0x21
    256              RTC->DR3 = RTC_DR3_RESET_VALUE;
   \   000020 725F 5146    CLR       L:0x5146
    257          
    258              /* Reset SPER & ARPER registers */
    259              RTC->SPRERH = RTC_SPRERH_RESET_VALUE;
   \   000024 725F 5150    CLR       L:0x5150
    260              RTC->SPRERL = RTC_SPRERL_RESET_VALUE;
   \   000028 35 FF 5151   MOV       L:0x5151, #0xff
    261              RTC->APRER  = RTC_APRER_RESET_VALUE;
   \   00002C 35 7F 5152   MOV       L:0x5152, #0x7f
    262          
    263              RTC->TCR1 = RTC_TCR1_RESET_VALUE;
   \   000030 725F 516C    CLR       L:0x516c
    264              RTC->TCR2 = RTC_TCR2_RESET_VALUE;
   \   000034 725F 516D    CLR       L:0x516d
    265          
    266              /* Reset All CR1 bits except CR1[2:0] */
    267          
    268              RTC->CR1 = RTC_CR1_RESET_VALUE;
   \   000038 725F 5148    CLR       L:0x5148
    269              RTC->CR2 = RTC_CR2_RESET_VALUE;
   \   00003C 725F 5149    CLR       L:0x5149
    270              RTC->CR3 = RTC_CR3_RESET_VALUE;
   \   000040 725F 514A    CLR       L:0x514a
   \   000044 5F           CLRW      X
   \   000045 20 04        JRA       L:??RTC_DeInit_1
    271          
    272              /* Wait till RTC WUTWF flag is set or if Time out is reached exit */
    273              while (((RTC->ISR1 & RTC_ISR1_WUTWF) == RESET) && ( wutwfcount != WUTWF_TIMEOUT))
    274              {
    275                wutwfcount++;
    276                RTC->ISR1 = 0;
   \                     ??RTC_DeInit_2:
   \   000047 725F 514C    CLR       L:0x514c
   \                     ??RTC_DeInit_1:
   \   00004B 5A           DECW      X
    277              }
   \   00004C 7204 514C 02 BTJT      L:0x514c, #0x2, L:??RTC_DeInit_3
   \   000051 26 F4        JRNE      L:??RTC_DeInit_2
    278          
    279              if ((RTC->ISR1 & RTC_ISR1_WUTWF) == RESET)
   \                     ??RTC_DeInit_3:
   \   000053 7205 514C 5E BTJF      L:0x514c, #0x2, L:??RTC_DeInit_0
    280              {
    281                status = ERROR;
    282                /* Enable the write protection for RTC registers */
    283                RTC->WPR = 0xFF; 
    284              }
    285              else
    286              {
    287                /* Reset All CR1 bits */
    288                RTC->CR1 = RTC_CR1_RESET_VALUE;
   \   000058 725F 5148    CLR       L:0x5148
    289          
    290                /* Reset WUTR registers */
    291                RTC->WUTRH = RTC_WUTRH_RESET_VALUE;
   \   00005C 35 FF 5154   MOV       L:0x5154, #0xff
    292                RTC->WUTRL = RTC_WUTRL_RESET_VALUE;
   \   000060 35 FF 5155   MOV       L:0x5155, #0xff
    293          
    294                /* Reset ALARM registers */
    295                RTC->ALRMAR1 = RTC_ALRMAR1_RESET_VALUE;
   \   000064 725F 515C    CLR       L:0x515c
    296                RTC->ALRMAR2 = RTC_ALRMAR2_RESET_VALUE;
   \   000068 725F 515D    CLR       L:0x515d
    297                RTC->ALRMAR3 = RTC_ALRMAR3_RESET_VALUE;
   \   00006C 725F 515E    CLR       L:0x515e
    298                RTC->ALRMAR4 = RTC_ALRMAR4_RESET_VALUE;
   \   000070 725F 515F    CLR       L:0x515f
    299          
    300                RTC->ALRMASSRH = RTC_ALRMASSRH_RESET_VALUE;
   \   000074 725F 5164    CLR       L:0x5164
    301                RTC->ALRMASSRL = RTC_ALRMASSRL_RESET_VALUE;
   \   000078 725F 5165    CLR       L:0x5165
    302                RTC->ALRMASSMSKR = RTC_ALRMASSMSKR_RESET_VALUE;
   \   00007C 725F 5166    CLR       L:0x5166
    303          
    304                /* Reset ISR register and exit initialization mode */
    305                RTC->ISR1 = (uint8_t)0x00;
   \   000080 725F 514C    CLR       L:0x514c
    306                RTC->ISR2 = RTC_ISR2_RESET_VALUE;
   \   000084 725F 514D    CLR       L:0x514d
    307          
    308                if ((RTC->ISR1 & RTC_ISR1_RECALPF) != RESET)
   \   000088 7202 514C 06 BTJT      L:0x514c, #0x1, L:??RTC_DeInit_4
   \   00008D 20 0F        JRA       L:??RTC_DeInit_5
    309                {
    310                  while (((RTC->ISR1 & RTC_ISR1_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
    311                  {
    312                    recalpfcount++;
   \                     ??RTC_DeInit_6:
   \   00008F 93           LDW       X, Y
   \   000090 5C           INCW      X
   \   000091 9093         LDW       Y, X
    313                  }
   \                     ??RTC_DeInit_4:
   \   000093 7203 514C 06 BTJF      L:0x514c, #0x1, L:??RTC_DeInit_5
   \   000098 90A3 FFFF    CPW       Y, #0xffff
   \   00009C 26 F1        JRNE      L:??RTC_DeInit_6
    314                }
    315                if ((RTC->ISR1 & RTC_ISR1_RECALPF) == RESET)
   \                     ??RTC_DeInit_5:
   \   00009E 7202 514C 13 BTJT      L:0x514c, #0x1, L:??RTC_DeInit_0
    316                {
    317                  RTC->CALRH = RTC_CALRH_RESET_VALUE;
   \   0000A3 725F 516A    CLR       L:0x516a
    318                  RTC->CALRL = RTC_CALRL_RESET_VALUE;
   \   0000A7 725F 516B    CLR       L:0x516b
    319          
    320                  if (RTC_WaitForSynchro() == ERROR)
   \   0000AB CD ....      CALL      L:RTC_WaitForSynchro
   \   0000AE A1 00        CP        A, #0x0
   \   0000B0 27 04        JREQ      L:??RTC_DeInit_0
    321                  {
    322                    status = ERROR;
    323                  }
    324                  else
    325                  {
    326                    status = SUCCESS;
   \   0000B2 35 01 ....   MOV       S:?b0, #0x1
    327                  }
    328                }
    329                else
    330                {
    331                  status = ERROR;
    332                }
    333          
    334                /* Enable the write protection for RTC registers */
    335                RTC->WPR = 0xFF; 
   \                     ??RTC_DeInit_0:
   \   0000B6 CD ....      CALL      L:??Subroutine19_0
    336              }
    337            }
    338          
    339            /* return Deinitialize RTC registers status*/
    340            return (ErrorStatus)status;
   \                     ??CrossCallReturnLabel_75:
   \   0000B9 B6 ..        LD        A, S:?b0
   \   0000BB 81           RET
    341          }

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine9:
   \   000000 CD ....      CALL      L:?Subroutine17
   \                     ??CrossCallReturnLabel_53:
   \   000003 CD ....      CALL      L:RTC_EnterInitMode
   \   000006 A1 00        CP        A, #0x0
   \   000008 81           RET
    342          
    343          
    344          
    345          /**
    346          * @brief  Initializes the RTC registers according to the specified parameters
    347          *         in RTC_InitStruct.
    348          * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure that contains
    349          *         the configuration information for the RTC peripheral.
    350          * @note   The RTC Prescaler register is write protected and can be written in 
    351          *         initialization mode only.  
    352          * @retval An ErrorStatus enumeration value:
    353          *          - SUCCESS: RTC registers are initialized
    354          *          - ERROR: RTC registers are not initialized
    355          */

   \                                 In section .near_func.text, align 1
    356          ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
    357          {
   \                     RTC_Init:
   \   000000 BF ..        LDW       S:?w0, X
    358            ErrorStatus status = ERROR;
   \   000002 3F ..        CLR       S:?b2
    359          
    360            /* Check the parameters */
    361            assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
    362            assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
    363            assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
    364          
    365            /* Disable the write protection for RTC registers */
    366            RTC->WPR = 0xCA;
   \   000004 CD ....      CALL      L:?Subroutine9
    367            RTC->WPR = 0x53;
    368          
    369            /* Set Initialization mode */
    370            if (RTC_EnterInitMode() == ERROR)
   \                     ??CrossCallReturnLabel_24:
   \   000007 27 32        JREQ      L:??RTC_Init_0
    371            {
    372              status = ERROR;
    373            }
    374            else
    375            {
    376              /* Clear the bits to be configured first */
    377              RTC->CR1 &= ((uint8_t)~( RTC_CR1_FMT ));
   \   000009 721D 5148    BRES      L:0x5148, #0x6
    378          
    379              /* Set RTC_CR1 register */
    380              RTC->CR1 |=  ((uint8_t)(RTC_InitStruct->RTC_HourFormat));
   \   00000D 92C6 ..      LD        A, [S:?w0.w]
   \   000010 CA 5148      OR        A, L:0x5148
   \   000013 C7 5148      LD        L:0x5148, A
    381          
    382              /* Set Prescalers registers */
    383              RTC->SPRERH = (uint8_t)(RTC_InitStruct->RTC_SynchPrediv >> 8);
   \   000016 90BE ..      LDW       Y, S:?w0
   \   000019 72A9 0002    ADDW      Y, #0x2
   \   00001D 93           LDW       X, Y
   \   00001E FE           LDW       X, (X)
   \   00001F 4F           CLR       A
   \   000020 01           RRWA      X, A
   \   000021 9F           LD        A, XL
   \   000022 C7 5150      LD        L:0x5150, A
    384              RTC->SPRERL = (uint8_t)(RTC_InitStruct->RTC_SynchPrediv);
   \   000025 90FE         LDW       Y, (Y)
   \   000027 909F         LD        A, YL
   \   000029 C7 5151      LD        L:0x5151, A
    385              RTC->APRER =  (uint8_t)(RTC_InitStruct->RTC_AsynchPrediv);
   \   00002C BE ..        LDW       X, S:?w0
   \   00002E 5C           INCW      X
   \   00002F F6           LD        A, (X)
   \   000030 C7 5152      LD        L:0x5152, A
    386          
    387              /* Exit Initialization mode */
    388              RTC->ISR1 &= (uint8_t)~RTC_ISR1_INIT;
   \   000033 721F 514C    BRES      L:0x514c, #0x7
    389          
    390              status = SUCCESS;
   \   000037 35 01 ....   MOV       S:?b2, #0x1
    391            }
    392          
    393            /* Enable the write protection for RTC registers */
    394            RTC->WPR = 0xFF; 
   \                     ??RTC_Init_0:
   \   00003B CD ....      CALL      L:??Subroutine19_0
    395          
    396            /* return Initialize the RTC registers status*/
    397            return (ErrorStatus)(status);
   \                     ??CrossCallReturnLabel_74:
   \   00003E B6 ..        LD        A, S:?b2
   \   000040 81           RET
    398          }
    399          
    400          /**
    401          * @brief  Fills each RTC_InitStruct member with its default value
    402          *         Hour format = 24h / Prescalers configured to their reset values.
    403          * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure which will be
    404          *         initialized.
    405          * @retval None
    406          */

   \                                 In section .near_func.text, align 1
    407          void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
    408          {
    409            /* Initialize the RTC_Hourformat member */
    410            RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
   \                     RTC_StructInit:
   \   000000 4F           CLR       A
   \   000001 F7           LD        (X), A
    411          
    412            /* Initialize the RTC_AsynchPrediv member */
    413            RTC_InitStruct->RTC_AsynchPrediv = RTC_APRER_RESET_VALUE;
   \   000002 9093         LDW       Y, X
   \   000004 905C         INCW      Y
   \   000006 A6 7F        LD        A, #0x7f
   \   000008 90F7         LD        (Y), A
    414          
    415            /* Initialize the RTC_SynchPrediv member */
    416            RTC_InitStruct->RTC_SynchPrediv = RTC_SPRERL_RESET_VALUE;
   \   00000A 1C 0002      ADDW      X, #0x2
   \   00000D 90AE 00FF    LDW       Y, #0xff
   \   000011 FF           LDW       (X), Y
    417          }
   \   000012 81           RET
    418          
    419          /**
    420          * @brief  Enables or disables the RTC registers write protection.
    421          * @param  NewState: new state of the write protection.
    422            *         This parameter can be: ENABLE or DISABLE.
    423          * @note   Writing a wrong key reactivates the write protection.
    424          * @note   The protection mechanism is not affected by system reset.  
    425          * @retval None
    426          */

   \                                 In section .near_func.text, align 1
    427          void RTC_WriteProtectionCmd(FunctionalState NewState)
    428          {
    429            /* Check the parameters */
    430            assert_param(IS_FUNCTIONAL_STATE(NewState));
    431          
    432            if (NewState != DISABLE)
   \                     RTC_WriteProtectionCmd:
   \   000000 4D           TNZ       A
   \   000001 27 04        JREQ      L:??RTC_WriteProtectionCmd_0
    433            {
    434              /* Enable the write protection for RTC registers */
    435              RTC->WPR = RTC_WPR_EnableKey;
   \   000003 CD ....      CALL      L:??Subroutine19_0
    436            }
   \                     ??CrossCallReturnLabel_73:
   \   000006 81           RET
    437            else
    438            {
    439              /* Disable the write protection for RTC registers */
    440              RTC->WPR = RTC_WPR_DisableKey1;
   \                     ??RTC_WriteProtectionCmd_0:
   \   000007 CD ....      CALL      L:?Subroutine10
    441              RTC->WPR = RTC_WPR_DisableKey2;
    442            }
    443          }
   \                     ??CrossCallReturnLabel_34:
   \   00000A 81           RET

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine10:
   \   000000 CD ....      CALL      L:?Subroutine17
   \                     ??CrossCallReturnLabel_52:
   \   000003 81           RET
    444          
    445          
    446          /**
    447          * @brief  Enters the RTC Initialization mode.
    448          * @note   The RTC Initialization mode is write protected, use the 
    449          *         RTC_WriteProtectionCmd(DISABLE) before calling this function. 
    450          * @param  None
    451          * @retval An ErrorStatus enumeration value:
    452          *          - SUCCESS: RTC is in Init mode
    453          *          - ERROR: RTC is not in Init mode
    454          */

   \                                 In section .near_func.text, align 1
    455          ErrorStatus RTC_EnterInitMode(void)
    456          {
    457            ErrorStatus status = ERROR;
    458            uint16_t initfcount = 0;
    459          
    460            /* Check if the Initialization mode is set */
    461            if ((RTC->ISR1 & RTC_ISR1_INITF) == RESET)
   \                     RTC_EnterInitMode:
   \   000000 720C 514C 0D BTJT      L:0x514c, #0x6, L:??RTC_EnterInitMode_0
    462            {
    463              /* Set the Initialization mode */
    464              RTC->ISR1 = (uint8_t)RTC_ISR1_INIT;
   \   000005 35 80 514C   MOV       L:0x514c, #0x80
   \   000009 5F           CLRW      X
    465          
    466              /* Wait until INITF flag is set */
    467              while (((RTC->ISR1 & RTC_ISR1_INITF) == RESET) && ( initfcount != INITF_TIMEOUT))
    468              {
    469                initfcount++;
   \                     ??RTC_EnterInitMode_1:
   \   00000A 5A           DECW      X
    470              }
   \   00000B 720C 514C 02 BTJT      L:0x514c, #0x6, L:??RTC_EnterInitMode_0
   \   000010 26 F8        JRNE      L:??RTC_EnterInitMode_1
    471            }
    472          
    473            if ((RTC->ISR1 & RTC_ISR1_INITF) == RESET)
   \                     ??RTC_EnterInitMode_0:
   \   000012 C6 514C      LD        A, L:0x514c
    474            {
    475              status = ERROR;
    476            }
    477            else
    478            {
    479              status = SUCCESS;
    480            }
    481          
    482            return (ErrorStatus)status;
   \   000015 CD ....      CALL      L:?srl8_a_a_6
   \   000018 A4 01        AND       A, #0x1
   \   00001A 81           RET
    483          }
    484          
    485          
    486          /**
    487          * @brief  Exits the RTC Initialization mode.
    488          * @note   When the initialization sequence is complete, the Calendar restarts 
    489          *         counting after 4 RTCCLK cycles.  
    490          * @note   The RTC Initialization mode is write protected, use the 
    491          *         RTC_WriteProtectionCmd(DISABLE) before calling this function.     
    492          * @param  None
    493          * @retval None
    494          */

   \                                 In section .near_func.text, align 1
    495          void RTC_ExitInitMode(void)
    496          {
    497            /* Exit Initialization mode */
    498            RTC->ISR1 &= (uint8_t)~RTC_ISR1_INIT;
   \                     RTC_ExitInitMode:
   \   000000 721F 514C    BRES      L:0x514c, #0x7
    499          }
   \   000004 81           RET
    500          
    501          
    502          /**
    503          * @brief  Waits until the RTC Calendar registers (Time and Date)
    504          *         are synchronized with RTC clock.
    505          * @note   This function is meaningless when BAYPASS feature is enabled in RTC_CR1
    506          *         register.
    507          * @note   To read the Calendar through the shadow registers after Calendar 
    508          *         initialization, Calendar update or after wakeup from low power modes 
    509          *         the software must first clear the RSF flag. 
    510          *         The software must then wait until it is set again before reading 
    511          *         the Calendar (if not yet done), which means that the Calendar registers
    512          *         have been correctly copied into the RTC_TRx and RTC_DRx shadow registers.
    513          * @note   RTC_SetTime() and RTC_SetDate() functions call RTC_WaitForSynchro() function
    514          *         after updating the Calendar. In Run mode, User can use RTC_GetDate(), 
    515          *         RTC_GetTime() and/or RTC_GetSubSecond() without need to call 
    516          *         RTC_WaitForSynchro() function. After waking up from low power mode, this 
    517          *         function must be called before calling RTC_GetDate(), RTC_GetTime() or 
    518          *         RTC_GetSubSecond() functions.   
    519          * @param  None
    520          * @retval An ErrorStatus enumeration value:
    521          *          - SUCCESS: RTC registers are synchronized
    522          *          - ERROR: RTC registers are not synchronized
    523          */

   \                                 In section .near_func.text, align 1
    524          ErrorStatus RTC_WaitForSynchro(void)
    525          {
    526            uint16_t rsfcount = 0;
    527            ErrorStatus status = ERROR;
    528            
    529            /* Disable the write protection for RTC registers */
    530            RTC->WPR = 0xCA;
   \                     RTC_WaitForSynchro:
   \   000000 CD ....      CALL      L:?Subroutine10
    531            RTC->WPR = 0x53;
    532          
    533            /* Clear RSF flag by writing 0 in RSF bit  */
    534            RTC->ISR1 &= (uint8_t)~(RTC_ISR1_RSF | RTC_ISR1_INIT);
   \                     ??CrossCallReturnLabel_33:
   \   000003 C6 514C      LD        A, L:0x514c
   \   000006 A4 5F        AND       A, #0x5f
   \   000008 C7 514C      LD        L:0x514c, A
   \   00000B 5F           CLRW      X
    535          
    536            /* Wait the registers to be synchronised */
    537            while (((RTC->ISR1 & RTC_ISR1_RSF) == RESET) && ( rsfcount != RSF_TIMEOUT))
    538            {
    539              rsfcount++;
   \                     ??RTC_WaitForSynchro_0:
   \   00000C 5A           DECW      X
    540            }
   \   00000D 720A 514C 02 BTJT      L:0x514c, #0x5, L:??RTC_WaitForSynchro_1
   \   000012 26 F8        JRNE      L:??RTC_WaitForSynchro_0
    541          
    542            /* Check if RSF flag occurs*/
    543            if ((RTC->ISR1 & RTC_ISR1_RSF) != RESET)
   \                     ??RTC_WaitForSynchro_1:
   \   000014 C6 514C      LD        A, L:0x514c
    544            {
    545              status = SUCCESS;
    546            }
    547            else
    548            {
    549              status = ERROR;
    550            }
    551          
    552            /* Enable the write protection for RTC registers */
    553            RTC->WPR = 0xFF; 
   \   000017 CD ....      CALL      L:??Subroutine19_0
    554            
    555            return (ErrorStatus)status;
   \                     ??CrossCallReturnLabel_72:
   \   00001A CD ....      CALL      L:?srl8_a_a_5
   \   00001D A4 01        AND       A, #0x1
   \   00001F 81           RET
    556          }
    557          
    558          
    559          /**
    560          * @brief  Enables or Disables the RTC Ratio.
    561          * @param  NewState: new state of the Ratio feature.
    562            *         This parameter can be: ENABLE or DISABLE.
    563          * @retval None
    564          */

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine7:
   \   000000 CD ....      CALL      L:?Subroutine17
   \                     ??CrossCallReturnLabel_50:
   \   000003 4D           TNZ       A
   \   000004 81           RET

   \                                 In section .near_func.text, align 1
    565          void RTC_RatioCmd(FunctionalState NewState)
    566          {
    567            /* Check the parameters */
    568            assert_param(IS_FUNCTIONAL_STATE(NewState));
    569          
    570            /* Disable the write protection for RTC registers */
    571            RTC->WPR = 0xCA;
   \                     RTC_RatioCmd:
   \   000000 CD ....      CALL      L:?Subroutine7
    572            RTC->WPR = 0x53;
    573          
    574            if (NewState != DISABLE)
   \                     ??CrossCallReturnLabel_21:
   \   000003 27 06        JREQ      L:??RTC_RatioCmd_0
    575            {
    576              /* Set the RATIO bit */
    577              RTC->CR1 |= (uint8_t)RTC_CR1_RATIO;
   \   000005 721A 5148    BSET      L:0x5148, #0x5
   \   000009 20 04        JRA       L:??RTC_RatioCmd_1
    578            }
    579            else
    580            {
    581              /* Reset the RATIO bit */
    582              RTC->CR1 &= (uint8_t)~RTC_CR1_RATIO;
   \                     ??RTC_RatioCmd_0:
   \   00000B 721B 5148    BRES      L:0x5148, #0x5
    583            }
    584          
    585            /* Enable the write protection for RTC registers */
    586            RTC->WPR = 0xFF; 
   \                     ??RTC_RatioCmd_1:
   \   00000F CD ....      CALL      L:??Subroutine19_0
    587          }
   \                     ??CrossCallReturnLabel_71:
   \   000012 81           RET
    588          
    589          /**
    590          * @brief  Enables or Disables the Bypass Shadow feature.
    591          * @param  NewState: new state of the Bypass Shadow feature.
    592            *         This parameter can be: ENABLE or DISABLE.
    593          * @retval None
    594          */

   \                                 In section .near_func.text, align 1
    595          void RTC_BypassShadowCmd(FunctionalState NewState)
    596          {
    597            /* Check the parameters */
    598            assert_param(IS_FUNCTIONAL_STATE(NewState));
    599          
    600            /* Disable the write protection for RTC registers */
    601            RTC->WPR = 0xCA;
   \                     RTC_BypassShadowCmd:
   \   000000 CD ....      CALL      L:?Subroutine7
    602            RTC->WPR = 0x53;
    603          
    604            if (NewState != DISABLE)
   \                     ??CrossCallReturnLabel_20:
   \   000003 27 06        JREQ      L:??RTC_BypassShadowCmd_0
    605            {
    606              /* Set the BYPSHAD bit */
    607              RTC->CR1 |= (uint8_t)RTC_CR1_BYPSHAD;
   \   000005 7218 5148    BSET      L:0x5148, #0x4
   \   000009 20 04        JRA       L:??RTC_BypassShadowCmd_1
    608            }
    609            else
    610            {
    611              /* Reset the BYPSHAD bit */
    612              RTC->CR1 &= (uint8_t)~RTC_CR1_BYPSHAD;
   \                     ??RTC_BypassShadowCmd_0:
   \   00000B 7219 5148    BRES      L:0x5148, #0x4
    613            }
    614          
    615            /* Enable the write protection for RTC registers */
    616            RTC->WPR = 0xFF; 
   \                     ??RTC_BypassShadowCmd_1:
   \   00000F CD ....      CALL      L:??Subroutine19_0
    617          }
   \                     ??CrossCallReturnLabel_70:
   \   000012 81           RET
    618          
    619          
    620          
    621          
    622          /**
    623            * @}
    624            */
    625          
    626          /** @defgroup RTC_Group2 Time and Date configuration functions
    627           *  @brief   Time and Date configuration functions 
    628           *
    629          @verbatim   
    630           ===============================================================================
    631                             Time and Date configuration functions
    632           ===============================================================================  
    633          
    634            This section provide functions allowing to program and read the RTC Calendar
    635            (Time and Date).
    636          
    637          @endverbatim
    638            * @{
    639            */
    640          
    641          
    642          /**
    643          * @brief Sets the RTC current time.
    644          * @note   After updating the Calendar, this routine clears the RSF flag and waits
    645          *         until it is set again (using RTC_WaitForSynchro() function) , which means
    646          *         that the Calendar registers have been correctly copied into the RTC_TRx
    647          *         and RTC_DRx shadow registers. 
    648          * @param  RTC_Format: specifies the format of the entered parameters.
    649          *         This parameter can be one of the @ref RTC_Format_TypeDef enumeration.
    650          * @param  RTC_TimeStruct:  pointer to a  @ref RTC_TimeTypeDef structure that
    651          *         contains the time configuration information for the RTC
    652          * @retval An ErrorStatus enumeration value:
    653          *          - SUCCESS: RTC Time register is configured
    654          *          - ERROR: RTC Time register is not configured
    655          */

   \                                 In section .near_func.text, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000 721F 514C    BRES      L:0x514c, #0x7
   \   000004              REQUIRE ??Subroutine19_0
   \   000004              ;               // Fall through to label ??Subroutine19_0

   \                                 In section .near_func.text, align 1
    656          ErrorStatus RTC_SetTime(RTC_Format_TypeDef RTC_Format,
    657                                  RTC_TimeTypeDef* RTC_TimeStruct)
    658          {
   \                     RTC_SetTime:
   \   000000 CD ....      CALL      L:?push_l2
   \   000003 3B ....      PUSH      S:?b12
   \   000006 B7 ..        LD        S:?b11, A
   \   000008 BF ..        LDW       S:?w4, X
    659            ErrorStatus status = ERROR;
   \   00000A 3F ..        CLR       S:?b10
    660            uint8_t temp = 0;
   \   00000C 3F ..        CLR       S:?b12
    661          
    662            /* Check the parameters */
    663            assert_param(IS_RTC_FORMAT(RTC_Format));
    664          
    665            if (RTC_Format == RTC_Format_BIN)
    666            {
    667              /* Check Hour Format (24h or 12h)*/
    668              if ((RTC->CR1 & RTC_CR1_FMT) != RESET)
    669              {
    670                assert_param(IS_RTC_HOUR12_MAX(RTC_TimeStruct->RTC_Hours));
    671                assert_param(IS_RTC_HOUR12_MIN(RTC_TimeStruct->RTC_Hours));
    672              }
    673              else
    674              {
    675                assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
    676              }
    677              assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
    678              assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
    679            }
    680            else
    681            {
    682              /* Check Hour Format (24h or 12h)*/
    683              if ((RTC->CR1 & RTC_CR1_FMT) != RESET)
   \   00000E C6 5148      LD        A, L:0x5148
    684              {
    685                assert_param(IS_RTC_HOUR12_MAX(Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
    686                assert_param(IS_RTC_HOUR12_MIN(Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
    687              }
    688              else
    689              {
    690                assert_param(IS_RTC_HOUR24(Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
    691              }
    692              assert_param(IS_RTC_MINUTES(Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
    693              assert_param(IS_RTC_SECONDS(Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
    694            }
    695          
    696          
    697            /* Disable the write protection for RTC registers */
    698            RTC->WPR = 0xCA;
   \   000011 CD ....      CALL      L:?Subroutine8
    699            RTC->WPR = 0x53;
    700          
    701            /* Set Initialization mode */
    702            if (RTC_EnterInitMode() == ERROR)
   \                     ??CrossCallReturnLabel_23:
   \   000014 26 05        JRNE      L:??RTC_SetTime_0
    703            {
    704              status = ERROR;
    705              /* Enable the write protection for RTC registers */
    706              RTC->WPR = 0xFF; 
   \   000016 CD ....      CALL      L:??Subroutine19_0
    707            }
   \                     ??CrossCallReturnLabel_69:
   \   000019 20 4F        JRA       L:??RTC_SetTime_1
    708            else
    709            {
    710              /* Check Hour Format is 12h)*/
    711              if ((RTC->CR1 & RTC_CR1_FMT) != RESET)
   \                     ??RTC_SetTime_0:
   \   00001B 720D 5148 08 BTJF      L:0x5148, #0x6, L:??RTC_SetTime_2
    712              {
    713                assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
    714                temp = RTC_TimeStruct->RTC_H12;
   \   000020 BE ..        LDW       X, S:?w4
   \   000022 1C 0003      ADDW      X, #0x3
   \   000025 F6           LD        A, (X)
   \   000026 B7 ..        LD        S:?b12, A
    715              }
    716              else
    717              {
    718                temp = 0;
    719              }
    720              /* Check the input parameters format */
    721              if (RTC_Format != RTC_Format_BIN)
   \                     ??RTC_SetTime_2:
   \   000028 CD ....      CALL      L:?Subroutine16
   \                     ??CrossCallReturnLabel_46:
   \   00002B 5C           INCW      X
   \   00002C 3D ..        TNZ       S:?b11
   \   00002E 27 0C        JREQ      L:??RTC_SetTime_3
    722              {
    723                RTC->TR1 = (uint8_t)(RTC_TimeStruct->RTC_Seconds);
   \   000030 C7 5140      LD        L:0x5140, A
    724                RTC->TR2 = (uint8_t)(RTC_TimeStruct->RTC_Minutes) ;
   \   000033 F6           LD        A, (X)
   \   000034 C7 5141      LD        L:0x5141, A
    725                RTC->TR3 = (uint8_t)( temp | RTC_TimeStruct->RTC_Hours) ;
   \   000037 92C6 ..      LD        A, [S:?w4.w]
   \   00003A 20 13        JRA       L:??RTC_SetTime_4
    726              }
    727              else
    728              {
    729                RTC->TR1 = (uint8_t)(ByteToBcd2(RTC_TimeStruct->RTC_Seconds));
   \                     ??RTC_SetTime_3:
   \   00003C CD ....      CALL      L:ByteToBcd2
   \   00003F C7 5140      LD        L:0x5140, A
    730                RTC->TR2 = (uint8_t)(ByteToBcd2(RTC_TimeStruct->RTC_Minutes)) ;
   \   000042 F6           LD        A, (X)
   \   000043 CD ....      CALL      L:ByteToBcd2
   \   000046 C7 5141      LD        L:0x5141, A
    731                RTC->TR3 = (uint8_t)( temp | ByteToBcd2(RTC_TimeStruct->RTC_Hours));
   \   000049 92C6 ..      LD        A, [S:?w4.w]
   \   00004C CD ....      CALL      L:ByteToBcd2
   \                     ??RTC_SetTime_4:
   \   00004F BA ..        OR        A, S:?b12
   \   000051 C7 5142      LD        L:0x5142, A
    732              }
    733              /* Read DR3 register to unfreeze calender registers */
    734              (void)(RTC->DR3);
   \   000054 C6 5146      LD        A, L:0x5146
    735          
    736              /* Exit Initialization mode */
    737              RTC->ISR1 &= (uint8_t)~RTC_ISR1_INIT;
   \   000057 CD ....      CALL      L:?Subroutine12
    738          
    739              /* Enable the write protection for RTC registers */
    740              RTC->WPR = 0xFF; 
    741          
    742              /* if RTC_CR1_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    743              if ((RTC->CR1 & RTC_CR1_BYPSHAD) == RESET)
   \                     ??CrossCallReturnLabel_57:
   \   00005A 7208 5148 07 BTJT      L:0x5148, #0x4, L:??RTC_SetTime_5
    744              {
    745                if (RTC_WaitForSynchro() == ERROR)
   \   00005F CD ....      CALL      L:RTC_WaitForSynchro
   \   000062 A1 00        CP        A, #0x0
   \   000064 27 04        JREQ      L:??RTC_SetTime_1
    746                {
    747                  status = ERROR;
    748                }
    749                else
    750                {
    751                  status = SUCCESS;
    752                }
    753              }
    754              else
    755              {
    756                status = SUCCESS;
   \                     ??RTC_SetTime_5:
   \   000066 35 01 ....   MOV       S:?b10, #0x1
    757              }
    758            }
    759          
    760            return (ErrorStatus)status;
   \                     ??RTC_SetTime_1:
   \   00006A B6 ..        LD        A, S:?b10
   \   00006C 32 ....      POP       S:?b12
   \   00006F CC ....      JP        L:?epilogue_l2
    761          }

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine16:
   \   000000 BE ..        LDW       X, S:?w4
   \   000002 1C 0002      ADDW      X, #0x2
   \   000005 F6           LD        A, (X)
   \   000006 BE ..        LDW       X, S:?w4
   \   000008 81           RET

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine8:
   \   000000 CD ....      CALL      L:?Subroutine17
   \                     ??CrossCallReturnLabel_51:
   \   000003 CD ....      CALL      L:RTC_EnterInitMode
   \   000006 A1 00        CP        A, #0x0
   \   000008 81           RET
    762          
    763          
    764          
    765          /**
    766          * @brief  Fills each RTC_TimeStruct member with its default value
    767          *         (Time = 00h:00min:00sec).
    768          * @param  RTC_TimeStruct: pointer to a @ref RTC_TimeTypeDef structure which will be
    769          *         initialized.
    770          * @retval None
    771          */

   \                                 In section .near_func.text, align 1
    772          void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
    773          {
    774            /* Time = 00h:00min:00sec*/
    775            RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
   \                     RTC_TimeStructInit:
   \   000000 CD ....      CALL      L:?Subroutine4
    776            RTC_TimeStruct->RTC_Hours = 0;
    777            RTC_TimeStruct->RTC_Minutes = 0;
    778            RTC_TimeStruct->RTC_Seconds = 0;
   \                     ??CrossCallReturnLabel_11:
   \   000003 1C 0002      ADDW      X, #0x2
   \   000006 F7           LD        (X), A
    779          }
   \   000007 81           RET

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine4:
   \   000000 9093         LDW       Y, X
   \   000002 72A9 0003    ADDW      Y, #0x3
   \   000006 4F           CLR       A
   \   000007 90F7         LD        (Y), A
   \   000009 F7           LD        (X), A
   \   00000A 9093         LDW       Y, X
   \   00000C 905C         INCW      Y
   \   00000E 90F7         LD        (Y), A
   \   000010 81           RET
    780          
    781                    
    782          /**
    783          * @brief  Gets the RTC current Time.
    784          * @note   To read the Calendar after wake up from low power mode, user software 
    785          *         must first check that the RSF flag is set in RTC_ISR1, using 
    786          *         RTC_WaitForSynchro() function, which means that the Calendar registers
    787          *         have been correctly copied into the shadow registers (RTC_TRx and RTC_DRx).
    788          * @param  RTC_Format: specifies the format of the returned parameters.
    789          *         This parameter can be one of the @ref RTC_Format_TypeDef enumeration.
    790          * @param  RTC_TimeStruct: pointer to a @ref RTC_TimeTypeDef structure that
    791          *         will contain the returned current time configuration.
    792          * @retval None
    793          
    794          */

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine14:
   \   000000 92C6 ..      LD        A, [S:?w2.w]
   \   000003 CD ....      CALL      L:Bcd2ToByte
   \   000006 92C7 ..      LD        [S:?w2.w], A
   \   000009 81           RET

   \                                 In section .near_func.text, align 1
    795          void RTC_GetTime(RTC_Format_TypeDef RTC_Format,
    796                           RTC_TimeTypeDef* RTC_TimeStruct)
    797          {
   \                     RTC_GetTime:
   \   000000 B7 ..        LD        S:?b0, A
   \   000002 9093         LDW       Y, X
    798            uint8_t  tmpreg = 0;
    799          
    800            /* Check the parameters */
    801            assert_param(IS_RTC_FORMAT(RTC_Format));
    802          
    803            /* Fill the structure fields with the read parameters */
    804            /* Get RTC seconds */
    805            RTC_TimeStruct->RTC_Seconds = RTC->TR1;
   \   000004 1C 0002      ADDW      X, #0x2
   \   000007 BF ..        LDW       S:?w2, X
   \   000009 C6 5140      LD        A, L:0x5140
   \   00000C 92C7 ..      LD        [S:?w2.w], A
    806          
    807            /* Get RTC Minutes */
    808            RTC_TimeStruct->RTC_Minutes = RTC->TR2;
   \   00000F 93           LDW       X, Y
   \   000010 5C           INCW      X
   \   000011 BF ..        LDW       S:?w1, X
   \   000013 C6 5141      LD        A, L:0x5141
   \   000016 92C7 ..      LD        [S:?w1.w], A
    809          
    810            /* Get the RTC_TR3 register */
    811            tmpreg = (uint8_t)RTC->TR3;
   \   000019 C6 5142      LD        A, L:0x5142
   \   00001C B7 ..        LD        S:?b1, A
    812          
    813            /* Read DR3 register to unfreeze calender registers */
    814            (void) (RTC->DR3) ;
   \   00001E C6 5146      LD        A, L:0x5146
    815          
    816          
    817            /* Get RTC Hours */
    818            RTC_TimeStruct->RTC_Hours = (uint8_t)(tmpreg & (uint8_t)~(RTC_TR3_PM));
   \   000021 B6 ..        LD        A, S:?b1
   \   000023 A4 BF        AND       A, #0xbf
   \   000025 90F7         LD        (Y), A
    819          
    820            /* Get RTC H12 state */
    821            RTC_TimeStruct->RTC_H12 = (RTC_H12_TypeDef)(tmpreg & RTC_TR3_PM);
   \   000027 B6 ..        LD        A, S:?b1
   \   000029 A4 40        AND       A, #0x40
   \   00002B 93           LDW       X, Y
   \   00002C 1C 0003      ADDW      X, #0x3
   \   00002F F7           LD        (X), A
    822          
    823            /* Check the input parameters format */
    824            if (RTC_Format == RTC_Format_BIN)
   \   000030 3D ..        TNZ       S:?b0
   \   000032 26 0D        JRNE      L:??CrossCallReturnLabel_42
    825            {
    826              /* Convert the structure parameters to Binary format */
    827              RTC_TimeStruct->RTC_Hours = (uint8_t)Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
   \   000034 90F6         LD        A, (Y)
   \   000036 CD ....      CALL      L:Bcd2ToByte
   \   000039 90F7         LD        (Y), A
    828              RTC_TimeStruct->RTC_Minutes = (uint8_t)Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
   \   00003B CD ....      CALL      L:?Subroutine18
    829              RTC_TimeStruct->RTC_Seconds = (uint8_t)Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);
   \                     ??CrossCallReturnLabel_55:
   \   00003E CD ....      CALL      L:?Subroutine14
    830            }
    831          }
   \                     ??CrossCallReturnLabel_42:
   \   000041 81           RET

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine18:
   \   000000 92C6 ..      LD        A, [S:?w1.w]
   \   000003 CD ....      CALL      L:Bcd2ToByte
   \   000006 92C7 ..      LD        [S:?w1.w], A
   \   000009 81           RET
    832          
    833          /**
    834          * @brief  Gets the RTC current Calendar Subseconds value.
    835          * @note   To read the Calendar after wake up from low power mode, user software 
    836          *         must first check that the RSF flag is set in RTC_ISR1, using 
    837          *         RTC_WaitForSynchro() function, which means that the Calendar registers
    838          *         have been correctly copied into the shadow registers (RTC_TRx and RTC_DRx).
    839          * @param  None
    840          * @retval RTC current Calendar Subseconds value.
    841          */

   \                                 In section .near_func.text, align 1
    842          uint16_t RTC_GetSubSecond(void)
    843          {
    844            uint8_t ssrhreg = 0, ssrlreg = 0;
    845            uint16_t ssrreg = 0;
    846          
    847            /* Get subseconds values from the correspondent registers*/
    848            ssrhreg = RTC->SSRH;
   \                     RTC_GetSubSecond:
   \   000000 C6 5157      LD        A, L:0x5157
   \   000003 B7 ..        LD        S:?b0, A
    849            ssrlreg = RTC->SSRL;
   \   000005 C6 5158      LD        A, L:0x5158
   \   000008 B7 ..        LD        S:?b1, A
    850          
    851            /* Read DR3 register to unfreeze calender registers */
    852            (void) (RTC->DR3);
   \   00000A C6 5146      LD        A, L:0x5146
    853          
    854          
    855            ssrreg = (uint16_t)((uint16_t)((uint16_t)ssrhreg << 8) | (uint16_t)(ssrlreg));
    856            return (uint16_t)(ssrreg);
   \   00000D 5F           CLRW      X
   \   00000E 41           EXG       A, XL
   \   00000F B6 ..        LD        A, S:?b0
   \   000011 41           EXG       A, XL
   \   000012 4F           CLR       A
   \   000013 BA ..        OR        A, S:?b1
   \   000015 02           RLWA      X, A
   \   000016 81           RET
    857          }
    858          
    859          /**
    860          * @brief  Set the RTC current date.
    861          * @note   After updating the Calendar, this routine clears the RSF flag and waits
    862          *         until it is set again (using RTC_WaitForSynchro() function) , which means
    863          *         that the Calendar registers have been correctly copied into the RTC_TRx
    864          *         and RTC_DRx shadow registers.   
    865          * @param  RTC_Format: specifies the format of the entered parameters.
    866          *         This parameter can be one of the @ref RTC_Format_TypeDef enumeration.
    867          * @param  RTC_DateStruct:  pointer to a  @ref RTC_TimeTypeDef structure that
    868          *         contains the date configuration information for the RTC.
    869          * @retval An ErrorStatus enumeration value:
    870          *          - SUCCESS: RTC Date register is configured
    871          *          - ERROR: RTC Date register is not configured
    872          */

   \                                 In section .near_func.text, align 1
    873          ErrorStatus RTC_SetDate(RTC_Format_TypeDef RTC_Format,
    874                                  RTC_DateTypeDef* RTC_DateStruct)
    875          {
   \                     RTC_SetDate:
   \   000000 CD ....      CALL      L:?push_l2
   \   000003 CD ....      CALL      L:?push_w6
   \   000006 B7 ..        LD        S:?b13, A
   \   000008 BF ..        LDW       S:?w4, X
    876            ErrorStatus status = ERROR;
   \   00000A 3F ..        CLR       S:?b12
    877          
    878            if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & TEN_VALUE_BCD) == TEN_VALUE_BCD))
   \   00000C 5C           INCW      X
   \   00000D BF ..        LDW       S:?w5, X
   \   00000F 3D ..        TNZ       S:?b13
   \   000011 26 12        JRNE      L:??RTC_SetDate_0
   \   000013 92C6 ..      LD        A, [S:?w5.w]
   \   000016 B7 ..        LD        S:?b0, A
   \   000018 A5 10        BCP       A, #0x10
   \   00001A 27 09        JREQ      L:??RTC_SetDate_0
    879            {
    880              RTC_DateStruct->RTC_Month = (RTC_Month_TypeDef)((RTC_DateStruct->RTC_Month & (uint8_t)~(TEN_VALUE_BCD)) + TEN_VALUE_BIN);
   \   00001C B6 ..        LD        A, S:?b0
   \   00001E A4 EF        AND       A, #0xef
   \   000020 AB 0A        ADD       A, #0xa
   \   000022 92C7 ..      LD        [S:?w5.w], A
    881            }
    882          
    883            /* Check the parameters */
    884            assert_param(IS_RTC_FORMAT(RTC_Format));
    885            if (RTC_Format == RTC_Format_BIN)
    886            {
    887              assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
    888              assert_param(IS_RTC_MONTH_MIN(RTC_DateStruct->RTC_Month));
    889              assert_param(IS_RTC_MONTH_MAX(RTC_DateStruct->RTC_Month));
    890              assert_param(IS_RTC_DATE_MIN(RTC_DateStruct->RTC_Date));
    891              assert_param(IS_RTC_DATE_MAX(RTC_DateStruct->RTC_Date));
    892            }
    893            else
    894            {
    895              assert_param(IS_RTC_YEAR(Bcd2ToByte(RTC_DateStruct->RTC_Year)));
    896              assert_param(IS_RTC_MONTH_MAX(Bcd2ToByte((uint8_t)RTC_DateStruct->RTC_Month)));
    897              assert_param(IS_RTC_MONTH_MIN(Bcd2ToByte((uint8_t)RTC_DateStruct->RTC_Month)));
    898              assert_param(IS_RTC_DATE_MIN(Bcd2ToByte((uint8_t)RTC_DateStruct->RTC_Date)));
    899              assert_param(IS_RTC_DATE_MAX(Bcd2ToByte((uint8_t)RTC_DateStruct->RTC_Date)));
    900            }
    901            assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
    902          
    903            /* Disable the write protection for RTC registers */
    904            RTC->WPR = 0xCA;
   \                     ??RTC_SetDate_0:
   \   000025 CD ....      CALL      L:?Subroutine8
    905            RTC->WPR = 0x53;
    906          
    907            /* Set Initialization mode */
    908            if (RTC_EnterInitMode() == ERROR)
   \                     ??CrossCallReturnLabel_22:
   \   000028 26 05        JRNE      L:??RTC_SetDate_1
    909            {
    910              status = ERROR;
    911              /* Enable the write protection for RTC registers */
    912              RTC->WPR = 0xFF; 
   \   00002A CD ....      CALL      L:??Subroutine19_0
    913            }
   \                     ??CrossCallReturnLabel_68:
   \   00002D 20 52        JRA       L:??RTC_SetDate_2
    914            else
    915            {
    916              (void)(RTC->TR1);
   \                     ??RTC_SetDate_1:
   \   00002F C6 5140      LD        A, L:0x5140
    917              /* Set the RTC_DR registers */
    918              /* Check the input parameters format */
    919              if (RTC_Format != RTC_Format_BIN)
   \   000032 CD ....      CALL      L:?Subroutine16
   \                     ??CrossCallReturnLabel_45:
   \   000035 1C 0003      ADDW      X, #0x3
   \   000038 3D ..        TNZ       S:?b13
   \   00003A 27 12        JREQ      L:??RTC_SetDate_3
    920              {
    921                RTC->DR1 = (uint8_t)(RTC_DateStruct->RTC_Date);
   \   00003C C7 5144      LD        L:0x5144, A
    922                RTC->DR2 = (uint8_t)((RTC_DateStruct->RTC_Month) | (uint8_t)((RTC_DateStruct->RTC_WeekDay) << 5));
   \   00003F 92C6 ..      LD        A, [S:?w4.w]
   \   000042 CD ....      CALL      L:?sll8_a_a_5
   \   000045 92CA ..      OR        A, [S:?w5.w]
   \   000048 C7 5145      LD        L:0x5145, A
    923                RTC->DR3 = (uint8_t)((RTC_DateStruct->RTC_Year));
   \   00004B F6           LD        A, (X)
   \   00004C 20 1D        JRA       L:??RTC_SetDate_4
    924              }
    925              else
    926              {
    927                RTC->DR1 = (uint8_t)(ByteToBcd2 ((uint8_t)RTC_DateStruct->RTC_Date));
   \                     ??RTC_SetDate_3:
   \   00004E CD ....      CALL      L:ByteToBcd2
   \   000051 C7 5144      LD        L:0x5144, A
    928                RTC->DR2 = (uint8_t)((ByteToBcd2((uint8_t)RTC_DateStruct->RTC_Month)) | (uint8_t)((RTC_DateStruct->RTC_WeekDay) << 5));
   \   000054 92C6 ..      LD        A, [S:?w5.w]
   \   000057 CD ....      CALL      L:ByteToBcd2
   \   00005A B7 ..        LD        S:?b0, A
   \   00005C 92C6 ..      LD        A, [S:?w4.w]
   \   00005F CD ....      CALL      L:?sll8_a_a_5
   \   000062 BA ..        OR        A, S:?b0
   \   000064 C7 5145      LD        L:0x5145, A
    929                RTC->DR3 = (uint8_t)(ByteToBcd2((uint8_t)RTC_DateStruct->RTC_Year));
   \   000067 F6           LD        A, (X)
   \   000068 CD ....      CALL      L:ByteToBcd2
   \                     ??RTC_SetDate_4:
   \   00006B C7 5146      LD        L:0x5146, A
    930              }
    931          
    932              /* Exit Initialization mode */
    933              RTC->ISR1 &= (uint8_t)~RTC_ISR1_INIT;
   \   00006E CD ....      CALL      L:?Subroutine12
    934          
    935              /* Enable the write protection for RTC registers */
    936              RTC->WPR = 0xFF; 
    937          
    938              /* if  RTC_CR1_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    939              if ((RTC->CR1 & RTC_CR1_BYPSHAD) == RESET)
   \                     ??CrossCallReturnLabel_56:
   \   000071 7208 5148 07 BTJT      L:0x5148, #0x4, L:??RTC_SetDate_5
    940              {
    941                if (RTC_WaitForSynchro() == ERROR)
   \   000076 CD ....      CALL      L:RTC_WaitForSynchro
   \   000079 A1 00        CP        A, #0x0
   \   00007B 27 04        JREQ      L:??RTC_SetDate_2
    942                {
    943                  status = ERROR;
    944                }
    945                else
    946                {
    947                  status = SUCCESS;
    948                }
    949              }
    950              else
    951              {
    952                status = SUCCESS;
   \                     ??RTC_SetDate_5:
   \   00007D 35 01 ....   MOV       S:?b12, #0x1
    953              }
    954            }
    955          
    956            return (ErrorStatus)status;
   \                     ??RTC_SetDate_2:
   \   000081 B6 ..        LD        A, S:?b12
   \   000083 CC ....      JP        L:?epilogue_l2_w6
    957          }
    958          /**
    959          * @brief  Fills each RTC_DateStruct member with its default value
    960          *         (Monday 01 January xx00).
    961          * @param  RTC_DateStruct: pointer to a @ref RTC_DateTypeDef structure which will be
    962          *         initialized.
    963          * @retval None
    964          */

   \                                 In section .near_func.text, align 1
    965          void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
    966          {
    967            /* * (Monday 01 January xx00)*/
    968            RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
   \                     RTC_DateStructInit:
   \   000000 A6 01        LD        A, #0x1
   \   000002 F7           LD        (X), A
    969            RTC_DateStruct->RTC_Date = 1;
   \   000003 CD ....      CALL      L:?Subroutine6
    970            RTC_DateStruct->RTC_Month = RTC_Month_January;
   \                     ??CrossCallReturnLabel_15:
   \   000006 905C         INCW      Y
   \   000008 90F7         LD        (Y), A
    971            RTC_DateStruct->RTC_Year = 0;
   \   00000A 1C 0003      ADDW      X, #0x3
   \   00000D 4F           CLR       A
   \   00000E F7           LD        (X), A
    972          }
   \   00000F 81           RET

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine6:
   \   000000 9093         LDW       Y, X
   \   000002 72A9 0002    ADDW      Y, #0x2
   \   000006 90F7         LD        (Y), A
   \   000008 9093         LDW       Y, X
   \   00000A 81           RET
    973          /**
    974          * @brief  Get the RTC current date.
    975          * @note   To read the Calendar after wake up from low power mode, user software 
    976          *         must first check that the RSF flag is set in RTC_ISR1, using 
    977          *         RTC_WaitForSynchro() function, which means that the Calendar registers
    978          *         have been correctly copied into the shadow registers (RTC_TRx and RTC_DRx).
    979          * @param  RTC_Format: specifies the format of the returned parameters.
    980          *         This parameter can be one of the @ref RTC_Format_TypeDef enumeration.
    981          * @param  RTC_DateStruct: pointer to a @ref RTC_DateTypeDef structure that
    982          *         will contain the returned current Date configuration.
    983          * @retval None
    984          */

   \                                 In section .near_func.text, align 1
    985          void RTC_GetDate(RTC_Format_TypeDef RTC_Format,
    986                           RTC_DateTypeDef* RTC_DateStruct)
    987          {
   \                     RTC_GetDate:
   \   000000 B7 ..        LD        S:?b6, A
   \   000002 BF ..        LDW       S:?w0, X
    988            uint8_t tmpreg = 0;
    989          
    990            /* Check the parameters */
    991            assert_param(IS_RTC_FORMAT(RTC_Format));
    992          
    993            /* Fill the structure fields with the read parameters */
    994            (void) (RTC->TR1) ;
   \   000004 C6 5140      LD        A, L:0x5140
    995            RTC_DateStruct->RTC_Date = (uint8_t)(RTC->DR1);
   \   000007 1C 0002      ADDW      X, #0x2
   \   00000A 9093         LDW       Y, X
   \   00000C C6 5144      LD        A, L:0x5144
   \   00000F 90F7         LD        (Y), A
    996            tmpreg = (uint8_t)RTC->DR2;
   \   000011 C6 5145      LD        A, L:0x5145
   \   000014 B7 ..        LD        S:?b7, A
    997            RTC_DateStruct->RTC_Year = (uint8_t)(RTC->DR3);
   \   000016 BE ..        LDW       X, S:?w0
   \   000018 1C 0003      ADDW      X, #0x3
   \   00001B BF ..        LDW       S:?w2, X
   \   00001D C6 5146      LD        A, L:0x5146
   \   000020 92C7 ..      LD        [S:?w2.w], A
    998          
    999          
   1000            RTC_DateStruct->RTC_Month = (RTC_Month_TypeDef)(tmpreg & (uint8_t)(RTC_DR2_MT | RTC_DR2_MU));
   \   000023 BE ..        LDW       X, S:?w0
   \   000025 5C           INCW      X
   \   000026 BF ..        LDW       S:?w1, X
   \   000028 B6 ..        LD        A, S:?b7
   \   00002A A4 1F        AND       A, #0x1f
   \   00002C 92C7 ..      LD        [S:?w1.w], A
   1001            RTC_DateStruct->RTC_WeekDay = (RTC_Weekday_TypeDef)((uint8_t)((uint8_t)tmpreg & (uint8_t)(RTC_DR2_WDU)) >> (uint8_t)5);
   \   00002F B6 ..        LD        A, S:?b7
   \   000031 CD ....      CALL      L:?srl8_a_a_5
   \   000034 92C7 ..      LD        [S:?w0.w], A
   1002          
   1003            /* Check the input parameters format */
   1004            if (RTC_Format == RTC_Format_BIN)
   \   000037 3D ..        TNZ       S:?b6
   \   000039 26 06        JRNE      L:??CrossCallReturnLabel_39
   1005            {
   1006              /* Convert the structure parameters to Binary format */
   1007              RTC_DateStruct->RTC_Year = (uint8_t)Bcd2ToByte((uint8_t)RTC_DateStruct->RTC_Year);
   \   00003B CD ....      CALL      L:?Subroutine14
   1008              RTC_DateStruct->RTC_Month = (RTC_Month_TypeDef)Bcd2ToByte((uint8_t)RTC_DateStruct->RTC_Month);
   \                     ??CrossCallReturnLabel_41:
   \   00003E CD ....      CALL      L:?Subroutine13
   1009              RTC_DateStruct->RTC_Date = (uint8_t)(Bcd2ToByte((uint8_t)RTC_DateStruct->RTC_Date));
   1010            }
   1011          }
   \                     ??CrossCallReturnLabel_39:
   \   000041 81           RET

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine13:
   \   000000 CD ....      CALL      L:?Subroutine18
   \                     ??CrossCallReturnLabel_54:
   \   000003 90F6         LD        A, (Y)
   \   000005 CD ....      CALL      L:Bcd2ToByte
   \   000008 90F7         LD        (Y), A
   \   00000A 81           RET
   1012          
   1013          /**
   1014            * @}
   1015            */
   1016          
   1017          /** @defgroup RTC_Group3 Alarms configuration functions
   1018           *  @brief   Alarms (Alarm A and Alarm B) configuration functions 
   1019           *
   1020          @verbatim   
   1021           ===============================================================================
   1022                        Alarms (Alarm A and Alarm B) configuration functions
   1023           ===============================================================================  
   1024          
   1025            This section provide functions allowing to program and read the RTC Alarms.
   1026          
   1027          @endverbatim
   1028            * @{
   1029            */
   1030            
   1031          /**
   1032            * @brief  Sets the RTC Alarm configuration.
   1033            * @note   Before configuring the Alarm settings, the Alarm Unit must be disabled
   1034            *         (if enabled) using RTC_AlarmCmd(DISABLE) function.
   1035            * @param  RTC_Format: specifies the format of the entered parameters.
   1036            *         This parameter can be one of the @ref RTC_Format_TypeDef enumeration.
   1037            * @param  RTC_AlarmStruct:  pointer to a  @ref RTC_AlarmTypeDef structure that
   1038            *         contains the Alarm configuration information for the RTC.
   1039            * @retval None.
   1040            */

   \                                 In section .near_func.text, align 1
   1041          void RTC_SetAlarm(RTC_Format_TypeDef RTC_Format,
   1042                            RTC_AlarmTypeDef* RTC_AlarmStruct)
   1043          {
   \                     RTC_SetAlarm:
   \   000000 CD ....      CALL      L:?push_w4
   \   000003 3B ....      PUSH      S:?b10
   \   000006 B7 ..        LD        S:?b0, A
   \   000008 BF ..        LDW       S:?w2, X
   1044            uint8_t tmpreg1 = 0;
   1045            uint8_t tmpreg2 = 0;
   1046            uint8_t tmpreg3 = 0;
   1047            uint8_t tmpreg4 = 0;
   1048          
   1049            /* Check the parameters */
   1050            assert_param(IS_RTC_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
   1051            assert_param(IS_RTC_FORMAT(RTC_Format));
   1052            assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
   1053            assert_param(IS_RTC_ALARM_DATEWEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
   1054          
   1055          
   1056            if (RTC_Format == RTC_Format_BIN)
   1057            {
   1058              /* Check Hour Format (24h or 12h)*/
   1059              if ((RTC->CR1 & RTC_CR1_FMT) != RESET)
   1060              {
   1061                assert_param(IS_RTC_HOUR12_MAX(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
   1062                assert_param(IS_RTC_HOUR12_MIN(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
   1063              }
   1064              else
   1065              {
   1066                assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
   1067              }
   1068              assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
   1069              assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
   1070            }
   1071            else
   1072            {
   1073              /* Check Hour Format (24h or 12h)*/
   1074              if ((RTC->CR1 & RTC_CR1_FMT) != RESET)
   \   00000A C6 5148      LD        A, L:0x5148
   1075              {
   1076                assert_param(IS_RTC_HOUR12_MAX(Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
   1077                assert_param(IS_RTC_HOUR12_MIN(Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
   1078              }
   1079              else
   1080              {
   1081                assert_param(IS_RTC_HOUR24(Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
   1082              }
   1083          
   1084              assert_param(IS_RTC_MINUTES(Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
   1085          
   1086              assert_param(IS_RTC_SECONDS(Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
   1087          
   1088            }
   1089          
   1090            /* if Date/Weekday field is not masked */
   1091            if ((RTC_AlarmStruct->RTC_AlarmMask & RTC_AlarmMask_DateWeekDay) == RESET )
   1092            {
   1093              if (RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_WeekDay)
   1094              {
   1095                assert_param(IS_RTC_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
   1096              }
   1097              else
   1098              {
   1099                assert_param(IS_RTC_DATE_MIN(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
   1100                assert_param(IS_RTC_DATE_MAX(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
   1101              }
   1102            }
   1103          
   1104            /* Disable the write protection for RTC registers */
   1105            RTC->WPR = 0xCA;
   \   00000D CD ....      CALL      L:?Subroutine10
   1106            RTC->WPR = 0x53;
   1107          
   1108          
   1109            /* Check the input parameters format & Configure the Alarm register */
   1110            if (RTC_Format != RTC_Format_BIN)
   \                     ??CrossCallReturnLabel_32:
   \   000010 1C 0002      ADDW      X, #0x2
   \   000013 F6           LD        A, (X)
   \   000014 B7 ..        LD        S:?b1, A
   \   000016 BE ..        LDW       X, S:?w2
   \   000018 1C 0005      ADDW      X, #0x5
   \   00001B 9093         LDW       Y, X
   \   00001D BE ..        LDW       X, S:?w2
   \   00001F 1C 0006      ADDW      X, #0x6
   \   000022 BF ..        LDW       S:?w3, X
   \   000024 BE ..        LDW       X, S:?w2
   \   000026 1C 0003      ADDW      X, #0x3
   \   000029 BF ..        LDW       S:?w1, X
   \   00002B BE ..        LDW       X, S:?w2
   \   00002D 5C           INCW      X
   \   00002E BF ..        LDW       S:?w4, X
   \   000030 BE ..        LDW       X, S:?w2
   \   000032 1C 0004      ADDW      X, #0x4
   \   000035 3D ..        TNZ       S:?b0
   \   000037 27 35        JREQ      L:??RTC_SetAlarm_0
   1111            {
   1112              tmpreg1 = (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
   1113                                  (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmMask) & (uint8_t)RTC_ALRMAR1_MSK1));
   \   000039 F6           LD        A, (X)
   \   00003A B7 ..        LD        S:?b0, A
   \   00003C A4 80        AND       A, #0x80
   \   00003E BA ..        OR        A, S:?b1
   \   000040 B7 ..        LD        S:?b10, A
   1114          
   1115              tmpreg2 = (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) | \
   1116                                  (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmMask << 1) & (uint8_t)RTC_ALRMAR2_MSK2));
   \   000042 B6 ..        LD        A, S:?b0
   \   000044 48           SLL       A
   \   000045 A4 80        AND       A, #0x80
   \   000047 92CA ..      OR        A, [S:?w4.w]
   \   00004A B7 ..        LD        S:?b8, A
   1117          
   1118              tmpreg3 = (uint8_t)((uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) | \
   1119                                            (uint8_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12)) | \
   1120                                  (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmMask << 2) & (uint8_t)RTC_ALRMAR3_MSK3));
   \   00004C 92C6 ..      LD        A, [S:?w1.w]
   \   00004F 92CA ..      OR        A, [S:?w2.w]
   \   000052 B7 ..        LD        S:?b1, A
   \   000054 B6 ..        LD        A, S:?b0
   \   000056 48           SLL       A
   \   000057 48           SLL       A
   \   000058 A4 80        AND       A, #0x80
   \   00005A BA ..        OR        A, S:?b1
   \   00005C B7 ..        LD        S:?b2, A
   1121          
   1122              tmpreg4 = (uint8_t)((uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) | \
   1123                                            (uint8_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel)) | \
   1124                                  (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmMask << 3) & (uint8_t)RTC_ALRMAR4_MSK4));
   \   00005E 90F6         LD        A, (Y)
   \   000060 92CA ..      OR        A, [S:?w3.w]
   \   000063 B7 ..        LD        S:?b1, A
   \   000065 B6 ..        LD        A, S:?b0
   \   000067 48           SLL       A
   \   000068 48           SLL       A
   \   000069 48           SLL       A
   \   00006A A4 80        AND       A, #0x80
   \   00006C 20 42        JRA       L:??RTC_SetAlarm_1
   1125          
   1126            }
   1127            else
   1128            {
   1129              tmpreg1 = (uint8_t)((ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
   1130                                  (uint8_t)(RTC_AlarmStruct->RTC_AlarmMask & RTC_ALRMAR1_MSK1));
   \                     ??RTC_SetAlarm_0:
   \   00006E CD ....      CALL      L:ByteToBcd2
   \   000071 B7 ..        LD        S:?b0, A
   \   000073 F6           LD        A, (X)
   \   000074 A4 80        AND       A, #0x80
   \   000076 BA ..        OR        A, S:?b0
   \   000078 B7 ..        LD        S:?b10, A
   1131          
   1132              tmpreg2 = (uint8_t)((ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)) | \
   1133                                  (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmMask << 1) & (uint8_t)RTC_ALRMAR2_MSK2));
   \   00007A 92C6 ..      LD        A, [S:?w4.w]
   \   00007D CD ....      CALL      L:ByteToBcd2
   \   000080 B7 ..        LD        S:?b0, A
   \   000082 F6           LD        A, (X)
   \   000083 48           SLL       A
   \   000084 A4 80        AND       A, #0x80
   \   000086 BA ..        OR        A, S:?b0
   \   000088 B7 ..        LD        S:?b8, A
   1134          
   1135              tmpreg3 = (uint8_t)((uint8_t)((ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)) | \
   1136                                            (uint8_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12)) | \
   1137                                  (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmMask << 2) & (uint8_t)RTC_ALRMAR3_MSK3));
   \   00008A 92C6 ..      LD        A, [S:?w2.w]
   \   00008D CD ....      CALL      L:?Subroutine15
   \                     ??CrossCallReturnLabel_43:
   \   000090 A4 80        AND       A, #0x80
   \   000092 88           PUSH      A
   \   000093 92C6 ..      LD        A, [S:?w1.w]
   \   000096 BA ..        OR        A, S:?b1
   \   000098 B7 ..        LD        S:?b1, A
   \   00009A 84           POP       A
   \   00009B BA ..        OR        A, S:?b1
   \   00009D B7 ..        LD        S:?b2, A
   1138          
   1139              tmpreg4 = (uint8_t)((uint8_t)((ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay)) | \
   1140                                            (uint8_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel)) | \
   1141                                  (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmMask << 3) & (uint8_t)(RTC_ALRMAR4_MSK4)));
   \   00009F 92C6 ..      LD        A, [S:?w3.w]
   \   0000A2 CD ....      CALL      L:?Subroutine15
   1142            }
   \                     ??CrossCallReturnLabel_44:
   \   0000A5 48           SLL       A
   \   0000A6 A4 80        AND       A, #0x80
   \   0000A8 88           PUSH      A
   \   0000A9 90F6         LD        A, (Y)
   \   0000AB BA ..        OR        A, S:?b1
   \   0000AD B7 ..        LD        S:?b1, A
   \   0000AF 84           POP       A
   \                     ??RTC_SetAlarm_1:
   \   0000B0 BA ..        OR        A, S:?b1
   \   0000B2 B7 ..        LD        S:?b0, A
   1143          
   1144            /* Configure the Alarm register */
   1145            RTC->ALRMAR1 = tmpreg1;
   \   0000B4 B6 ..        LD        A, S:?b10
   \   0000B6 C7 515C      LD        L:0x515c, A
   1146            RTC->ALRMAR2 = tmpreg2;
   \   0000B9 B6 ..        LD        A, S:?b8
   \   0000BB C7 515D      LD        L:0x515d, A
   1147            RTC->ALRMAR3 = tmpreg3;
   \   0000BE B6 ..        LD        A, S:?b2
   \   0000C0 C7 515E      LD        L:0x515e, A
   1148            RTC->ALRMAR4 = tmpreg4;
   \   0000C3 B6 ..        LD        A, S:?b0
   \   0000C5 C7 515F      LD        L:0x515f, A
   1149          
   1150            /* Enable the write protection for RTC registers */
   1151            RTC->WPR = 0xFF; 
   \   0000C8 CD ....      CALL      L:??Subroutine19_0
   1152          }
   \                     ??CrossCallReturnLabel_67:
   \   0000CB 32 ....      POP       S:?b10
   \   0000CE CC ....      JP        L:?epilogue_w4

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine15:
   \   000000 CD ....      CALL      L:ByteToBcd2
   \   000003 B7 ..        LD        S:?b1, A
   \   000005 F6           LD        A, (X)
   \   000006 48           SLL       A
   \   000007 48           SLL       A
   \   000008 81           RET
   1153          
   1154          /**
   1155          * @brief  Fills each RTC_AlarmStruct member with its default value
   1156          *         (Time = 00h:00mn:00sec / Date = 1st day of the month/Mask =
   1157          *         all fields are masked).
   1158          * @param  RTC_AlarmStruct: pointer to a @ref RTC_AlarmTypeDef structure which
   1159          *         will be initialized.
   1160          * @retval None
   1161          */

   \                                 In section .near_func.text, align 1
   1162          void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
   1163          {
   1164            /* Alarm Time Settings : Time = 00h:00mn:00sec */
   1165            RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
   \                     RTC_AlarmStructInit:
   \   000000 CD ....      CALL      L:?Subroutine4
   1166            RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
   1167            RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
   1168            RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
   \                     ??CrossCallReturnLabel_10:
   \   000003 CD ....      CALL      L:?Subroutine6
   1169          
   1170            /* Alarm Date Settings : Date = 1st day of the month*/
   1171            RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
   \                     ??CrossCallReturnLabel_14:
   \   000006 72A9 0005    ADDW      Y, #0x5
   \   00000A 90F7         LD        (Y), A
   1172            RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
   \   00000C 9093         LDW       Y, X
   \   00000E 72A9 0006    ADDW      Y, #0x6
   \   000012 A6 01        LD        A, #0x1
   \   000014 90F7         LD        (Y), A
   1173          
   1174            /* Alarm Masks Settings : Mask =  all fields are masked*/
   1175            RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_All;
   \   000016 1C 0004      ADDW      X, #0x4
   \   000019 A6 F0        LD        A, #0xf0
   \   00001B F7           LD        (X), A
   1176          }
   \   00001C 81           RET
   1177          /**
   1178            * @brief  Gets the RTC Alarm configuration.
   1179            * @param  RTC_Format: specifies the format of the entered parameters.
   1180            *         This parameter can be one of the @ref RTC_Format_TypeDef enumeration.
   1181            * @param  RTC_AlarmStruct:  pointer to a  @ref RTC_AlarmTypeDef structure that
   1182            *         will contain the Alarm configuration information of  the RTC.
   1183            * @retval None
   1184            */

   \                                 In section .near_func.text, align 1
   1185          void RTC_GetAlarm(RTC_Format_TypeDef RTC_Format,
   1186                            RTC_AlarmTypeDef* RTC_AlarmStruct)
   1187          {
   \                     RTC_GetAlarm:
   \   000000 CD ....      CALL      L:?push_w4
   \   000003 3B ....      PUSH      S:?b10
   \   000006 B7 ..        LD        S:?b0, A
   \   000008 BF ..        LDW       S:?w1, X
   1188            uint8_t tmpreg1 = 0;
   1189            uint8_t tmpreg2 = 0;
   1190            uint8_t tmpreg3 = 0;
   1191            uint8_t tmpreg4 = 0;
   1192            uint8_t alarmmask = 0;
   1193          
   1194            /* Check the parameters */
   1195            assert_param(IS_RTC_FORMAT(RTC_Format));
   1196          
   1197            /* Get Alarm registers data */
   1198            tmpreg1 = (uint8_t)RTC->ALRMAR1;
   \   00000A C6 515C      LD        A, L:0x515c
   \   00000D B7 ..        LD        S:?b8, A
   1199            tmpreg2 = (uint8_t)RTC->ALRMAR2;
   \   00000F C6 515D      LD        A, L:0x515d
   \   000012 B7 ..        LD        S:?b9, A
   1200            tmpreg3 = (uint8_t)RTC->ALRMAR3;
   \   000014 C6 515E      LD        A, L:0x515e
   \   000017 B7 ..        LD        S:?b10, A
   1201            tmpreg4 = (uint8_t)RTC->ALRMAR4;
   \   000019 C6 515F      LD        A, L:0x515f
   \   00001C B7 ..        LD        S:?b1, A
   1202          
   1203            /* Fill the structure with the read parameters */
   1204            RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint8_t)((uint8_t)tmpreg1 & (uint8_t)((uint8_t)RTC_ALRMAR1_ST | (uint8_t)RTC_ALRMAR1_SU));
   \   00001E 1C 0002      ADDW      X, #0x2
   \   000021 BF ..        LDW       S:?w2, X
   \   000023 B6 ..        LD        A, S:?b8
   \   000025 A4 7F        AND       A, #0x7f
   \   000027 92C7 ..      LD        [S:?w2.w], A
   1205            alarmmask = (uint8_t)(tmpreg1 & RTC_ALRMAR1_MSK1);
   1206          
   1207            /* Fill the structure with the read parameters */
   1208            RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint8_t)((uint8_t)tmpreg2 & (uint8_t)((uint8_t)RTC_ALRMAR2_MNT | (uint8_t)RTC_ALRMAR2_MNU));
   \   00002A BE ..        LDW       X, S:?w1
   \   00002C 5C           INCW      X
   \   00002D 9093         LDW       Y, X
   \   00002F B6 ..        LD        A, S:?b9
   \   000031 A4 7F        AND       A, #0x7f
   \   000033 90F7         LD        (Y), A
   1209            alarmmask = (uint8_t)((alarmmask) | (uint8_t)((uint8_t)(tmpreg2 & RTC_ALRMAR2_MSK2) >> 1));
   1210          
   1211            /* Fill the structure with the read parameters */
   1212            RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint8_t)((uint8_t)tmpreg3 & (uint8_t)((uint8_t)RTC_ALRMAR3_HT | (uint8_t)RTC_ALRMAR3_HU));
   \   000035 B6 ..        LD        A, S:?b10
   \   000037 A4 3F        AND       A, #0x3f
   \   000039 92C7 ..      LD        [S:?w1.w], A
   1213            RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (RTC_H12_TypeDef)((uint8_t)tmpreg3 & (uint8_t)RTC_ALRMAR3_PM);
   \   00003C B6 ..        LD        A, S:?b10
   \   00003E A4 40        AND       A, #0x40
   \   000040 BE ..        LDW       X, S:?w1
   \   000042 1C 0003      ADDW      X, #0x3
   \   000045 F7           LD        (X), A
   1214            alarmmask = (uint8_t)((alarmmask) | (uint8_t)((uint8_t)((uint8_t)tmpreg3 & (uint8_t)RTC_ALRMAR3_MSK3) >> 2));
   1215          
   1216            /* Fill the structure with the read parameters */
   1217            RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint8_t)((uint8_t)tmpreg4 & (uint8_t)((uint8_t)RTC_ALRMAR4_DT | (uint8_t)RTC_ALRMAR4_DU));
   \   000046 BE ..        LDW       X, S:?w1
   \   000048 1C 0006      ADDW      X, #0x6
   \   00004B BF ..        LDW       S:?w3, X
   \   00004D B6 ..        LD        A, S:?b1
   \   00004F A4 3F        AND       A, #0x3f
   \   000051 92C7 ..      LD        [S:?w3.w], A
   1218            RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (RTC_AlarmDateWeekDaySel_TypeDef)((uint8_t)tmpreg4 & (uint8_t)RTC_ALRMAR4_WDSEL);
   \   000054 B6 ..        LD        A, S:?b1
   \   000056 A4 40        AND       A, #0x40
   \   000058 BE ..        LDW       X, S:?w1
   \   00005A 1C 0005      ADDW      X, #0x5
   \   00005D F7           LD        (X), A
   1219            alarmmask = (uint8_t)((alarmmask) | (uint8_t)((uint8_t)((uint8_t)tmpreg4 & RTC_ALRMAR4_MSK4) >> 3));
   1220          
   1221            RTC_AlarmStruct->RTC_AlarmMask = alarmmask;
   \   00005E B6 ..        LD        A, S:?b9
   \   000060 44           SRL       A
   \   000061 A4 40        AND       A, #0x40
   \   000063 88           PUSH      A
   \   000064 B6 ..        LD        A, S:?b8
   \   000066 A4 80        AND       A, #0x80
   \   000068 B7 ..        LD        S:?b8, A
   \   00006A 84           POP       A
   \   00006B BA ..        OR        A, S:?b8
   \   00006D B7 ..        LD        S:?b8, A
   \   00006F B6 ..        LD        A, S:?b10
   \   000071 44           SRL       A
   \   000072 44           SRL       A
   \   000073 A4 20        AND       A, #0x20
   \   000075 BA ..        OR        A, S:?b8
   \   000077 B7 ..        LD        S:?b8, A
   \   000079 B6 ..        LD        A, S:?b1
   \   00007B 44           SRL       A
   \   00007C 44           SRL       A
   \   00007D 44           SRL       A
   \   00007E A4 10        AND       A, #0x10
   \   000080 BA ..        OR        A, S:?b8
   \   000082 BE ..        LDW       X, S:?w1
   \   000084 1C 0004      ADDW      X, #0x4
   \   000087 F7           LD        (X), A
   1222          
   1223            if (RTC_Format == RTC_Format_BIN)
   \   000088 3D ..        TNZ       S:?b0
   \   00008A 26 0F        JRNE      L:??RTC_GetAlarm_0
   1224            {
   1225              RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
   \   00008C CD ....      CALL      L:?Subroutine13
   1226              RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes);
   1227              RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds);
   \                     ??CrossCallReturnLabel_38:
   \   00008F CD ....      CALL      L:?Subroutine14
   1228              RTC_AlarmStruct->RTC_AlarmDateWeekDay = Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
   \                     ??CrossCallReturnLabel_40:
   \   000092 92C6 ..      LD        A, [S:?w3.w]
   \   000095 CD ....      CALL      L:Bcd2ToByte
   \   000098 92C7 ..      LD        [S:?w3.w], A
   1229            }
   1230          }
   \                     ??RTC_GetAlarm_0:
   \   00009B 32 ....      POP       S:?b10
   \   00009E CC ....      JP        L:?epilogue_w4
   1231          
   1232          /**
   1233            * @brief  Enables or disables the RTC Alarm.
   1234            * @param  NewState: new state of the alarm. This parameter can be: ENABLE or DISABLE.
   1235            * @retval An ErrorStatus enumeration value:
   1236            *          - SUCCESS: RTC Alarm is enabled/disabled
   1237            *          - ERROR: RTC Alarm is not enabled/disabled
   1238            */

   \                                 In section .near_func.text, align 1
   1239          ErrorStatus RTC_AlarmCmd(FunctionalState NewState)
   1240          {
   \                     RTC_AlarmCmd:
   \   000000 52 02        SUB       SP, #0x2
   1241            __IO uint16_t alrawfcount = 0;
   \   000002 5F           CLRW      X
   \   000003 1F 01        LDW       (0x1,SP), X
   1242            ErrorStatus status = ERROR;
   1243            uint8_t temp1 = 0;
   1244          
   1245            /* Check the parameters */
   1246            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1247          
   1248            /* Disable the write protection for RTC registers */
   1249            RTC->WPR = 0xCA;
   \   000005 CD ....      CALL      L:?Subroutine7
   1250            RTC->WPR = 0x53;
   1251          
   1252            /* Configure the Alarm state */
   1253            if (NewState != DISABLE)
   \                     ??CrossCallReturnLabel_19:
   \   000008 27 08        JREQ      L:??RTC_AlarmCmd_0
   1254            { /*Enable the Alarm*/
   1255              RTC->CR2 |= (uint8_t)(RTC_CR2_ALRAE);
   \   00000A 7210 5149    BSET      L:0x5149, #0x0
   1256              status = SUCCESS;
   \   00000E A6 01        LD        A, #0x1
   \   000010 20 1F        JRA       L:??RTC_AlarmCmd_1
   1257            }
   1258            else
   1259            {  /* Disable the Alarm */
   1260              RTC->CR2 &= (uint8_t)~(RTC_CR2_ALRAE) ;
   \                     ??RTC_AlarmCmd_0:
   \   000012 7211 5149    BRES      L:0x5149, #0x0
   1261          
   1262              /* Wait until ALRxWF flag is set */
   1263              temp1 = (uint8_t)(RTC->ISR1 & RTC_ISR1_ALRAWF);
   \   000016 C6 514C      LD        A, L:0x514c
   \   000019 A4 01        AND       A, #0x1
   \   00001B 20 05        JRA       L:??RTC_AlarmCmd_2
   1264              while ((alrawfcount != ALRAWF_TIMEOUT) && (temp1 == RESET))
   1265              {
   1266                alrawfcount++;
   \                     ??RTC_AlarmCmd_3:
   \   00001D 1E 01        LDW       X, (0x1,SP)
   \   00001F 5C           INCW      X
   \   000020 1F 01        LDW       (0x1,SP), X
   1267              }
   \                     ??RTC_AlarmCmd_2:
   \   000022 1E 01        LDW       X, (0x1,SP)
   \   000024 A3 FFFF      CPW       X, #0xffff
   \   000027 27 03        JREQ      L:??RTC_AlarmCmd_4
   \   000029 4D           TNZ       A
   \   00002A 27 F1        JREQ      L:??RTC_AlarmCmd_3
   1268          
   1269              if ((RTC->ISR1 &  RTC_ISR1_ALRAWF) == RESET)
   \                     ??RTC_AlarmCmd_4:
   \   00002C C6 514C      LD        A, L:0x514c
   1270              {
   1271                status = ERROR;
   \   00002F A4 01        AND       A, #0x1
   1272              }
   1273              else
   1274              {
   1275                status = SUCCESS;
   1276              }
   1277            }
   1278          
   1279            /* Enable the write protection for RTC registers */
   1280            RTC->WPR = 0xFF; 
   \                     ??RTC_AlarmCmd_1:
   \   000031 CD ....      CALL      L:??Subroutine19_0
   1281          
   1282            /* Return the status*/
   1283            return (ErrorStatus)status;
   \                     ??CrossCallReturnLabel_66:
   \   000034 5B 02        ADD       SP, #0x2
   \   000036 81           RET
   1284          }
   1285          /**
   1286          * @brief  Configure the RTC Alarm Subseconds value and mask.
   1287          * @param  RTC_AlarmSubSecondValue: specifies the Subseconds value.
   1288          *         This parameter can be a value from 0 to 0x7FFF.
   1289          * @param  RTC_AlarmSubSecondMask:  specifies the Subseconds Mask.
   1290          *         This parameter can be one of the @ref RTC_AlarmSubSecondMask_TypeDef enumeration.
   1291          * @retval An ErrorStatus enumeration value:
   1292          *          - SUCCESS: Alarm Subseconds value and mask are configured
   1293          *          - ERROR: Alarm Subseconds value and mask are  not configured
   1294          */

   \                                 In section .near_func.text, align 1
   1295          ErrorStatus RTC_AlarmSubSecondConfig(uint16_t RTC_AlarmSubSecondValue,
   1296                                               RTC_AlarmSubSecondMask_TypeDef RTC_AlarmSubSecondMask)
   1297          {
   \                     RTC_AlarmSubSecondConfig:
   \   000000 9093         LDW       Y, X
   \   000002 B7 ..        LD        S:?b1, A
   1298            uint8_t alarmstatus = 0;
   1299            ErrorStatus status = ERROR;
   \   000004 4F           CLR       A
   1300          
   1301            /* Check the parameters */
   1302            assert_param(IS_RTC_ALARM_SS_VALUE(RTC_AlarmSubSecondValue));
   1303            assert_param(IS_RTC_ALARM_SS_MASK(RTC_AlarmSubSecondMask));
   1304          
   1305            /* Disable the write protection for RTC registers */
   1306            RTC->WPR = 0xCA;
   \   000005 CD ....      CALL      L:?Subroutine10
   1307            RTC->WPR = 0x53;
   1308          
   1309            /* Check if the initialization mode is not set */
   1310            if ((RTC->ISR1 & RTC_ISR1_INITF) == RESET)
   \                     ??CrossCallReturnLabel_31:
   \   000008 720C 514C 25 BTJT      L:0x514c, #0x6, L:??RTC_AlarmSubSecondConfig_0
   1311            {
   1312              /* save  Alarm status */
   1313              alarmstatus = (uint8_t)(RTC->CR2 | RTC_CR2_ALRAE);
   \   00000D C6 5149      LD        A, L:0x5149
   \   000010 B7 ..        LD        S:?b0, A
   1314          
   1315              /* Disable the Alarm */
   1316              RTC->CR2 &= (uint8_t)~(RTC_CR2_ALRAE);
   \   000012 7211 5149    BRES      L:0x5149, #0x0
   1317          
   1318              /* Configure the Alarm register */
   1319              RTC->ALRMASSRH = (uint8_t)(RTC_AlarmSubSecondValue >> 8);
   \   000016 4F           CLR       A
   \   000017 01           RRWA      X, A
   \   000018 9F           LD        A, XL
   \   000019 C7 5164      LD        L:0x5164, A
   1320              RTC->ALRMASSRL = (uint8_t)(RTC_AlarmSubSecondValue);
   \   00001C 909F         LD        A, YL
   \   00001E C7 5165      LD        L:0x5165, A
   1321              RTC->ALRMASSMSKR = (uint8_t)RTC_AlarmSubSecondMask;
   \   000021 B6 ..        LD        A, S:?b1
   \   000023 C7 5166      LD        L:0x5166, A
   1322          
   1323              /* restore the saved  Alarm status */
   1324              RTC->CR2 |= alarmstatus;
   \   000026 B6 ..        LD        A, S:?b0
   \   000028 AA 01        OR        A, #0x1
   \   00002A CA 5149      OR        A, L:0x5149
   \   00002D C7 5149      LD        L:0x5149, A
   1325          
   1326              status = SUCCESS;
   \   000030 A6 01        LD        A, #0x1
   1327            }
   1328            else
   1329            {
   1330              status = ERROR;
   1331            }
   1332          
   1333            /* Enable the write protection for RTC registers */
   1334            RTC->WPR = 0xFF; 
   \                     ??RTC_AlarmSubSecondConfig_0:
   \   000032 CD ....      CALL      L:??Subroutine19_0
   1335          
   1336            return (ErrorStatus)status;
   \                     ??CrossCallReturnLabel_65:
   \   000035 81           RET
   1337          }
   1338          
   1339          
   1340          
   1341          /**
   1342            * @}
   1343            */
   1344          
   1345          /** @defgroup RTC_Group4 WakeUp Timer configuration functions
   1346           *  @brief   WakeUp Timer configuration functions 
   1347           *
   1348          @verbatim   
   1349           ===============================================================================
   1350                               WakeUp Timer configuration functions
   1351           ===============================================================================  
   1352          
   1353            This section provide functions allowing to program and read the RTC WakeUp.
   1354          
   1355          @endverbatim
   1356            * @{
   1357            */
   1358          /**
   1359            * @brief  Configures the RTC Wakeup clock source.
   1360            * @pre    Before configuring the wakeup unit Clock source, the wake up Unit must
   1361            *         be disabled (if enabled) using RTC_WakeUpCmd(Disable) .
   1362            * @param  RTC_WakeupClockSrc: specifies the Wakeup clock source,
   1363            *         this parameter  can be one of the @ref RTC_WakeupClockSrc_TypeDef enumeration.
   1364            * @retval None
   1365            */

   \                                 In section .near_func.text, align 1
   1366          void RTC_WakeUpClockConfig(RTC_WakeUpClock_TypeDef RTC_WakeUpClock)
   1367          {
   \                     RTC_WakeUpClockConfig:
   \   000000 B7 ..        LD        S:?b0, A
   1368          
   1369            /* Check the parameters */
   1370            assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
   1371          
   1372            /* Disable the write protection for RTC registers */
   1373            RTC->WPR = 0xCA;
   \   000002 CD ....      CALL      L:?Subroutine10
   1374            RTC->WPR = 0x53;
   1375          
   1376            /* Disable the Wakeup timer in RTC_CR2 register */
   1377            RTC->CR2 &= (uint8_t)~RTC_CR2_WUTE;
   \                     ??CrossCallReturnLabel_30:
   \   000005 7215 5149    BRES      L:0x5149, #0x2
   1378          
   1379            /* Clear the Wakeup Timer clock source bits in CR1 register */
   1380            RTC->CR1 &= (uint8_t)~RTC_CR1_WUCKSEL;
   \   000009 C6 5148      LD        A, L:0x5148
   \   00000C A4 F8        AND       A, #0xf8
   \   00000E C7 5148      LD        L:0x5148, A
   1381          
   1382            /* Configure the clock source */
   1383            RTC->CR1 |= (uint8_t)RTC_WakeUpClock;
   \   000011 B6 ..        LD        A, S:?b0
   \   000013 CA 5148      OR        A, L:0x5148
   \   000016 C7 5148      LD        L:0x5148, A
   1384          
   1385            /* Enable the write protection for RTC registers */
   1386            RTC->WPR = 0xFF; 
   \   000019 CD ....      CALL      L:??Subroutine19_0
   1387          }
   \                     ??CrossCallReturnLabel_64:
   \   00001C 81           RET
   1388          
   1389          /**
   1390            * @brief  Sets the RTC Wakeup counter.
   1391            * @note   Before configuring the wakeup unit counter, the wake up Unit must be
   1392            *         disabled (if enabled) using RTC_WakeUpCmd(Disable).
   1393            * @param  RTC_WakeupCounter: specifies the Wake up counter,
   1394            *         This parameter can be a value from 0x0000 to 0xFFFF.
   1395            * @retval None.
   1396            */

   \                                 In section .near_func.text, align 1
   1397          void RTC_SetWakeUpCounter(uint16_t RTC_WakeupCounter)
   1398          {
   \                     RTC_SetWakeUpCounter:
   \   000000 9093         LDW       Y, X
   1399            /* Disable the write protection for RTC registers */
   1400            RTC->WPR = 0xCA;
   \   000002 CD ....      CALL      L:?Subroutine10
   1401            RTC->WPR = 0x53;
   1402          
   1403          
   1404            /* Configure the Wakeup Timer counter */
   1405            RTC->WUTRH = (uint8_t)(RTC_WakeupCounter >> 8);
   \                     ??CrossCallReturnLabel_29:
   \   000005 4F           CLR       A
   \   000006 01           RRWA      X, A
   \   000007 9F           LD        A, XL
   \   000008 C7 5154      LD        L:0x5154, A
   1406            RTC->WUTRL = (uint8_t)(RTC_WakeupCounter);
   \   00000B 909F         LD        A, YL
   \   00000D C7 5155      LD        L:0x5155, A
   1407          
   1408            /* Enable the write protection for RTC registers */
   1409            RTC->WPR = 0xFF; 
   \   000010 CD ....      CALL      L:??Subroutine19_0
   1410          }
   \                     ??CrossCallReturnLabel_63:
   \   000013 81           RET
   1411          
   1412          /**
   1413            * @brief  Returns the RTC Wakeup timer counter value.
   1414            * @param  None.
   1415            * @retval RTC Wakeup Counter value.
   1416            */

   \                                 In section .near_func.text, align 1
   1417          uint16_t RTC_GetWakeUpCounter(void)
   1418          {
   1419            uint16_t tmpreg = 0;
   1420          
   1421            /* Get the counter value */
   1422            tmpreg = ((uint16_t)RTC->WUTRH) << 8;
   \                     RTC_GetWakeUpCounter:
   \   000000 C6 5154      LD        A, L:0x5154
   \   000003 B7 ..        LD        S:?b1, A
   1423            tmpreg |= RTC->WUTRL;
   \   000005 C6 5155      LD        A, L:0x5155
   1424          
   1425            /* return RTC Wakeup Counter value*/
   1426            return (uint16_t)tmpreg;
   \   000008 5F           CLRW      X
   \   000009 41           EXG       A, XL
   \   00000A B6 ..        LD        A, S:?b1
   \   00000C 41           EXG       A, XL
   \   00000D 905F         CLRW      Y
   \   00000F 61           EXG       A, YL
   \   000010 90BF ..      LDW       S:?w0, Y
   \   000013 BA ..        OR        A, S:?b1
   \   000015 02           RLWA      X, A
   \   000016 81           RET
   1427          }
   1428          
   1429          /**
   1430            * @brief  Enables or Disables the RTC Wakeup Unit.
   1431            * @param  NewState: new state of the Wakeup Unit. This parameter can 
   1432            *                   be: ENABLE or DISABLE.
   1433            * @retval An ErrorStatus enumeration value:
   1434            *          - SUCCESS : RTC Wakeup Unit is enabled/disabled
   1435            *          - ERROR    : RTC Wakeup Unit is not enabled/disabled
   1436            */

   \                                 In section .near_func.text, align 1
   1437          ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
   1438          {
   1439            ErrorStatus status = ERROR;
   1440            uint16_t wutwfcount = 0;
   1441          
   1442            /* Check the parameters */
   1443            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1444          
   1445            /* Disable the write protection for RTC registers */
   1446            RTC->WPR = 0xCA;
   \                     RTC_WakeUpCmd:
   \   000000 CD ....      CALL      L:?Subroutine7
   1447            RTC->WPR = 0x53;
   1448          
   1449            if (NewState != DISABLE)
   \                     ??CrossCallReturnLabel_18:
   \   000003 27 06        JREQ      L:??RTC_WakeUpCmd_0
   1450            {
   1451              /* Enable the Wakeup Timer */
   1452              RTC->CR2 |= (uint8_t)RTC_CR2_WUTE;
   \   000005 7214 5149    BSET      L:0x5149, #0x2
   1453          
   1454              status = SUCCESS;
   \   000009 20 14        JRA       L:??RTC_WakeUpCmd_1
   1455            }
   1456            else
   1457            {
   1458              /* Disable the Wakeup Timer */
   1459              RTC->CR2 &= (uint8_t)~RTC_CR2_WUTE;
   \                     ??RTC_WakeUpCmd_0:
   \   00000B 7215 5149    BRES      L:0x5149, #0x2
   \   00000F 5F           CLRW      X
   1460          
   1461              /* Wait until WUTWF flag is set */
   1462              while (((RTC->ISR1 & RTC_ISR1_WUTWF) == RESET) && ( wutwfcount != WUTWF_TIMEOUT))
   1463              {
   1464                wutwfcount++;
   \                     ??RTC_WakeUpCmd_2:
   \   000010 5A           DECW      X
   1465              }
   \   000011 7204 514C 02 BTJT      L:0x514c, #0x2, L:??RTC_WakeUpCmd_3
   \   000016 26 F8        JRNE      L:??RTC_WakeUpCmd_2
   1466          
   1467              /* Check WUTWF flag is set or not */
   1468              if ((RTC->ISR1 & RTC_ISR1_WUTWF) == RESET)
   \                     ??RTC_WakeUpCmd_3:
   \   000018 C6 514C      LD        A, L:0x514c
   1469              {
   1470                status = ERROR;
   \   00001B A5 04        BCP       A, #0x4
   \   00001D 27 04        JREQ      L:??RTC_WakeUpCmd_4
   \                     ??RTC_WakeUpCmd_1:
   \   00001F A6 01        LD        A, #0x1
   \   000021 20 01        JRA       L:??RTC_WakeUpCmd_5
   \                     ??RTC_WakeUpCmd_4:
   \   000023 4F           CLR       A
   1471              }
   1472              else
   1473              {
   1474                status = SUCCESS;
   1475              }
   1476            }
   1477          
   1478            /* Enable the write protection for RTC registers */
   1479            RTC->WPR = 0xFF; 
   \                     ??RTC_WakeUpCmd_5:
   \   000024 CD ....      CALL      L:??Subroutine19_0
   1480          
   1481            /* Return the status*/
   1482            return (ErrorStatus)status;
   \                     ??CrossCallReturnLabel_62:
   \   000027 81           RET
   1483          }
   1484          
   1485          
   1486          
   1487          
   1488          
   1489          
   1490          /**
   1491            * @}
   1492            */
   1493          
   1494          /** @defgroup RTC_Group5 Daylight Saving configuration functions
   1495           *  @brief   Daylight Saving configuration functions 
   1496           *
   1497          @verbatim   
   1498           ===============================================================================
   1499                              Daylight Saving configuration functions
   1500           ===============================================================================  
   1501          
   1502            This section provide functions allowing to configure the RTC DayLight Saving.
   1503          
   1504          @endverbatim
   1505            * @{
   1506            */
   1507          
   1508          /**
   1509            * @brief  Adds or subtracts one hour from the current time depending on
   1510            *         the daylight saving parameter.
   1511            * @param  RTC_DayLightSaving: the day light saving Mode
   1512            *         This parameter can be one of the @ref RTC_DayLightSaving_TypeDef 
   1513            *         enumeration.
   1514            * @param  RTC_StoreOperation: the day light saving store operation
   1515            *         This parameter can be one of the @ref RTC_StoreOperation_TypeDef 
   1516            *         enumeration.
   1517            * @retval None
   1518            */

   \                                 In section .near_func.text, align 1
   1519          void RTC_DayLightSavingConfig(RTC_DayLightSaving_TypeDef RTC_DayLightSaving,
   1520                                        RTC_StoreOperation_TypeDef RTC_StoreOperation)
   1521          {
   \                     RTC_DayLightSavingConfig:
   \   000000 B7 ..        LD        S:?b1, A
   \   000002 B6 ..        LD        A, S:?b0
   1522            /* Check the parameters */
   1523            assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
   1524            assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
   1525          
   1526            /* Disable the write protection for RTC registers */
   1527            RTC->WPR = 0xCA;
   \   000004 CD ....      CALL      L:?Subroutine10
   1528            RTC->WPR = 0x53;
   1529          
   1530            /* Clear the bits to be configured */
   1531            RTC->CR3 &= (uint8_t)~(RTC_CR3_BCK);
   \                     ??CrossCallReturnLabel_28:
   \   000007 7215 514A    BRES      L:0x514a, #0x2
   1532          
   1533            /* Configure the RTC_CR3 register */
   1534            RTC->CR3 |= (uint8_t)((uint8_t)RTC_DayLightSaving | (uint8_t)RTC_StoreOperation);
   \   00000B CD ....      CALL      L:?Subroutine2
   1535          
   1536            /* Enable the write protection for RTC registers */
   1537            RTC->WPR = 0xFF; 
   1538          }
   \                     ??CrossCallReturnLabel_7:
   \   00000E 81           RET

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine2:
   \   000000 BA ..        OR        A, S:?b1
   \   000002 CA 514A      OR        A, L:0x514a
   \   000005 C7 514A      LD        L:0x514a, A
   \   000008 35 FF 5159   MOV       L:0x5159, #0xff
   \   00000C 81           RET
   1539          
   1540          /**
   1541            * @brief  Returns the stored operation.
   1542            * @param  None
   1543            * @retval the store operation, this parameter can be one of
   1544            *         the @ref RTC_StoreOperation_TypeDef enumeration.
   1545            */

   \                                 In section .near_func.text, align 1
   1546          RTC_StoreOperation_TypeDef  RTC_GetStoreOperation(void)
   1547          {
   1548            /* Return the stored operation*/
   1549            return (RTC_StoreOperation_TypeDef)(RTC->CR3 & RTC_CR3_BCK);
   \                     RTC_GetStoreOperation:
   \   000000 C6 514A      LD        A, L:0x514a
   \   000003 A4 04        AND       A, #0x4
   \   000005 81           RET
   1550          }
   1551          
   1552          
   1553          
   1554          
   1555          
   1556          
   1557          /**
   1558            * @}
   1559            */
   1560          
   1561          /** @defgroup RTC_Group6 Output pin Configuration function
   1562           *  @brief   Output pin Configuration function 
   1563           *
   1564          @verbatim   
   1565           ===============================================================================
   1566                                   Output pin Configuration function
   1567           ===============================================================================  
   1568          
   1569            This section provide functions allowing to configure the RTC Output source.
   1570          
   1571          @endverbatim
   1572            * @{
   1573            */
   1574          /**
   1575            * @brief  Configures the RTC output for the output pin (RTC_ALARM output).
   1576            * @param  RTC_OutputSel: Specifies which signal will be mapped to the output.
   1577            *         This parameter can be one parameter from the 
   1578            *         @ref RTC_OutputSel_TypeDef enumeration.
   1579            * @param  RTC_OutputPolarity: Specifies the polarity of the output signal.
   1580            *         This parameter can be one parameter from the 
   1581            *         @ref RTC_OutputPolarity_TypeDef enumeration.
   1582            * @retval None
   1583            */

   \                                 In section .near_func.text, align 1
   1584          void RTC_OutputConfig(RTC_Output_TypeDef RTC_Output,
   1585                                RTC_OutputPolarity_TypeDef RTC_OutputPolarity)
   1586          {
   \                     RTC_OutputConfig:
   \   000000 CD ....      CALL      L:?Subroutine3
   1587            /* Check the parameters */
   1588            assert_param(IS_RTC_OUTPUT_SEL(RTC_Output));
   1589            assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
   1590          
   1591            /* Disable the write protection for RTC registers */
   1592            RTC->WPR = 0xCA;
   1593            RTC->WPR = 0x53;
   1594          
   1595            /* Clear the bits to be configured */
   1596            RTC->CR3 &= (uint8_t)~(RTC_CR3_OSEL | RTC_CR3_POL);
   \                     ??CrossCallReturnLabel_9:
   \   000003 C6 514A      LD        A, L:0x514a
   \   000006 A4 8F        AND       A, #0x8f
   \   000008 C7 514A      LD        L:0x514a, A
   1597          
   1598            /* Configure the output selection and polarity */
   1599            RTC->CR3 |= (uint8_t)((uint8_t)RTC_Output | (uint8_t)RTC_OutputPolarity);
   \   00000B B6 ..        LD        A, S:?b0
   \   00000D CD ....      CALL      L:?Subroutine2
   1600          
   1601            /* Enable the write protection for RTC registers */
   1602            RTC->WPR = 0xFF; 
   1603          }
   \                     ??CrossCallReturnLabel_6:
   \   000010 81           RET

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine3:
   \   000000 B7 ..        LD        S:?b1, A
   \   000002 CD ....      CALL      L:?Subroutine17
   \                     ??CrossCallReturnLabel_49:
   \   000005 81           RET
   1604          
   1605          
   1606          
   1607          
   1608          /**
   1609            * @}
   1610            */
   1611          
   1612          /** @defgroup RTC_Group7 Output pin Configuration function
   1613           *  @brief   Output pin Configuration function 
   1614           *
   1615          @verbatim   
   1616           ===============================================================================
   1617                                   Output pin Configuration function
   1618           ===============================================================================  
   1619          
   1620            This section provide functions allowing to configure the RTC Output source.
   1621          
   1622          @endverbatim
   1623            * @{
   1624            */
   1625          /**
   1626          * @brief  Configures the Synchronization Shift Control Settings.
   1627          * @param  RTC_ShiftAdd1S : Select to add or not 1 second to the time Calendar.
   1628          *         This parameter can be one parameter from the @ref RTC_ShiftAdd1S_TypeDef
   1629          *         enumeration.
   1630          * @param  RTC_ShiftSubFS: Select the number of Second Fractions to Substitute.
   1631          *         This parameter can be one any value from 0 to 0x7FFF.
   1632           * @retval An ErrorStatus enumeration value:
   1633          *          - SUCCESS: RTC Shift registers are configured
   1634          *          - ERROR: RTC Shift registers are not configured
   1635          */

   \                                 In section .near_func.text, align 1
   1636          ErrorStatus RTC_SynchroShiftConfig(RTC_ShiftAdd1S_TypeDef RTC_ShiftAdd1S,
   1637                                             uint16_t RTC_ShiftSubFS)
   1638          {
   \                     RTC_SynchroShiftConfig:
   \   000000 B7 ..        LD        S:?b0, A
   \   000002 CD ....      CALL      L:?Subroutine5
   1639            uint8_t shiftrhreg = 0;
   1640            ErrorStatus status = ERROR;
   1641            uint16_t shpfcount = 0;
   1642          
   1643            /* Check the parameters */
   1644            assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
   1645            assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));
   1646          
   1647            /* Disable the write protection for RTC registers */
   1648            RTC->WPR = 0xCA;
   1649            RTC->WPR = 0x53;
   1650          
   1651            /* Check if a Shift is pending*/
   1652            if ((RTC->ISR1 & RTC_ISR1_SHPF) != RESET)
   \                     ??CrossCallReturnLabel_13:
   \   000005 7206 514C 03 BTJT      L:0x514c, #0x3, L:??RTC_SynchroShiftConfig_0
   \   00000A 20 0B        JRA       L:??RTC_SynchroShiftConfig_1
   1653            {
   1654              /* wait until the shift is completed*/
   1655              while (((RTC->ISR1 & RTC_ISR1_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
   1656              {
   1657                shpfcount++;
   \                     ??RTC_SynchroShiftConfig_2:
   \   00000C 5C           INCW      X
   1658              }
   \                     ??RTC_SynchroShiftConfig_0:
   \   00000D 7207 514C 05 BTJF      L:0x514c, #0x3, L:??RTC_SynchroShiftConfig_1
   \   000012 A3 FFFF      CPW       X, #0xffff
   \   000015 26 F5        JRNE      L:??RTC_SynchroShiftConfig_2
   1659            }
   1660          
   1661            /* check if the Shift pending is completed or if there is no Shift operation at all*/
   1662            if ((RTC->ISR1 & RTC_ISR1_SHPF) == RESET)
   \                     ??RTC_SynchroShiftConfig_1:
   \   000017 7206 514C 0F BTJT      L:0x514c, #0x3, L:??RTC_SynchroShiftConfig_3
   1663            {
   1664              /* Configure the Shift settings */
   1665              shiftrhreg = (uint8_t)((uint8_t)(RTC_ShiftSubFS >> 8) | (uint8_t)(RTC_ShiftAdd1S));
   1666              RTC->SHIFTRH = (uint8_t)(shiftrhreg);
   \   00001C 93           LDW       X, Y
   \   00001D 01           RRWA      X, A
   \   00001E 9F           LD        A, XL
   \   00001F BA ..        OR        A, S:?b0
   \   000021 C7 515A      LD        L:0x515a, A
   1667              RTC->SHIFTRL = (uint8_t)(RTC_ShiftSubFS);
   \   000024 909F         LD        A, YL
   \   000026 C7 515B      LD        L:0x515b, A
   1668          
   1669              status = SUCCESS;
   \   000029 A6 01        LD        A, #0x1
   1670            }
   1671            else
   1672            {
   1673              status = ERROR;
   1674            }
   1675          
   1676            /* Enable the write protection for RTC registers */
   1677            RTC->WPR = 0xFF; 
   \                     ??RTC_SynchroShiftConfig_3:
   \   00002B CD ....      CALL      L:??Subroutine19_0
   1678          
   1679            return (ErrorStatus)(status);
   \                     ??CrossCallReturnLabel_61:
   \   00002E 81           RET
   1680          }

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine5:
   \   000000 9093         LDW       Y, X
   \   000002 4F           CLR       A
   \   000003 5F           CLRW      X
   \   000004 CD ....      CALL      L:?Subroutine17
   \                     ??CrossCallReturnLabel_48:
   \   000007 81           RET
   1681          
   1682          
   1683          
   1684          /**
   1685            * @}
   1686            */
   1687          
   1688          /** @defgroup RTC_Group8 Output pin Configuration function
   1689           *  @brief   Output pin Configuration function 
   1690           *
   1691          @verbatim   
   1692           ===============================================================================
   1693                                   Output pin Configuration function
   1694           ===============================================================================  
   1695          
   1696            This section provide functions allowing to configure the RTC Output source.
   1697          
   1698          @endverbatim
   1699            * @{
   1700            */
   1701          /**
   1702          * @brief  Configures the Smooth Calibration Settings.
   1703          * @param  RTC_SmoothCalibPeriod : Select the Smooth Calibration Period.
   1704          *         This parameter can be one parameter from
   1705          *         the @ref RTC_SmoothCalibPeriod_TypeDef enumeration.
   1706          * @param  RTC_SmoothCalibPlusPulses : Select to Set or reset the CALP bit.
   1707          *         This parameter can be one parameter from the
   1708          *         @ref RTC_SmoothCalibPlusPulses_TypeDef enumeration.
   1709          * @param  RTC_SmouthCalibMinusPulsesValue: Select the value of CALM[8:0] bits.
   1710          *         This parameter can be one any value from 0 to 0x01FF.
   1711          * @retval An ErrorStatus enumeration value:
   1712          *          - SUCCESS: RTC Calib registers are configured
   1713          *          - ERROR: RTC Calib registers are not configured
   1714          */

   \                                 In section .near_func.text, align 1
   1715          ErrorStatus RTC_SmoothCalibConfig(RTC_SmoothCalibPeriod_TypeDef RTC_SmoothCalibPeriod,
   1716                                            RTC_SmoothCalibPlusPulses_TypeDef RTC_SmoothCalibPlusPulses,
   1717                                            uint16_t RTC_SmouthCalibMinusPulsesValue)
   1718          {
   \                     RTC_SmoothCalibConfig:
   \   000000 B7 ..        LD        S:?b2, A
   \   000002 CD ....      CALL      L:?Subroutine5
   1719            ErrorStatus status = ERROR;
   1720            uint16_t recalpfcount = 0;
   1721          
   1722            /* Check the parameters */
   1723            assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
   1724            assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
   1725            assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));
   1726          
   1727            /* Disable the write protection for RTC registers */
   1728            RTC->WPR = 0xCA;
   1729            RTC->WPR = 0x53;
   1730          
   1731            /* check if a calibration is pending*/
   1732            if ((RTC->ISR1 & RTC_ISR1_RECALPF) != RESET)
   \                     ??CrossCallReturnLabel_12:
   \   000005 7202 514C 03 BTJT      L:0x514c, #0x1, L:??RTC_SmoothCalibConfig_0
   \   00000A 20 0B        JRA       L:??RTC_SmoothCalibConfig_1
   1733            {
   1734              /* wait until the Calibration is completed*/
   1735              while (((RTC->ISR1 & RTC_ISR1_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
   1736              {
   1737                recalpfcount++;
   \                     ??RTC_SmoothCalibConfig_2:
   \   00000C 5C           INCW      X
   1738              }
   \                     ??RTC_SmoothCalibConfig_0:
   \   00000D 7203 514C 05 BTJF      L:0x514c, #0x1, L:??RTC_SmoothCalibConfig_1
   \   000012 A3 FFFF      CPW       X, #0xffff
   \   000015 26 F5        JRNE      L:??RTC_SmoothCalibConfig_2
   1739            }
   1740          
   1741            /* check if the calibration pending is completed or if there is 
   1742               no calibration operation at all*/
   1743            if ((RTC->ISR1 & RTC_ISR1_RECALPF) == RESET)
   \                     ??RTC_SmoothCalibConfig_1:
   \   000017 7202 514C 15 BTJT      L:0x514c, #0x1, L:??RTC_SmoothCalibConfig_3
   1744            {
   1745              /* Configure the Smooth calibration settings */
   1746              RTC->CALRH = (uint8_t)((uint8_t)((uint8_t)RTC_SmoothCalibPeriod | \
   1747                                     (uint8_t)RTC_SmoothCalibPlusPulses) | \
   1748                                     (uint8_t)((uint16_t)RTC_SmouthCalibMinusPulsesValue >> 8));
   \   00001C 93           LDW       X, Y
   \   00001D 01           RRWA      X, A
   \   00001E 41           EXG       A, XL
   \   00001F B7 ..        LD        S:?b1, A
   \   000021 B6 ..        LD        A, S:?b0
   \   000023 BA ..        OR        A, S:?b2
   \   000025 BA ..        OR        A, S:?b1
   \   000027 C7 516A      LD        L:0x516a, A
   1749              RTC->CALRL = (uint8_t)(RTC_SmouthCalibMinusPulsesValue);
   \   00002A 909F         LD        A, YL
   \   00002C C7 516B      LD        L:0x516b, A
   1750          
   1751              status = SUCCESS;
   \   00002F A6 01        LD        A, #0x1
   1752            }
   1753            else
   1754            {
   1755              status = ERROR;
   1756            }
   1757          
   1758            /* Enable the write protection for RTC registers */
   1759            RTC->WPR = 0xFF; 
   \                     ??RTC_SmoothCalibConfig_3:
   \   000031 CD ....      CALL      L:??Subroutine19_0
   1760          
   1761            return (ErrorStatus)(status);
   \                     ??CrossCallReturnLabel_60:
   \   000034 81           RET
   1762          }
   1763          
   1764          
   1765          /**
   1766            * @}
   1767            */
   1768          
   1769          /** @defgroup RTC_Group9 Digital Calibration configuration functions
   1770           *  @brief   Digital Calibration configuration functions 
   1771           *
   1772          @verbatim   
   1773           ===============================================================================
   1774                            Calibration configuration functions
   1775           ===============================================================================  
   1776          
   1777          @endverbatim
   1778            * @{
   1779            */
   1780          /**
   1781          * @brief  Configure the Calibration Pin-out (RTC_CALIB) Selection (1Hz or 512Hz).
   1782          * @param  RTC_CalibOutput : Select the Calibration output Selection .
   1783          *         This parameter can be one parameter from the
   1784          *         @ref RTC_CalibOutput_TypeDef enumeration.
   1785          * @retval None
   1786          */

   \                                 In section .near_func.text, align 1
   1787          void RTC_CalibOutputConfig(RTC_CalibOutput_TypeDef RTC_CalibOutput)
   1788          {
   1789            /* Check the parameters */
   1790            assert_param(IS_RTC_CALOUTPUT_SELECT(RTC_CalibOutput));
   1791          
   1792            /* Disable the write protection for RTC registers */
   1793            RTC->WPR = 0xCA;
   \                     RTC_CalibOutputConfig:
   \   000000 CD ....      CALL      L:?Subroutine7
   1794            RTC->WPR = 0x53;
   1795          
   1796            if (RTC_CalibOutput != RTC_CalibOutput_512Hz)
   \                     ??CrossCallReturnLabel_17:
   \   000003 27 06        JREQ      L:??RTC_CalibOutputConfig_0
   1797            {
   1798              /* Enable the RTC clock output */
   1799              RTC->CR3 |= (uint8_t)RTC_CR3_COSEL;
   \   000005 7216 514A    BSET      L:0x514a, #0x3
   \   000009 20 04        JRA       L:??RTC_CalibOutputConfig_1
   1800            }
   1801            else
   1802            {
   1803              /* Disable the RTC clock output */
   1804              RTC->CR3 &= (uint8_t)~RTC_CR3_COSEL;
   \                     ??RTC_CalibOutputConfig_0:
   \   00000B 7217 514A    BRES      L:0x514a, #0x3
   1805            }
   1806          
   1807            /* Enable the write protection for RTC registers */
   1808            RTC->WPR = 0xFF; 
   \                     ??RTC_CalibOutputConfig_1:
   \   00000F CD ....      CALL      L:??Subroutine19_0
   1809          }
   \                     ??CrossCallReturnLabel_59:
   \   000012 81           RET
   1810          
   1811          /**
   1812          * @brief  Enables or disables the RTC clock to be output through the relative pin.
   1813          * @param  NewState: new state of the RTC Calibration output
   1814            *         This parameter can be: ENABLE or DISABLE.
   1815          * @retval None
   1816          */

   \                                 In section .near_func.text, align 1
   1817          void RTC_CalibOutputCmd(FunctionalState NewState)
   1818          {
   1819            /* Check the parameters */
   1820            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1821          
   1822            /* Disable the write protection for RTC registers */
   1823            RTC->WPR = 0xCA;
   \                     RTC_CalibOutputCmd:
   \   000000 CD ....      CALL      L:?Subroutine7
   1824            RTC->WPR = 0x53;
   1825          
   1826            if (NewState != DISABLE)
   \                     ??CrossCallReturnLabel_16:
   \   000003 27 06        JREQ      L:??RTC_CalibOutputCmd_0
   1827            {
   1828              /* Enable the RTC clock output */
   1829              RTC->CR3 |= (uint8_t)RTC_CR3_COE;
   \   000005 721E 514A    BSET      L:0x514a, #0x7
   \   000009 20 04        JRA       L:??RTC_CalibOutputCmd_1
   1830            }
   1831            else
   1832            {
   1833              /* Disable the RTC clock output */
   1834              RTC->CR3 &= (uint8_t)~RTC_CR3_COE;
   \                     ??RTC_CalibOutputCmd_0:
   \   00000B 721F 514A    BRES      L:0x514a, #0x7
   1835            }
   1836          
   1837            /* Enable the write protection for RTC registers */
   1838            RTC->WPR = 0xFF; 
   \                     ??RTC_CalibOutputCmd_1:
   \   00000F CD ....      CALL      L:??Subroutine19_0
   1839          }
   \                     ??CrossCallReturnLabel_58:
   \   000012 81           RET
   1840          
   1841          
   1842          /**
   1843            * @}
   1844            */
   1845          
   1846          /** @defgroup RTC_Group10 Tampers configuration functions
   1847           *  @brief   Tampers configuration functions 
   1848           *
   1849          @verbatim   
   1850           ===============================================================================
   1851                                 Tampers configuration functions
   1852           ===============================================================================  
   1853          
   1854          @endverbatim
   1855            * @{
   1856            */
   1857          
   1858          /**
   1859          * @brief  Configures the Tamper Sensitive Level.
   1860          * @param  RTC_Tamper: Select the tamper to configure.
   1861          *         This parameter can be one parameter from the @ref RTC_Tamper_TypeDef
   1862          *         enumeration.
   1863          * @param  RTC_TamperLevel: Select the tamper Sensitive Level.
   1864          *         This parameter can be one parameter from the 
   1865          *         @ref RTC_TamperLevel_TypeDef enumeration.
   1866          * @retval None
   1867          */

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine11:
   \   000000 C7 516C      LD        L:0x516c, A
   \   000003 35 FF 5159   MOV       L:0x5159, #0xff
   \   000007 81           RET

   \                                 In section .near_func.text, align 1
   1868          void RTC_TamperLevelConfig(RTC_Tamper_TypeDef RTC_Tamper,
   1869                                     RTC_TamperLevel_TypeDef RTC_TamperLevel)
   1870          {
   1871            /* Check the parameters */
   1872            assert_param(IS_RTC_TAMPER((uint8_t)RTC_Tamper));
   1873            assert_param(IS_RTC_TAMPER_LEVEL(RTC_TamperLevel));
   1874          
   1875            /* Disable the write protection for RTC registers */
   1876            RTC->WPR = 0xCA;
   \                     RTC_TamperLevelConfig:
   \   000000 CD ....      CALL      L:?Subroutine10
   1877            RTC->WPR = 0x53;
   1878          
   1879            if (RTC_TamperLevel != RTC_TamperLevel_Low)
   \                     ??CrossCallReturnLabel_27:
   \   000003 48           SLL       A
   \   000004 3D ..        TNZ       S:?b0
   \   000006 27 05        JREQ      L:??RTC_TamperLevelConfig_0
   1880            {
   1881              /* Enable the selected Tampers */
   1882              RTC->TCR1 |= (uint8_t)(RTC_Tamper << 1);
   \   000008 CA 516C      OR        A, L:0x516c
   \   00000B 20 04        JRA       L:??RTC_TamperLevelConfig_1
   1883            }
   1884            else
   1885            {
   1886              /* Disable the selected Tampers */
   1887              RTC->TCR1 &= (uint8_t)~(uint8_t)(RTC_Tamper << 1);
   \                     ??RTC_TamperLevelConfig_0:
   \   00000D 43           CPL       A
   \   00000E C4 516C      AND       A, L:0x516c
   1888            }
   \                     ??RTC_TamperLevelConfig_1:
   \   000011 CD ....      CALL      L:?Subroutine11
   1889          
   1890            /* Enable the write protection for RTC registers */
   1891            RTC->WPR = 0xFF; 
   1892          }
   \                     ??CrossCallReturnLabel_37:
   \   000014 81           RET
   1893          /**
   1894            * @brief  Configures the Tampers Filter.
   1895            * @param  RTC_TamperFilter: Specifies the tampers filter.
   1896            *         This parameter can be one parameter from the
   1897            *         @ref RTC_TamperFilter_TypeDef enumeration.
   1898            * @retval None
   1899            */

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine1:
   \   000000 C7 516D      LD        L:0x516d, A
   \   000003 B6 ..        LD        A, S:?b0
   \   000005 CA 516D      OR        A, L:0x516d
   \   000008 C7 516D      LD        L:0x516d, A
   \   00000B 35 FF 5159   MOV       L:0x5159, #0xff
   \   00000F 81           RET

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine0:
   \   000000 B7 ..        LD        S:?b0, A
   \   000002 CD ....      CALL      L:?Subroutine17
   \                     ??CrossCallReturnLabel_47:
   \   000005 C6 516D      LD        A, L:0x516d
   \   000008 81           RET

   \                                 In section .near_func.text, align 1
   1900          void RTC_TamperFilterConfig(RTC_TamperFilter_TypeDef RTC_TamperFilter)
   1901          {
   \                     RTC_TamperFilterConfig:
   \   000000 CD ....      CALL      L:?Subroutine0
   1902          
   1903            /* Check the parameters */
   1904            assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
   1905          
   1906            /* Disable the write protection for RTC registers */
   1907            RTC->WPR = 0xCA;
   1908            RTC->WPR = 0x53;
   1909          
   1910            /*clear flags before configuration */
   1911            RTC->TCR2 &= (uint8_t)~(RTC_TCR2_TAMPFLT);
   \                     ??CrossCallReturnLabel_2:
   \   000003 A4 E7        AND       A, #0xe7
   \   000005 CD ....      CALL      L:?Subroutine1
   1912          
   1913            /* Configure the RTC_TCR register */
   1914            RTC->TCR2 |= (uint8_t)RTC_TamperFilter;
   1915          
   1916            /* Enable the write protection for RTC registers */
   1917            RTC->WPR = 0xFF; 
   1918          
   1919          }
   \                     ??CrossCallReturnLabel_5:
   \   000008 81           RET
   1920          
   1921          /**
   1922            * @brief  Configures the Tampers Sampling Frequency.
   1923            * @param  RTC_TamperSamplingFreq: Specifies the tampers Sampling Frequency.
   1924            *         This parameter can be one parameter from the
   1925            *         @ref RTC_TamperSamplingFreq_TypeDef enumeration.
   1926            * @retval None
   1927            */

   \                                 In section .near_func.text, align 1
   1928          void RTC_TamperSamplingFreqConfig(RTC_TamperSamplingFreq_TypeDef RTC_TamperSamplingFreq)
   1929          {
   \                     RTC_TamperSamplingFreqConfig:
   \   000000 CD ....      CALL      L:?Subroutine0
   1930            /* Check the parameters */
   1931            assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
   1932          
   1933            /* Disable the write protection for RTC registers */
   1934            RTC->WPR = 0xCA;
   1935            RTC->WPR = 0x53;
   1936          
   1937            /* Clear flags before configuration */
   1938            RTC->TCR2 &= (uint8_t)~(RTC_TCR2_TAMPFREQ);
   \                     ??CrossCallReturnLabel_1:
   \   000003 A4 F8        AND       A, #0xf8
   \   000005 CD ....      CALL      L:?Subroutine1
   1939          
   1940            /* Configure the RTC_TCR register */
   1941            RTC->TCR2 |= (uint8_t)RTC_TamperSamplingFreq;
   1942          
   1943            /* Enable the write protection for RTC registers */
   1944            RTC->WPR = 0xFF; 
   1945          }
   \                     ??CrossCallReturnLabel_4:
   \   000008 81           RET
   1946          
   1947          /**
   1948          * @brief  Configures the Tampers Pins input Precharge Duration.
   1949          * @param  RTC_TamperPrechargeDuration: Specifies the Tampers Pins input
   1950          *         Precharge Duration.
   1951          *         This parameter can be one parameter from the
   1952          *         @ref RTC_TamperPrechargeDuration_TypeDef enumeration.
   1953          * @retval None
   1954          */

   \                                 In section .near_func.text, align 1
   1955          void RTC_TamperPinsPrechargeDuration(RTC_TamperPrechargeDuration_TypeDef RTC_TamperPrechargeDuration)
   1956          {
   \                     RTC_TamperPinsPrechargeDuration:
   \   000000 CD ....      CALL      L:?Subroutine0
   1957            /* Check the parameters */
   1958            assert_param(IS_RTC_TAMPER_PINS_PRECHAR_DURATION(RTC_TamperPrechargeDuration));
   1959          
   1960            /* Disable the write protection for RTC registers */
   1961            RTC->WPR = 0xCA;
   1962            RTC->WPR = 0x53;
   1963          
   1964            /* Clear the tampers  pull-up  and precharge/discharge duration Old settings*/
   1965            RTC->TCR2 &= (uint8_t)~(RTC_TCR2_TAMPPUDIS | RTC_TCR2_TAMPPRCH);
   \                     ??CrossCallReturnLabel_0:
   \   000003 A4 1F        AND       A, #0x1f
   \   000005 CD ....      CALL      L:?Subroutine1
   1966          
   1967            /* Configure the Tampers Precharge Duration  and pull-up New settings*/
   1968            RTC->TCR2 |= (uint8_t)RTC_TamperPrechargeDuration;
   1969          
   1970            /* Enable the write protection for RTC registers */
   1971            RTC->WPR = 0xFF; 
   1972          }
   \                     ??CrossCallReturnLabel_3:
   \   000008 81           RET
   1973          
   1974          
   1975          /**
   1976          * @brief  Enables or Disables the Tamper detection.
   1977          * @param  RTC_Tamper: Select the tamper to configure.
   1978          *         This parameter can be one parameter from the @ref RTC_Tamper_TypeDef
   1979          *         enumeration.
   1980          * @param  NewState: new state of the tamper pin.
   1981            *         This parameter can be: ENABLE or DISABLE.
   1982          * @retval None
   1983          */

   \                                 In section .near_func.text, align 1
   1984          void RTC_TamperCmd(RTC_Tamper_TypeDef RTC_Tamper,
   1985                             FunctionalState NewState)
   1986          {
   1987          
   1988            /* Check the parameters */
   1989            assert_param(IS_RTC_TAMPER((uint8_t)RTC_Tamper));
   1990            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1991          
   1992            /* Disable the write protection for RTC registers */
   1993            RTC->WPR = 0xCA;
   \                     RTC_TamperCmd:
   \   000000 CD ....      CALL      L:?Subroutine10
   1994            RTC->WPR = 0x53;
   1995          
   1996          
   1997            if (NewState != DISABLE)
   \                     ??CrossCallReturnLabel_26:
   \   000003 3D ..        TNZ       S:?b0
   \   000005 27 05        JREQ      L:??RTC_TamperCmd_0
   1998            {
   1999              /* Enable the selected Tampers */
   2000              RTC->TCR1 |= (uint8_t)RTC_Tamper;
   \   000007 CA 516C      OR        A, L:0x516c
   \   00000A 20 04        JRA       L:??RTC_TamperCmd_1
   2001            }
   2002            else
   2003            {
   2004              /* Disable the selected Tampers */
   2005              RTC->TCR1 &= (uint8_t)~RTC_Tamper;
   \                     ??RTC_TamperCmd_0:
   \   00000C 43           CPL       A
   \   00000D C4 516C      AND       A, L:0x516c
   2006            }
   \                     ??RTC_TamperCmd_1:
   \   000010 CD ....      CALL      L:?Subroutine11
   2007          
   2008          
   2009            /* Enable the write protection for RTC registers */
   2010            RTC->WPR = 0xFF; 
   2011          }
   \                     ??CrossCallReturnLabel_36:
   \   000013 81           RET
   2012          
   2013          
   2014          
   2015          /**
   2016            * @}
   2017            */
   2018          
   2019          /** @defgroup RTC_Group11 Interrupts and flags management functions
   2020           *  @brief   Interrupts and flags management functions  
   2021           *
   2022          @verbatim   
   2023           ===============================================================================
   2024                                 Interrupts and flags management functions
   2025           ===============================================================================  
   2026           
   2027           To enable the RTC Alarm interrupt, the following sequence is required:
   2028             - Configure the RTC to generate RTC alarm (Alarm A) using the RTC_SetAlarm() 
   2029               and RTC_AlarmCmd() functions.
   2030          
   2031           To enable the RTC Wakeup interrupt, the following sequence is required:
   2032             - Configure the RTC to generate the RTC wakeup timer event using the 
   2033               RTC_WakeUpClockConfig(), RTC_SetWakeUpCounter() and RTC_WakeUpCmd() functions.
   2034          
   2035           To enable the RTC Tamper interrupt, the following sequence is required:
   2036             - Configure the RTC to detect the RTC tamper event using the 
   2037               RTC_TamperTriggerConfig() and RTC_TamperCmd() functions.
   2038          
   2039          
   2040          
   2041          @endverbatim
   2042            * @{
   2043            */
   2044          /**
   2045          * @brief  Enables or Disables the specified RTC interrupts.
   2046          * @param  RTC_IT: specifies the RTC interrupt sources to be enabled or disabled.
   2047          *         This parameter can be any combination of the following values:
   2048          *         @arg RTC_IT_ALRA:  Alarm A interrupt
   2049          *         @arg RTC_IT_TAMP:  Tampers interrupt
   2050          *         @arg RTC_IT_WUT:  WakeUp Timer interrupt
   2051          * @param  NewState: new state of the specified RTC interrupts.
   2052            *         This parameter can be: ENABLE or DISABLE.
   2053          * @retval None
   2054          */

   \                                 In section .near_func.text, align 1
   2055          void RTC_ITConfig(RTC_IT_TypeDef RTC_IT, FunctionalState NewState)
   2056          {
   \                     RTC_ITConfig:
   \   000000 CD ....      CALL      L:?Subroutine3
   2057            /* Check the parameters */
   2058            assert_param(IS_RTC_CONFIG_IT(RTC_IT));
   2059            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2060          
   2061            /* Disable the write protection for RTC registers */
   2062            RTC->WPR = 0xCA;
   2063            RTC->WPR = 0x53;
   2064          
   2065            if (NewState != DISABLE)
   \                     ??CrossCallReturnLabel_8:
   \   000003 9F           LD        A, XL
   \   000004 A4 01        AND       A, #0x1
   \   000006 B7 ..        LD        S:?b0, A
   \   000008 9F           LD        A, XL
   \   000009 A4 F0        AND       A, #0xf0
   \   00000B 3D ..        TNZ       S:?b1
   \   00000D 27 0D        JREQ      L:??RTC_ITConfig_0
   2066            {
   2067              /* Enable the Interrupts */
   2068              RTC->CR2 |= (uint8_t)((uint16_t)RTC_IT & (uint16_t)0x00F0);
   \   00000F CA 5149      OR        A, L:0x5149
   \   000012 C7 5149      LD        L:0x5149, A
   2069              RTC->TCR1 |= (uint8_t)((uint16_t)RTC_IT & RTC_TCR1_TAMPIE);
   \   000015 B6 ..        LD        A, S:?b0
   \   000017 CA 516C      OR        A, L:0x516c
   \   00001A 20 0E        JRA       L:??RTC_ITConfig_1
   2070            }
   2071            else
   2072            {
   2073              /* Disable the Interrupts */
   2074              RTC->CR2  &= (uint8_t)~(uint8_t)((uint16_t)RTC_IT & (uint16_t)0x00F0);
   \                     ??RTC_ITConfig_0:
   \   00001C 43           CPL       A
   \   00001D C4 5149      AND       A, L:0x5149
   \   000020 C7 5149      LD        L:0x5149, A
   2075              RTC->TCR1 &= (uint8_t)~(uint8_t)((uint16_t)RTC_IT & (uint16_t)RTC_TCR1_TAMPIE);
   \   000023 33 ..        CPL       S:?b0
   \   000025 B6 ..        LD        A, S:?b0
   \   000027 C4 516C      AND       A, L:0x516c
   2076            }
   \                     ??RTC_ITConfig_1:
   \   00002A CD ....      CALL      L:?Subroutine11
   2077          
   2078            /* Enable the write protection for RTC registers */
   2079            RTC->WPR = 0xFF; 
   2080          }
   \                     ??CrossCallReturnLabel_35:
   \   00002D 81           RET
   2081          /**
   2082          * @brief  Checks whether the specified RTC flag is set or not.
   2083          * @param  RTC_FLAG: specifies the flag to check.
   2084          *         This parameter can be one of the @ref RTC_Flag_TypeDef enumeration.
   2085          * @retval Status of RTC_FLAG (SET or RESET)
   2086          */

   \                                 In section .near_func.text, align 1
   2087          FlagStatus RTC_GetFlagStatus(RTC_Flag_TypeDef RTC_FLAG)
   2088          {
   \                     RTC_GetFlagStatus:
   \   000000 BF ..        LDW       S:?w2, X
   2089            FlagStatus flagstatus = RESET;
   \   000002 3F ..        CLR       S:?b0
   2090            uint16_t tmpreg1 = 0;
   2091            uint16_t tmpreg2 = 0;
   2092          
   2093            /* Check the parameters */
   2094            assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
   2095          
   2096            /* Get all the flags */
   2097            tmpreg2 = (uint16_t)((uint16_t)RTC->ISR1 << 8);
   \   000004 C6 514C      LD        A, L:0x514c
   \   000007 B7 ..        LD        S:?b2, A
   2098            tmpreg1 = (uint16_t)((uint16_t)((uint16_t)(RTC->ISR2)) | tmpreg2);
   \   000009 C6 514D      LD        A, L:0x514d
   2099          
   2100            /* Return the status of the flag */
   2101            if ((tmpreg1 & (uint16_t)RTC_FLAG) != RESET)
   \   00000C 5F           CLRW      X
   \   00000D 41           EXG       A, XL
   \   00000E 02           RLWA      X, A
   \   00000F BA ..        OR        A, S:?b2
   \   000011 02           RLWA      X, A
   \   000012 B4 ..        AND       A, S:?b5
   \   000014 01           RRWA      X, A
   \   000015 B4 ..        AND       A, S:?b4
   \   000017 01           RRWA      X, A
   \   000018 27 04        JREQ      L:??RTC_GetFlagStatus_0
   2102            {
   2103              flagstatus = SET;
   \   00001A 35 01 ....   MOV       S:?b0, #0x1
   2104            }
   2105            else
   2106            {
   2107              flagstatus = RESET;
   2108            }
   2109            return (FlagStatus)flagstatus;
   \                     ??RTC_GetFlagStatus_0:
   \   00001E B6 ..        LD        A, S:?b0
   \   000020 81           RET
   2110          }
   2111          
   2112          /**
   2113          * @brief  Clears the RTC's pending flags.
   2114          * @param  RTC_FLAG: specifies the RTC flag to clear.
   2115          *         This parameter can be any combination of the @ref RTC_Flag_TypeDef
   2116          *         enumeration.
   2117          * @retval None
   2118          */

   \                                 In section .near_func.text, align 1
   2119          void RTC_ClearFlag(RTC_Flag_TypeDef RTC_FLAG)
   2120          {
   2121            /* Check the parameters */
   2122            assert_param(IS_RTC_CLEAR_FLAG((uint16_t)RTC_FLAG));
   2123          
   2124            /* Clear the Flags in the RTC_ISR registers */
   2125            RTC->ISR2 = (uint8_t)~((uint8_t)RTC_FLAG) ;
   \                     RTC_ClearFlag:
   \   000000 9F           LD        A, XL
   \   000001 43           CPL       A
   \   000002 C7 514D      LD        L:0x514d, A
   2126            RTC->ISR1 = (uint8_t)(((uint8_t)~(uint8_t)((uint16_t)RTC_FLAG >> (uint8_t)8)) & ((uint8_t)~(uint8_t)(RTC_ISR1_INIT)));
   \   000005 4F           CLR       A
   \   000006 01           RRWA      X, A
   \   000007 9F           LD        A, XL
   \   000008 43           CPL       A
   \   000009 A4 7F        AND       A, #0x7f
   \   00000B C7 514C      LD        L:0x514c, A
   2127          }
   \   00000E 81           RET
   2128          
   2129          /**
   2130          * @brief  Checks whether the specified RTC interrupt has occurred or not.
   2131          * @param  RTC_IT: specifies the RTC interrupt source to check.
   2132          *         This parameter can be one of the @ref RTC_IT_TypeDef enumeration.
   2133          * @retval Status of RTC_IT (SET or RESET).
   2134          */

   \                                 In section .near_func.text, align 1
   2135          ITStatus RTC_GetITStatus(RTC_IT_TypeDef RTC_IT)
   2136          {
   \                     RTC_GetITStatus:
   \   000000 9093         LDW       Y, X
   2137            ITStatus itstatus = RESET;
   \   000002 3F ..        CLR       S:?b0
   2138            uint8_t enablestatus = 0, tmpreg = 0;
   2139          
   2140            /* Check the parameters */
   2141            assert_param(IS_RTC_GET_IT(RTC_IT));
   2142          
   2143            /* Get the Interrupt enable Status */
   2144            enablestatus = (uint8_t)(RTC->CR2 & (uint16_t)RTC_IT);
   \   000004 C6 5149      LD        A, L:0x5149
   \   000007 B7 ..        LD        S:?b2, A
   2145          
   2146            /* Get the Interrupt pending bit */
   2147            tmpreg = (uint8_t)(RTC->ISR2 & (uint8_t)((uint16_t)RTC_IT >> 4));
   \   000009 CD ....      CALL      L:?srl16_x_x_4
   \   00000C 9F           LD        A, XL
   \   00000D C4 514D      AND       A, L:0x514d
   \   000010 B7 ..        LD        S:?b1, A
   2148          
   2149            /* Get the status of the Interrupt */
   2150            if ((enablestatus != (uint8_t)RESET) && (tmpreg != (uint8_t)RESET))
   \   000012 909F         LD        A, YL
   \   000014 B5 ..        BCP       A, S:?b2
   \   000016 27 08        JREQ      L:??RTC_GetITStatus_0
   \   000018 3D ..        TNZ       S:?b1
   \   00001A 27 04        JREQ      L:??RTC_GetITStatus_0
   2151            {
   2152              itstatus = SET;
   \   00001C 35 01 ....   MOV       S:?b0, #0x1
   2153            }
   2154            else
   2155            {
   2156              itstatus = RESET;
   2157            }
   2158          
   2159            return (ITStatus)itstatus;
   \                     ??RTC_GetITStatus_0:
   \   000020 B6 ..        LD        A, S:?b0
   \   000022 81           RET
   2160          }
   2161          
   2162          /**
   2163          * @brief  Clears the RTC's interrupt pending bits.
   2164          * @param  RTC_IT: specifies the RTC interrupt pending bit to clear.
   2165          *         This parameter can be any combination of the @ref RTC_IT_TypeDef
   2166          *         enumeration.
   2167          * @retval None
   2168          */

   \                                 In section .near_func.text, align 1
   2169          void RTC_ClearITPendingBit(RTC_IT_TypeDef RTC_IT)
   2170          {
   2171            /* Check the parameters */
   2172            assert_param(IS_RTC_CLEAR_IT((uint16_t)RTC_IT));
   2173          
   2174            /* Clear the interrupt pending bits in the RTC_ISR registers */
   2175            RTC->ISR2 = (uint8_t)~(uint8_t)((uint16_t)RTC_IT >> 4);
   \                     RTC_ClearITPendingBit:
   \   000000 CD ....      CALL      L:?srl16_x_x_4
   \   000003 9F           LD        A, XL
   \   000004 43           CPL       A
   \   000005 C7 514D      LD        L:0x514d, A
   2176          }
   \   000008 81           RET
   2177          
   2178          /**
   2179            * @}
   2180            */
   2181          
   2182          
   2183          
   2184          
   2185          
   2186          
   2187          
   2188          
   2189          
   2190          /**
   2191           * @addtogroup RTC_Private_Functions
   2192           * @{
   2193           */
   2194          /**
   2195          * @brief  Converts a 2 digit decimal to BCD format
   2196          * @param  Value: Byte to be converted.
   2197          * @retval Converted byte
   2198          */

   \                                 In section .near_func.text, align 1
   2199          static uint8_t ByteToBcd2(uint8_t Value)
   2200          {
   \                     ByteToBcd2:
   \   000000 B7 ..        LD        S:?b1, A
   2201            uint8_t bcdhigh = 0;
   \   000002 3F ..        CLR       S:?b0
   \   000004 20 09        JRA       L:??ByteToBcd2_0
   2202          
   2203            while (Value >= 10)
   2204            {
   2205              bcdhigh++;
   \                     ??ByteToBcd2_1:
   \   000006 4C           INC       A
   \   000007 B7 ..        LD        S:?b0, A
   2206              Value -= 10;
   \   000009 B6 ..        LD        A, S:?b1
   \   00000B AB F6        ADD       A, #0xf6
   \   00000D B7 ..        LD        S:?b1, A
   2207            }
   \                     ??ByteToBcd2_0:
   \   00000F B6 ..        LD        A, S:?b1
   \   000011 A1 0A        CP        A, #0xa
   \   000013 B6 ..        LD        A, S:?b0
   \   000015 24 EF        JRNC      L:??ByteToBcd2_1
   2208          
   2209            return  (uint8_t)((uint8_t)(bcdhigh << 4) | Value);
   \   000017 4E           SWAP      A
   \   000018 A4 F0        AND       A, #0xf0
   \   00001A BA ..        OR        A, S:?b1
   \   00001C 81           RET
   2210          }
   2211          
   2212          /**
   2213          * @brief  Converts from 2 digit BCD to Binary format
   2214          * @param  Value: BCD value to be converted.
   2215          * @retval Converted word
   2216          */

   \                                 In section .near_func.text, align 1
   2217          static uint8_t Bcd2ToByte(uint8_t Value)
   2218          {
   \                     Bcd2ToByte:
   \   000000 B7 ..        LD        S:?b1, A
   2219            uint8_t tmp = 0;
   2220          
   2221            tmp = (uint8_t)((uint8_t)((uint8_t)(Value & (uint8_t)0xF0) >> 4) * (uint8_t)10);
   2222          
   2223            return (uint8_t)(tmp + (Value & (uint8_t)0x0F));
   \   000002 4E           SWAP      A
   \   000003 A4 0F        AND       A, #0xf
   \   000005 35 0A ....   MOV       S:?b0, #0xa
   \   000009 97           LD        XL, A
   \   00000A B6 ..        LD        A, S:?b0
   \   00000C 42           MUL       X, A
   \   00000D 41           EXG       A, XL
   \   00000E B7 ..        LD        S:?b0, A
   \   000010 B6 ..        LD        A, S:?b1
   \   000012 A4 0F        AND       A, #0xf
   \   000014 BB ..        ADD       A, S:?b0
   \   000016 81           RET
   2224          }
   2225          
   2226          /**
   2227            * @}
   2228            */ 
   2229          
   2230          /**
   2231            * @}
   2232            */ 
   2233            
   2234          /**
   2235            * @}
   2236            */
   2237          
   2238          /**
   2239            * @}
   2240            */
   2241          
   2242          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
       5  ??Subroutine19_0
       9  ?Subroutine0
      16  ?Subroutine1
       4  ?Subroutine10
       8  ?Subroutine11
       4  ?Subroutine12
      11  ?Subroutine13
      10  ?Subroutine14
       9  ?Subroutine15
       9  ?Subroutine16
       9  ?Subroutine17
      10  ?Subroutine18
      13  ?Subroutine2
       6  ?Subroutine3
      17  ?Subroutine4
       8  ?Subroutine5
      11  ?Subroutine6
       5  ?Subroutine7
       9  ?Subroutine8
       9  ?Subroutine9
      23  Bcd2ToByte
      29  ByteToBcd2
      55  RTC_AlarmCmd
      29  RTC_AlarmStructInit
      54  RTC_AlarmSubSecondConfig
      19  RTC_BypassShadowCmd
      19  RTC_CalibOutputCmd
      19  RTC_CalibOutputConfig
      15  RTC_ClearFlag
       9  RTC_ClearITPendingBit
      16  RTC_DateStructInit
      15  RTC_DayLightSavingConfig
     188  RTC_DeInit
      27  RTC_EnterInitMode
       5  RTC_ExitInitMode
     161  RTC_GetAlarm
      66  RTC_GetDate
      33  RTC_GetFlagStatus
      35  RTC_GetITStatus
       6  RTC_GetStoreOperation
      23  RTC_GetSubSecond
      66  RTC_GetTime
      23  RTC_GetWakeUpCounter
      46  RTC_ITConfig
      65  RTC_Init
      17  RTC_OutputConfig
      19  RTC_RatioCmd
     209  RTC_SetAlarm
     134  RTC_SetDate
     114  RTC_SetTime
      20  RTC_SetWakeUpCounter
      53  RTC_SmoothCalibConfig
      19  RTC_StructInit
      47  RTC_SynchroShiftConfig
      20  RTC_TamperCmd
       9  RTC_TamperFilterConfig
      21  RTC_TamperLevelConfig
       9  RTC_TamperPinsPrechargeDuration
       9  RTC_TamperSamplingFreqConfig
       8  RTC_TimeStructInit
      32  RTC_WaitForSynchro
      29  RTC_WakeUpClockConfig
      40  RTC_WakeUpCmd
      11  RTC_WriteProtectionCmd

 
 2 048 bytes in section .near_func.text
 
 2 048 bytes of CODE memory

Errors: none
Warnings: none
