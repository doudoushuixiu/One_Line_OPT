###############################################################################
#
# IAR C/C++ Compiler V2.10.2.149 for STM8                 09/Jun/2015  11:00:14
# Copyright 2010-2014 IAR Systems AB.
#
#    Source file  =  
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\main.c
#    Command line =  
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\main.c
#        -e -Ohz --debug --code_model medium --data_model medium -o
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\relase\Obj\
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\stm8\LIB\dlstm8mmn.h" -D USE_STM8L1526_EVAL -D STM8L05X_LD_VL -lC
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\relase\List\
#        -lA
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\relase\List\
#        -I
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\..\
#        -I
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\..\..\..\Libraries\STM8L15x_StdPeriph_Driver\inc\
#        -I
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\..\..\..\Utilities\STM8_EVAL\
#        -I
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\..\..\..\Utilities\STM8_EVAL\STM8L1526_EVAL\
#        -I
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\..\..\..\Utilities\STM8_EVAL\Common\
#        -I
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\..\..\..\Utilities\Misc\
#        --require_prototypes --vregs 16
#    List file    =  
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\relase\List\main.lst
#    Object file  =  
#        C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\EWSTM8\relase\Obj\main.o
#
###############################################################################

C:\Users\THINK\Documents\GitHub\FTT-TwoLine-Operater\STM8L051\Project\main_code\main.c
      1          /**                               **
      2                  433Mhz CC1101 Receiver
      3                       Xu jiawei
      4          **                                **/
      5          
      6          #include "stm8l15x.h"
      7          #include "stm8l15x_clk.h"
      8          #include "stm8l15x_gpio.h" 
      9          //#include  <math.h>
     10          
     11          //设备ID 为     43 20 05 15
     12          #define  DEVICE_ID_4  0x15
     13          #define  DEVICE_ID_3  0x05
     14          #define  DEVICE_ID_2  0x20
     15          #define  DEVICE_ID_1  0x43
     16          #define  DEVICE_TYPE  0x21  //双路执行器设备类型码
     17          
     18          #define  AI           0x10
     19          #define  AO           0x30
     20          #define  BI           0x50
     21          #define  BO           0x70
     22          #define  ABIO_TOOGLE  0x20
     23          
     24          
     25          #define  A_LINE1      0x11
     26          #define  B_LINE1      0x12
     27          #define  A_LINE2      0x13
     28          #define  B_LINE2      0x14
     29          
     30          #define  LINE_1       0x16
     31          #define  LINE_2       0x17
     32          
     33          #define  ABIO_TOOGLE_LINE1 0x18
     34          #define  ABIO_TOOGLE_LINE2 0x19
     35          
     36          #define  INT8U    unsigned char
     37          #define  INT16U   unsigned int
     38          #define  uclong   unsigned long
     39          #define  ON       0x11
     40          #define  OFF      0x10
     41          
     42          #define  FLAG_ON                      0x11
     43          #define  RECEIVE_DATA_LENGTH          0x21
     44          
     45          #define  FINDINFLASH_FAIL             0x77      //查找ID失败返回值
     46          #define  MAXLEARNNUM                  10        //ID最大学习数量
     47          
     48          #define  IDSTARTADDRESS               0x1010    //第一个ID在Flash中记录的开始位置
     49          #define  IFFIRSTPOWERNUMADRESS        0x1002    //判断是否第一次开机的标识数在flash中位置
     50          #define  IDCOUNTADD                   0x1003    //已经学习到的ID的数量
     51          #define  NEWIDADDRESSINFLASH_PART_1   0x1005    //新ID在Flash中记录的开始位置需要保存
     52          #define  NEWIDADDRESSINFLASH_PART_2   0x1006  
     53          
     54          /***********  SPI IO口宏定义  ************/
     55          #define  MISO_PORT         GPIOB                                                                                                        
     56          #define  MOSI_PORT         GPIOB
     57          #define  SCK_PORT          GPIOB
     58          #define  CSN_PORT          GPIOB
     59          #define  MISO_PIN          GPIO_Pin_4      //GPIO_Pin_7           
     60          #define  MOSI_PIN          GPIO_Pin_6
     61          #define  SCK_PIN           GPIO_Pin_5
     62          #define  CSN_PIN           GPIO_Pin_2
     63          
     64          #define  MISO_INPUT        GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_4)
     65          #define  MOSI_1            GPIO_SetBits   (MOSI_PORT,MOSI_PIN)
     66          #define  MOSI_0            GPIO_ResetBits (MOSI_PORT,MOSI_PIN)  
     67          #define  SCK_1             GPIO_SetBits   (SCK_PORT,SCK_PIN)
     68          #define  SCK_0             GPIO_ResetBits (SCK_PORT,SCK_PIN)      
     69          #define  CSN_1             GPIO_SetBits   (CSN_PORT,CSN_PIN)
     70          #define  CSN_0             GPIO_ResetBits (CSN_PORT,CSN_PIN)
     71          
     72          /***********  LED IO口宏定义  ************/
     73          #define  LED2_GREEN_PORT   GPIOC 
     74          #define  LED2_BLUE_PORT    GPIOB
     75          #define  LED2_RED_PORT     GPIOC
     76          #define  LED1_GREEN_PORT   GPIOA
     77          #define  LED1_BLUE_PORT    GPIOA
     78          #define  LED1_RED_PORT     GPIOA
     79          
     80          #define  LED2_GREEN_PIN    GPIO_Pin_6
     81          #define  LED2_BLUE_PIN     GPIO_Pin_1
     82          #define  LED2_RED_PIN      GPIO_Pin_5
     83          #define  LED1_GREEN_PIN    GPIO_Pin_2
     84          #define  LED1_BLUE_PIN     GPIO_Pin_0
     85          #define  LED1_RED_PIN      GPIO_Pin_3
     86          
     87          #define  LED1_GREEN        GPIO_SetBits(LED1_GREEN_PORT,LED1_GREEN_PIN);   
     88          #define  LED1_BLUE         GPIO_SetBits(LED1_BLUE_PORT ,LED1_BLUE_PIN );    
     89          #define  LED1_RED          GPIO_SetBits(LED1_RED_PORT  ,LED1_RED_PIN  );
     90          #define  LED2_GREEN        GPIO_SetBits(LED2_GREEN_PORT,LED2_GREEN_PIN);
     91          #define  LED2_BLUE         GPIO_SetBits(LED2_BLUE_PORT ,LED2_BLUE_PIN );
     92          #define  LED2_RED          GPIO_SetBits(LED2_RED_PORT  ,LED2_RED_PIN  );
     93          
     94          /***********  按键 IO口 宏定义  ************/
     95          #define  KEY1_PORT         GPIOD
     96          #define  KEY2_PORT         GPIOB
     97          #define  KEY1_PIN          GPIO_Pin_0
     98          #define  KEY2_PIN          GPIO_Pin_0 
     99          #define  KEY1_INPUT        GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_0)    //按键1  
    100          #define  KEY2_INPUT        GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_7)    //按键2 
    101          
    102          /***********  继电器操作 宏定义  ************/
    103          #define  LINE1_PORT        GPIOB
    104          #define  LINE2_PORT        GPIOC
    105          #define  LINE1_PIN         GPIO_Pin_7   
    106          #define  LINE2_PIN         GPIO_Pin_4
    107          /* 继电器操作 */
    108          #define  OPEN_LINE1        GPIO_SetBits  (LINE1_PORT,  LINE1_PIN)
    109          #define  CLOSE_LINE1       GPIO_ResetBits(LINE1_PORT,  LINE1_PIN)
    110          #define  TOOGLE_LINE1      GPIO_ToggleBits(LINE1_PORT, LINE1_PIN);
    111          
    112          #define  OPEN_LINE2        GPIO_SetBits  (LINE2_PORT,  LINE2_PIN)
    113          #define  CLOSE_LINE2       GPIO_ResetBits(LINE2_PORT,  LINE2_PIN)
    114          #define  TOOGLE_LINE2      GPIO_ToggleBits(LINE2_PORT, LINE2_PIN);
    115            
    116          
    117          /* 函数声明区域 */
    118          INT8U  SpiTxRxByte(INT8U dat);
    119          void   Reset_CC1100(void); 
    120          void   halSpiWriteReg(INT8U addr, INT8U value);
    121          void   halSpiWriteBurstReg(INT8U addr, INT8U *buffer, INT8U count);
    122          void   halSpiStrobe(INT8U strobe);
    123          INT8U  halSpiReadReg(INT8U addr);
    124          void   halSpiReadBurstReg(INT8U addr, INT8U *buffer, INT8U count);
    125          INT8U  halSpiReadStatus(INT8U addr);
    126          void   RadioSettings(void);
    127          INT8U  halRfReceivePacket(INT8U *rxBuffer, INT8U *length);
    128          void   halRfSendPacket(INT8U *txBuffer, INT8U size);
    129          
    130          void   delay(uclong s);
    131          void   InitAllGpio(void);
    132          
    133          void   delay(uclong s);
    134          void   InitAllGpio(void);
    135          void   InitRegister(void);
    136          void   FirstPower(void);
    137          INT8U  FindIdInFlash(INT8U ID_1,INT8U ID_2,INT8U ID_3,INT8U ID_4);
    138          void   ReadIdInFlash(void);
    139          void   WriteIdInFlash(INT8U ID_Part1,INT8U ID_Part2,INT8U ID_Part3,INT8U ID_Part4);
    140          void   ClearFlash(void);
    141          void   Led1_Off(void);
    142          void   Led2_Off(void);
    143          void   Key1_Function(void);
    144          void   Key2_Function(void);
    145          void   Radio_Recive(void);
    146          void   Auto_Exit_LearnMode_Function(void);
    147          void   LearnMode_Function(void);
    148          void   WriteKeyOperationInFlash(INT8U ABIO_Line,INT8U Adress);
    149          void   SaveInfoInFlash(void);
    150          INT8U  CalculateRssi(INT8U RSSI_dec);
    151          void   CommonMode_OperateLine(INT8U Key_num,INT8U AdressOfData);
    152          void   timer2_delay(uclong  time);
    153          void   Reply_RequestFlashData(INT8U AdressOfData,INT8U Master_Id_1,INT8U Master_Id_2,INT8U Master_Id_3,INT8U Master_Id_4);
    154          void   ControlByAirLearn_NewWriteInFlash(INT8U data1,INT8U data2,INT8U data3,INT8U data4,INT8U data5,INT8U Line ,INT8U LearnedIdNum);
    155          void   UpdateDatasAdressInFlash(INT8U NumOfDeleteData); 
    156          void   Broadcast_info(void);
    157          void   length6function(void);
    158          void   length7function(void);
    159          void   length10function(void);
    160          void   length5function(void);
    161          void   length20function(void);
    162          void   reply_broadcast(void);
    163          
    164          
    165          /***********  系统参数定义区  **********/
    166          

   \                                 In section .near.bss, align 1
    167          INT8U  receiveflag = 0;                       //报文接收中断标识
   \                     receiveflag:
   \   000000              DS8 1

   \                                 In section .near.bss, align 1
    168          INT8U  firstpower  = 0;                       //第一次开机标识
   \                     firstpower:
   \   000000              DS8 1
    169          

   \                                 In section .near.bss, align 1
    170          INT8U  Key1_InterruptPushflag  = 0;           //按键1  中断标识
   \                     Key1_InterruptPushflag:
   \   000000              DS8 1

   \                                 In section .near.bss, align 1
    171          INT8U  Key2_InterruptPushflag  = 0;           //按键2  中断标识
   \                     Key2_InterruptPushflag:
   \   000000              DS8 1

   \                                 In section .near.bss, align 1
    172          INT8U  Key1_Short_Pushed       = 0;           //确认按下KEY1--短按 标识
   \                     Key1_Short_Pushed:
   \   000000              DS8 1

   \                                 In section .near.bss, align 1
    173          INT8U  Key2_Short_Pushed       = 0;           //确认按下KEY2--短按 标识
   \                     Key2_Short_Pushed:
   \   000000              DS8 1

   \                                 In section .near.bss, align 1
    174          uclong key2_time_count         ;              //按键2 计时 
   \                     key2_time_count:
   \   000000              DS8 4

   \                                 In section .near.bss, align 1
    175          uclong key1_time_count         ;              //按键1 计时
   \                     key1_time_count:
   \   000000              DS8 4
    176          

   \                                 In section .near.data, align 1
    177          INT8U  learn_mode          = OFF;             //判断是否处于学习模式的标识
   \                     learn_mode:
   \   000000 10           DC8 16
    178          

   \                                 In section .near.bss, align 1
    179          uclong auto_exit_time      = 0;               //自动退出学习模式 计时
   \                     auto_exit_time:
   \   000000              DS8 4

   \                                 In section .near.bss, align 1
    180          INT8U  led_blink_time      = 0;               //LED闪烁计时
   \                     led_blink_time:
   \   000000              DS8 1

   \                                 In section .near.bss, align 1
    181          uclong WaitForConfirm_time = 0;               //学习模式确认时间计时
   \                     WaitForConfirm_time:
   \   000000              DS8 4

   \                                 In section .near.data, align 1
    182          INT8U  Choose_Line         = 1;               //学习模式下通道选择 --  1：Line1  2：Line2
   \                     Choose_Line:
   \   000000 01           DC8 1

   \                                 In section .near.bss, align 1
    183          uclong timer2_delay_time   = 0;
   \                     timer2_delay_time:
   \   000000              DS8 4
    184          

   \                                 In section .near.bss, align 1
    185          INT8U  Public_learned_ID_num = 0;             //已经学习到的ID的数量
   \                     Public_learned_ID_num:
   \   000000              DS8 1

   \                                 In section .near.data, align 1
    186          INT16U IdStartAddress = IDSTARTADDRESS;       //新开关的ID将被记录到Flash中，IdStartAddres为开始存储的起始地址
   \                     IdStartAddress:
   \   000000 1010         DC16 4112
    187          
    188          //接收报文函数中使用

   \                                 In section .near.bss, align 1
    189          INT8U Radio_Data[RECEIVE_DATA_LENGTH];                         //存放接收到的数据
   \                     Radio_Data:
   \   000000              DS8 33
    190          //INT8U receive_data_leng = RECEIVE_DATA_LENGTH;               //定义接收报文长度 最大值  

   \                                 In section .near.bss, align 1
    191          INT8U receive_radio_length     = 0;           //接收报文函数返回的报文长度
   \                     receive_radio_length:
   \   000000              DS8 1

   \                                 In section .near.bss, align 1
    192          INT8U FindIdInFlash_return_num = 0;           //接收FindIdInFlash（）函数的返回值，返回值为 ID_num
   \                     FindIdInFlash_return_num:
   \   000000              DS8 1

   \                                 In section .near.bss, align 1
    193          INT8U IdNum                    = 0;
   \                     IdNum:
   \   000000              DS8 1

   \                                 In section .near.data, align 1
    194          INT8U LearnModeWaitForConfirm  = OFF;         //学习模式中等待确认
   \                     LearnModeWaitForConfirm:
   \   000000 10           DC8 16
    195          

   \                                 In section .near.data, align 1
    196          INT8U  Radio_Can_Operated  = 1;               //接收到报文之后已经执行了操作
   \                     Radio_Can_Operated:
   \   000000 01           DC8 1

   \                                 In section .near.bss, align 1
    197          uclong timer3_Operate_time = 0;               //计算开关送两个信号的处理时间
   \                     timer3_Operate_time:
   \   000000              DS8 4
    198          

   \                                 In section .near.data, align 1
    199          INT8U  Return_FindInFlash = FINDINFLASH_FAIL;
   \                     Return_FindInFlash:
   \   000000 77           DC8 119

   \                                 In section .near.bss, align 1
    200          INT8U  clear_num = 0;
   \                     clear_num:
   \   000000              DS8 1

   \                                 In section .near.bss, align 1
    201          INT8U  led_flash = 0;
   \                     led_flash:
   \   000000              DS8 1
    202          

   \                                 In section .near.bss, align 1
    203          INT8U  check_key1 = 0;
   \                     check_key1:
   \   000000              DS8 1

   \                                 In section .near.bss, align 1
    204          INT8U  check_key2 = 0;
   \                     check_key2:
   \   000000              DS8 1
    205          

   \                                 In section .near.bss, align 1
    206          INT8U  timer2_need_delay = 0;
   \                     timer2_need_delay:
   \   000000              DS8 1

   \                                 In section .near.bss, align 1
    207          INT8U  rtc_flag = 0;
   \                     rtc_flag:
   \   000000              DS8 1
    208          
    209          
    210          /* 无线报文结构体 */
    211          struct Radio{          
    212            INT8U Radio_type;                        //设备类型 -- 0x7(双路执行器)  0x3(远程学习接口)
    213            INT8U Id_part_1;                          //ID
    214            INT8U Id_part_2;
    215            INT8U Id_part_3;
    216            INT8U Id_part_4;
    217            INT8U status;                             //报文状态
    218            INT8U Data;                               //数据
    219          };

   \                                 In section .near.bss, align 1
    220          struct Radio AllRadio[MAXLEARNNUM];         //初始化全局变量，用于将Flash中数据移植到本地
   \                     AllRadio:
   \   000000              DS8 70
    221          
    222          /* 开关按键功能结构体 */     
    223          struct ABIO{          
    224            INT8U AI_Line1;                       
    225            INT8U AO_Line1;                         
    226            INT8U BI_Line1;
    227            INT8U BO_Line1;
    228            INT8U TOOGLE_Line1;
    229            
    230            INT8U AI_Line2;                       
    231            INT8U AO_Line2;                         
    232            INT8U BI_Line2;
    233            INT8U BO_Line2;
    234            INT8U TOOGLE_Line2;  
    235          };

   \                                 In section .near.bss, align 1
    236          struct ABIO ABIO_Function[MAXLEARNNUM];    
   \                     ABIO_Function:
   \   000000              DS8 100
    237          
    238          

   \                                 In section .far_func.text, align 1
    239          void delay(uclong  s)
    240          {
   \                     delay:
   \   000000 8D ......    CALLF     L:?mov_l1_l0
    241              uclong i;
    242              for(i=0; i<s; i++);
   \   000004 5F           CLRW      X
   \   000005 BF ..        LDW       S:?w1, X
   \   000007 BF ..        LDW       S:?w0, X
   \   000009 20 04        JRA       L:??delay_0
   \                     ??delay_1:
   \   00000B 8D ......    CALLF     L:?inc32_l0_l0
   \                     ??delay_0:
   \   00000F 8D ......    CALLF     L:?ucmp32_c_l0_l1
   \   000013 25 F6        JRC       L:??delay_1
    243              for(i=0; i<s; i++);
   \   000015 5F           CLRW      X
   \   000016 BF ..        LDW       S:?w1, X
   \   000018 BF ..        LDW       S:?w0, X
   \   00001A 20 04        JRA       L:??delay_2
   \                     ??delay_3:
   \   00001C 8D ......    CALLF     L:?inc32_l0_l0
   \                     ??delay_2:
   \   000020 8D ......    CALLF     L:?ucmp32_c_l0_l1
   \   000024 25 F6        JRC       L:??delay_3
    244          }
   \   000026 87           RETF
    245          
    246          
    247          /**
    248          @function：Timer2 计时    
    249          总计时为 1ms * time 
    250          **/

   \                                 In section .far_func.text, align 1, keep-with-next
    251          void timer2_delay(uclong  time)  
    252          {
   \                     timer2_delay:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_w6
   \   000008 8D ......    CALLF     L:?mov_l2_l0
    253              uclong error_out = 0;
    254              timer2_need_delay = 1;
   \   00000C 35 01 ....   MOV       L:timer2_need_delay, #0x1
    255              timer2_delay_time  = 0;    //计数器清空
   \   000010 5F           CLRW      X
   \   000011 CF ....      LDW       L:timer2_delay_time, X
   \   000014 CF ....      LDW       L:timer2_delay_time + 2, X
    256              TIM2_Cmd(ENABLE);
   \   000017 A6 01        LD        A, #0x1
   \   000019 8D ......    CALLF     TIM2_Cmd
   \   00001D AE EA61      LDW       X, #0xea61
   \   000020 BF ..        LDW       S:?w6, X
    257              do
    258              {
    259                  IWDG_ReloadCounter();    //喂狗
   \                     ??timer2_delay_0:
   \   000022 8D ......    CALLF     IWDG_ReloadCounter
    260                  error_out++;
    261                  if(error_out > 60000)
   \   000026 BE ..        LDW       X, S:?w6
   \   000028 5A           DECW      X
   \   000029 BF ..        LDW       S:?w6, X
   \   00002B 27 11        JREQ      L:??timer2_delay_1
    262                  { break;}
    263              }while(timer2_delay_time  < time);
   \   00002D AE ....      LDW       X, #timer2_delay_time
   \   000030 8D ......    CALLF     L:?load32_l0_0x
   \   000034 8D ......    CALLF     L:?mov_l1_l2
   \   000038 8D ......    CALLF     L:?ucmp32_c_l0_l1
   \   00003C 25 E4        JRC       L:??timer2_delay_0
    264                
    265              TIM2_Cmd(DISABLE);
   \                     ??timer2_delay_1:
   \   00003E 4F           CLR       A
   \   00003F 8D ......    CALLF     TIM2_Cmd
    266              
    267              timer2_need_delay = 0;
   \   000043 725F ....    CLR       L:timer2_need_delay
    268              timer2_delay_time  = 0;
   \   000047 5F           CLRW      X
   \   000048 CF ....      LDW       L:timer2_delay_time, X
   \   00004B CF ....      LDW       L:timer2_delay_time + 2, X
    269          }
   \   00004E AC ......    JPF       L:?epilogue_l2_w6
    270          
    271          /**
    272          @function：关闭LED1 
    273          **/

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000 A6 01        LD        A, #0x1
   \   000002              REQUIRE ??Subroutine113_0
   \   000002              ;               // Fall through to label ??Subroutine113_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine113_0:
   \   000000 AE 5000      LDW       X, #0x5000
   \   000003 AC ......    JPF       GPIO_ResetBits

   \                                 In section .far_func.text, align 1, keep-with-next
    274          void  Led1_Off(void)
    275          {
    276              GPIO_ResetBits(LED1_GREEN_PORT,LED1_GREEN_PIN);
   \                     Led1_Off:
   \   000000 A6 04        LD        A, #0x4
   \   000002 8D ......    CALLF     ??Subroutine113_0
    277              GPIO_ResetBits(LED1_BLUE_PORT,LED1_BLUE_PIN); 
   \                     ??CrossCallReturnLabel_304:
   \   000006 8D ......    CALLF     ?Subroutine8
    278              GPIO_ResetBits(LED1_RED_PORT ,LED1_RED_PIN);
   \                     ??CrossCallReturnLabel_305:
   \   00000A A6 08        LD        A, #0x8
   \   00000C AE 5000      LDW       X, #0x5000
   \   00000F AC ......    JPF       GPIO_ResetBits
    279          }
    280          /**
    281          @function：关闭LED2 
    282          **/

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine110_0:
   \   000000 8D ......    CALLF     ??Subroutine111_0
   \                     ??CrossCallReturnLabel_294:
   \   000004 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine111_0:
   \   000000 AE 5005      LDW       X, #0x5005
   \   000003 AC ......    JPF       GPIO_ResetBits

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000 A6 40        LD        A, #0x40
   \   000002              REQUIRE ??Subroutine112_0
   \   000002              ;               // Fall through to label ??Subroutine112_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine112_0:
   \   000000 8D ......    CALLF     ?Subroutine68
   \                     ??CrossCallReturnLabel_302:
   \   000004 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000 AE 500A      LDW       X, #0x500a
   \   000003 AC ......    JPF       GPIO_ResetBits

   \                                 In section .far_func.text, align 1, keep-with-next
    283          void  Led2_Off(void)
    284          {
    285              GPIO_ResetBits(LED2_GREEN_PORT,LED2_GREEN_PIN);
   \                     Led2_Off:
   \   000000 8D ......    CALLF     ?Subroutine22
    286              GPIO_ResetBits(LED2_BLUE_PORT,LED2_BLUE_PIN); 
   \                     ??CrossCallReturnLabel_299:
   \   000004 A6 02        LD        A, #0x2
   \   000006 8D ......    CALLF     ??Subroutine110_0
    287              GPIO_ResetBits(LED2_RED_PORT ,LED2_RED_PIN);
   \                     ??CrossCallReturnLabel_293:
   \   00000A A6 20        LD        A, #0x20
   \   00000C AE 500A      LDW       X, #0x500a
   \   00000F AC ......    JPF       GPIO_ResetBits
    288          }
    289          
    290          /**
    291          @function：计算RSSI值 
    292          **/

   \                                 In section .far_func.text, align 1, keep-with-next
    293          INT8U CalculateRssi(INT8U RSSI_dec)
    294          {
    295          return 0;
   \                     CalculateRssi:
   \   000000 4F           CLR       A
   \   000001 87           RETF
    296          }
    297          
    298          /**
    299          @function：初始化IO口  
    300          **/

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine104_0:
   \   000000 AE 500A      LDW       X, #0x500a
   \   000003 AC ......    JPF       GPIO_SetBits

   \                                 In section .far_func.text, align 1, keep-with-next
    301          void InitAllGpio(void)  
    302          { 
    303              /*SPI初始化*/
    304              GPIO_Init(GPIOB,     GPIO_Pin_4,GPIO_Mode_In_PU_No_IT);           // MISO_PIN        
   \                     InitAllGpio:
   \   000000 35 40 ....   MOV       S:?b0, #0x40
   \   000004 A6 10        LD        A, #0x10
   \   000006 8D ......    CALLF     ?Subroutine41
   \                     ??CrossCallReturnLabel_74:
   \   00000A A6 40        LD        A, #0x40
   \   00000C 8D ......    CALLF     ?Subroutine41
   \                     ??CrossCallReturnLabel_75:
   \   000010 A6 20        LD        A, #0x20
   \   000012 8D ......    CALLF     ?Subroutine41
    305              GPIO_Init(MOSI_PORT, MOSI_PIN,GPIO_Mode_Out_PP_High_Fast);        // MOSI_PIN
    306              GPIO_Init(SCK_PORT,  SCK_PIN,GPIO_Mode_Out_PP_High_Fast);         // SCK_PIN
    307              GPIO_Init(CSN_PORT,  CSN_PIN,GPIO_Mode_Out_PP_High_Fast);         // CSN_PIN
   \                     ??CrossCallReturnLabel_76:
   \   000016 A6 04        LD        A, #0x4
   \   000018 8D ......    CALLF     ?Subroutine44
    308              /*GDO0初始化*/
    309              GPIO_Init(GPIOB, GPIO_Pin_3,GPIO_Mode_In_FL_IT);
   \                     ??CrossCallReturnLabel_79:
   \   00001C 35 20 ....   MOV       S:?b0, #0x20
   \   000020 A6 08        LD        A, #0x8
   \   000022 8D ......    CALLF     ?Subroutine43
   \                     ??CrossCallReturnLabel_77:
   \   000026 A6 06        LD        A, #0x6
   \   000028 8D ......    CALLF     EXTI_SetPinSensitivity
    310              EXTI_SetPinSensitivity(EXTI_Pin_3, EXTI_Trigger_Falling); 
    311              /*按键初始化*/
    312              GPIO_Init(KEY1_PORT, KEY1_PIN,GPIO_Mode_In_FL_IT);
   \   00002C 35 20 ....   MOV       S:?b0, #0x20
   \   000030 A6 01        LD        A, #0x1
   \   000032 AE 500F      LDW       X, #0x500f
   \   000035 8D ......    CALLF     GPIO_Init
    313              GPIO_Init(KEY2_PORT, KEY2_PIN,GPIO_Mode_In_FL_IT);                                    
   \   000039 35 20 ....   MOV       S:?b0, #0x20
   \   00003D A6 01        LD        A, #0x1
   \   00003F 8D ......    CALLF     ?Subroutine43
    314              /*按键中断*/
    315              EXTI_SetPinSensitivity(EXTI_Pin_0, EXTI_Trigger_Falling);
   \                     ??CrossCallReturnLabel_78:
   \   000043 4F           CLR       A
   \   000044 8D ......    CALLF     EXTI_SetPinSensitivity
    316              EXTI_SetPinSensitivity(EXTI_Pin_3, EXTI_Trigger_Falling);       
   \   000048 35 02 ....   MOV       S:?b0, #0x2
   \   00004C A6 06        LD        A, #0x6
   \   00004E 8D ......    CALLF     EXTI_SetPinSensitivity
    317              /*三色LED的IO初始化*/
    318              //LED1
    319              GPIO_Init(LED1_GREEN_PORT, LED1_GREEN_PIN,GPIO_Mode_Out_PP_Low_Slow);      
   \   000052 35 C0 ....   MOV       S:?b0, #0xc0
   \   000056 A6 04        LD        A, #0x4
   \   000058 8D ......    CALLF     ?Subroutine4
    320              GPIO_ResetBits(LED1_GREEN_PORT, LED1_GREEN_PIN);
   \                     ??CrossCallReturnLabel_7:
   \   00005C A6 04        LD        A, #0x4
   \   00005E 8D ......    CALLF     ?Subroutine7
    321              GPIO_Init(LED1_RED_PORT, LED1_RED_PIN,GPIO_Mode_Out_PP_Low_Slow);
   \                     ??CrossCallReturnLabel_10:
   \   000062 A6 08        LD        A, #0x8
   \   000064 8D ......    CALLF     ?Subroutine4
    322              GPIO_ResetBits(LED1_RED_PORT, LED1_RED_PIN);
   \                     ??CrossCallReturnLabel_6:
   \   000068 A6 08        LD        A, #0x8
   \   00006A 8D ......    CALLF     ?Subroutine7
    323              GPIO_Init(LED1_BLUE_PORT, LED1_BLUE_PIN,GPIO_Mode_Out_PP_Low_Slow); 
   \                     ??CrossCallReturnLabel_11:
   \   00006E A6 01        LD        A, #0x1
   \   000070 8D ......    CALLF     ?Subroutine4
    324              GPIO_ResetBits(LED1_BLUE_PORT, LED1_BLUE_PIN);
   \                     ??CrossCallReturnLabel_5:
   \   000074 8D ......    CALLF     ?Subroutine8
    325              //LED2
    326              GPIO_Init(LED2_GREEN_PORT, LED2_GREEN_PIN,GPIO_Mode_Out_PP_High_Fast);      
   \                     ??CrossCallReturnLabel_306:
   \   000078 35 F0 ....   MOV       S:?b0, #0xf0
   \   00007C A6 40        LD        A, #0x40
   \   00007E 8D ......    CALLF     ?Subroutine16
    327              GPIO_ResetBits(LED2_GREEN_PORT, LED2_GREEN_PIN);
   \                     ??CrossCallReturnLabel_26:
   \   000082 8D ......    CALLF     ?Subroutine22
    328              GPIO_Init(LED2_RED_PORT, LED2_RED_PIN,GPIO_Mode_Out_PP_High_Fast);
   \                     ??CrossCallReturnLabel_298:
   \   000086 35 F0 ....   MOV       S:?b0, #0xf0
   \   00008A A6 20        LD        A, #0x20
   \   00008C 8D ......    CALLF     ?Subroutine16
    329              GPIO_ResetBits(LED2_RED_PORT, LED2_RED_PIN);
   \                     ??CrossCallReturnLabel_25:
   \   000090 A6 20        LD        A, #0x20
   \   000092 8D ......    CALLF     ?Subroutine20
   \                     ??CrossCallReturnLabel_32:
   \   000096 8D ......    CALLF     ?Subroutine44
    330              GPIO_Init(LED2_BLUE_PORT, LED2_BLUE_PIN,GPIO_Mode_Out_PP_High_Fast);
    331              GPIO_ResetBits(LED2_BLUE_PORT, LED2_BLUE_PIN);
   \                     ??CrossCallReturnLabel_80:
   \   00009A A6 02        LD        A, #0x2
   \   00009C 8D ......    CALLF     ??Subroutine110_0
    332              /*继电器IO初始化*/
    333              GPIO_Init(LINE1_PORT,LINE1_PIN,GPIO_Mode_Out_PP_High_Slow);
   \                     ??CrossCallReturnLabel_292:
   \   0000A0 35 D0 ....   MOV       S:?b0, #0xd0
   \   0000A4 A6 80        LD        A, #0x80
   \   0000A6 8D ......    CALLF     ?Subroutine44
    334              GPIO_ResetBits(LINE1_PORT,LINE1_PIN);  
   \                     ??CrossCallReturnLabel_81:
   \   0000AA 8D ......    CALLF     ?Subroutine39
    335              GPIO_Init(LINE2_PORT,LINE2_PIN,GPIO_Mode_Out_PP_High_Slow);
   \                     ??CrossCallReturnLabel_73:
   \   0000AE 35 D0 ....   MOV       S:?b0, #0xd0
   \   0000B2 A6 10        LD        A, #0x10
   \   0000B4 8D ......    CALLF     ?Subroutine16
    336              GPIO_ResetBits(LINE2_PORT,LINE2_PIN);   
   \                     ??CrossCallReturnLabel_24:
   \   0000B8 A6 10        LD        A, #0x10
   \   0000BA 8D ......    CALLF     ?Subroutine20
    337             
    338              /*设置未用到的IO*/
    339              GPIO_Init(GPIOA,GPIO_Pin_1,GPIO_Mode_Out_PP_High_Fast);
   \                     ??CrossCallReturnLabel_33:
   \   0000BE 8D ......    CALLF     ?Subroutine4
    340              GPIO_SetBits(GPIOA,GPIO_Pin_1);
   \                     ??CrossCallReturnLabel_4:
   \   0000C2 A6 02        LD        A, #0x2
   \   0000C4 8D ......    CALLF     ??Subroutine85_0
    341              GPIO_Init(GPIOC,GPIO_Pin_0,GPIO_Mode_Out_PP_High_Fast);
   \                     ??CrossCallReturnLabel_147:
   \   0000C8 35 F0 ....   MOV       S:?b0, #0xf0
   \   0000CC A6 01        LD        A, #0x1
   \   0000CE 8D ......    CALLF     ?Subroutine16
    342              GPIO_SetBits(GPIOC,GPIO_Pin_0);
   \                     ??CrossCallReturnLabel_23:
   \   0000D2 A6 01        LD        A, #0x1
   \   0000D4 8D ......    CALLF     ??Subroutine104_0
    343              GPIO_Init(GPIOC,GPIO_Pin_1,GPIO_Mode_Out_PP_High_Fast);
   \                     ??CrossCallReturnLabel_250:
   \   0000D8 35 F0 ....   MOV       S:?b0, #0xf0
   \   0000DC A6 02        LD        A, #0x2
   \   0000DE 8D ......    CALLF     ?Subroutine16
    344              GPIO_SetBits(GPIOC,GPIO_Pin_1);
   \                     ??CrossCallReturnLabel_22:
   \   0000E2 A6 02        LD        A, #0x2
   \   0000E4 AE 500A      LDW       X, #0x500a
   \   0000E7 AC ......    JPF       GPIO_SetBits
    345              
    346            //  GPIO_Init(GPIOC, GPIO_Pin_6,GPIO_Mode_In_FL_IT);
    347            //  EXTI_SetPinSensitivity(EXTI_Pin_6, EXTI_Trigger_Falling);
    348              
    349          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000 8D ......    CALLF     ?Subroutine63
   \                     ??CrossCallReturnLabel_122:
   \   000004 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000 AE 5005      LDW       X, #0x5005
   \   000003 AC ......    JPF       GPIO_Init

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000 8D ......    CALLF     ?Subroutine63
   \                     ??CrossCallReturnLabel_121:
   \   000004 35 02 ....   MOV       S:?b0, #0x2
   \   000008 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000 8D ......    CALLF     ?Subroutine63
   \                     ??CrossCallReturnLabel_120:
   \   000004 35 F0 ....   MOV       S:?b0, #0xf0
   \   000008 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000 8D ......    CALLF     ?Subroutine62
   \                     ??CrossCallReturnLabel_296:
   \   000004 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000 A6 80        LD        A, #0x80
   \   000002              REQUIRE ??Subroutine111_0
   \   000002              ;               // Fall through to label ??Subroutine111_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000 8D ......    CALLF     ?Subroutine68
   \                     ??CrossCallReturnLabel_301:
   \   000004 35 F0 ....   MOV       S:?b0, #0xf0
   \   000008 A6 02        LD        A, #0x2
   \   00000A 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000 AE 500A      LDW       X, #0x500a
   \   000003 AC ......    JPF       GPIO_Init

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000 AE 5000      LDW       X, #0x5000
   \   000003 8D ......    CALLF     GPIO_ResetBits
   \   000007 35 C0 ....   MOV       S:?b0, #0xc0
   \   00000B 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000 AE 5000      LDW       X, #0x5000
   \   000003 AC ......    JPF       GPIO_Init

   \                                 In section .far_func.text, align 1
   \                     ??Subroutine85_0:
   \   000000 AE 5000      LDW       X, #0x5000
   \   000003 AC ......    JPF       GPIO_SetBits
    350          
    351          /**
    352          @function：配置CLK 及Timer4、2、3定时器 & 看门狗 & SPI
    353          **/

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000 BF ..        LDW       S:?w1, X
   \   000002 5F           CLRW      X
   \   000003 BF ..        LDW       S:?w0, X
   \   000005 AC ......    JPF       delay

   \                                 In section .far_func.text, align 1, keep-with-next
    354          void InitRegister(void)
    355          {  
    356               /** 配置内部时钟 **/
    357               CLK_SYSCLKSourceConfig(CLK_SYSCLKSource_HSI);                //配置内部时钟
   \                     InitRegister:
   \   000000 A6 01        LD        A, #0x1
   \   000002 8D ......    CALLF     CLK_SYSCLKSourceConfig
    358               CLK_SYSCLKDivConfig(CLK_SYSCLKDiv_4);                        //时钟预分频
   \   000006 A6 02        LD        A, #0x2
   \   000008 8D ......    CALLF     CLK_SYSCLKDivConfig
    359               /** 配置Timer4 **/ 
    360               CLK_PeripheralClockConfig(CLK_Peripheral_TIM4, ENABLE);
   \   00000C 35 01 ....   MOV       S:?b0, #0x1
   \   000010 A6 02        LD        A, #0x2
   \   000012 8D ......    CALLF     CLK_PeripheralClockConfig
    361               TIM4_TimeBaseInit(TIM4_Prescaler_512, 50);                 //6.4ms中断      
   \   000016 35 32 ....   MOV       S:?b0, #0x32
   \   00001A A6 09        LD        A, #0x9
   \   00001C 8D ......    CALLF     TIM4_TimeBaseInit
    362               TIM4_ClearFlag(TIM4_FLAG_Update);
   \   000020 A6 01        LD        A, #0x1
   \   000022 8D ......    CALLF     TIM4_ClearFlag
    363               TIM4_ITConfig(TIM4_IT_Update, ENABLE);
   \   000026 8D ......    CALLF     ?Subroutine60
   \                     ??CrossCallReturnLabel_116:
   \   00002A 8D ......    CALLF     TIM4_ITConfig
    364               /** 配置Timer2 **/ 
    365               CLK_PeripheralClockConfig(CLK_Peripheral_TIM2, ENABLE);
   \   00002E 35 01 ....   MOV       S:?b0, #0x1
   \   000032 4F           CLR       A
   \   000033 8D ......    CALLF     CLK_PeripheralClockConfig
    366               TIM2_TimeBaseInit(TIM2_Prescaler_4,TIM2_CounterMode_Up, 1000);   //1ms
   \   000037 AE 03E8      LDW       X, #0x3e8
   \   00003A 3F ..        CLR       S:?b0
   \   00003C A6 02        LD        A, #0x2
   \   00003E 8D ......    CALLF     TIM2_TimeBaseInit
    367               TIM2_ClearFlag(TIM2_FLAG_Update);
   \   000042 5F           CLRW      X
   \   000043 5C           INCW      X
   \   000044 8D ......    CALLF     TIM2_ClearFlag
    368               TIM2_ITConfig(TIM2_IT_Update, ENABLE);            
   \   000048 8D ......    CALLF     ?Subroutine60
   \                     ??CrossCallReturnLabel_117:
   \   00004C 8D ......    CALLF     TIM2_ITConfig
    369               TIM2_Cmd(ENABLE);     
   \   000050 A6 01        LD        A, #0x1
   \   000052 8D ......    CALLF     TIM2_Cmd
    370               /** 配置Timer3 **/ 
    371               CLK_PeripheralClockConfig(CLK_Peripheral_TIM3, ENABLE);
   \   000056 8D ......    CALLF     ?Subroutine60
   \                     ??CrossCallReturnLabel_118:
   \   00005A 8D ......    CALLF     CLK_PeripheralClockConfig
    372               TIM3_TimeBaseInit(TIM3_Prescaler_32,TIM3_CounterMode_Up, 200);  //1.6ms  参数300
   \   00005E AE 00C8      LDW       X, #0xc8
   \   000061 3F ..        CLR       S:?b0
   \   000063 A6 05        LD        A, #0x5
   \   000065 8D ......    CALLF     TIM3_TimeBaseInit
    373               TIM3_ClearFlag(TIM3_FLAG_Update);
   \   000069 5F           CLRW      X
   \   00006A 5C           INCW      X
   \   00006B 8D ......    CALLF     TIM3_ClearFlag
    374               TIM3_ITConfig(TIM3_IT_Update, ENABLE);       
   \   00006F 8D ......    CALLF     ?Subroutine60
   \                     ??CrossCallReturnLabel_119:
   \   000073 8D ......    CALLF     TIM3_ITConfig
    375               /** 配置看门狗 **/   
    376               IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);    //16.384ms
   \   000077 A6 55        LD        A, #0x55
   \   000079 8D ......    CALLF     IWDG_WriteAccessCmd
    377               IWDG_SetPrescaler(IWDG_Prescaler_256);
   \   00007D A6 06        LD        A, #0x6
   \   00007F 8D ......    CALLF     IWDG_SetPrescaler
    378               IWDG_SetReload(0xFE);
   \   000083 A6 FE        LD        A, #0xfe
   \   000085 8D ......    CALLF     IWDG_SetReload
    379               IWDG_ReloadCounter();
   \   000089 8D ......    CALLF     IWDG_ReloadCounter
    380               /** 配置SPI通信 **/ 
    381               CLK_PeripheralClockConfig(CLK_Peripheral_SPI1, ENABLE);
   \   00008D 35 01 ....   MOV       S:?b0, #0x1
   \   000091 A6 04        LD        A, #0x4
   \   000093 8D ......    CALLF     CLK_PeripheralClockConfig
    382               SPI_DeInit( SPI1);
   \   000097 AE 5200      LDW       X, #0x5200
   \   00009A 8D ......    CALLF     SPI_DeInit
    383               SPI_Init( SPI1,SPI_FirstBit_MSB, SPI_BaudRatePrescaler_2,
    384                         SPI_Mode_Master, SPI_CPOL_Low, SPI_CPHA_1Edge,
    385                         SPI_Direction_2Lines_FullDuplex, SPI_NSS_Soft,(uint8_t)0x00 );
   \   00009E 3F ..        CLR       S:?b6
   \   0000A0 35 02 ....   MOV       S:?b5, #0x2
   \   0000A4 3F ..        CLR       S:?b4
   \   0000A6 3F ..        CLR       S:?b3
   \   0000A8 3F ..        CLR       S:?b2
   \   0000AA 35 04 ....   MOV       S:?b1, #0x4
   \   0000AE 3F ..        CLR       S:?b0
   \   0000B0 4F           CLR       A
   \   0000B1 AE 5200      LDW       X, #0x5200
   \   0000B4 8D ......    CALLF     SPI_Init
    386               SPI_Cmd( SPI1,ENABLE );
   \   0000B8 A6 01        LD        A, #0x1
   \   0000BA AE 5200      LDW       X, #0x5200
   \   0000BD 8D ......    CALLF     SPI_Cmd
    387               /**  RTC **/
    388               CLK_RTCClockConfig(CLK_RTCCLKSource_HSI, CLK_RTCCLKDiv_16);    //3.2s
   \   0000C1 35 80 ....   MOV       S:?b0, #0x80
   \   0000C5 A6 02        LD        A, #0x2
   \   0000C7 8D ......    CALLF     CLK_RTCClockConfig
    389               delay(10000);
   \   0000CB AE 2710      LDW       X, #0x2710
   \   0000CE 8D ......    CALLF     ?Subroutine19
    390               CLK_PeripheralClockConfig(CLK_Peripheral_RTC, ENABLE);
   \                     ??CrossCallReturnLabel_29:
   \   0000D2 35 01 ....   MOV       S:?b0, #0x1
   \   0000D6 A6 12        LD        A, #0x12
   \   0000D8 8D ......    CALLF     CLK_PeripheralClockConfig
    391               RTC_WakeUpClockConfig(RTC_WakeUpClock_RTCCLK_Div16);
   \   0000DC 4F           CLR       A
   \   0000DD 8D ......    CALLF     RTC_WakeUpClockConfig
    392               RTC_ITConfig(RTC_IT_WUT, ENABLE);
   \   0000E1 A6 01        LD        A, #0x1
   \   0000E3 AE 0040      LDW       X, #0x40
   \   0000E6 8D ......    CALLF     RTC_ITConfig
    393               RTC_SetWakeUpCounter(50000);
   \   0000EA AE C350      LDW       X, #0xc350
   \   0000ED 8D ......    CALLF     RTC_SetWakeUpCounter
    394               RTC_WakeUpCmd(ENABLE);
   \   0000F1 A6 01        LD        A, #0x1
   \   0000F3 AC ......    JPF       RTC_WakeUpCmd
    395          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000 35 01 ....   MOV       S:?b0, #0x1
   \   000004 A6 01        LD        A, #0x1
   \   000006 87           RETF
    396          
    397          /**
    398          @function：配置CC1100的寄存器 
    399          **/

   \                                 In section .far_func.text, align 1, keep-with-next
    400          void RadioSettings(void) 
    401          {  
   \                     RadioSettings:
   \   000000 52 08        SUB       SP, #0x8
    402              INT8U  PaTabel[8] = {0xC5 ,0xC5 ,0xC5 ,0xC5 ,0xC5 ,0xC5 ,0xC5 ,0xC5};   //10dBm
   \   000002 90AE ....    LDW       Y, #?_0
   \   000006 96           LDW       X, SP
   \   000007 5C           INCW      X
   \   000008 89           PUSHW     X
   \   000009 A6 08        LD        A, #0x8
   \   00000B 8D ......    CALLF     L:?move1616_v_x_y_a
   \   00000F 85           POPW      X
    403              halSpiWriteReg(0x08,0x05);          //PKTCTRL0   
   \   000010 35 05 ....   MOV       S:?b0, #0x5
   \   000014 A6 08        LD        A, #0x8
   \   000016 8D ......    CALLF     halSpiWriteReg
    404              halSpiWriteReg(0x0B,0x0C);          //FSCTRL1   
   \   00001A 35 0C ....   MOV       S:?b0, #0xc
   \   00001E A6 0B        LD        A, #0xb
   \   000020 8D ......    CALLF     halSpiWriteReg
    405              halSpiWriteReg(0x0D,0x10);          //FREQ2
   \   000024 35 10 ....   MOV       S:?b0, #0x10
   \   000028 A6 0D        LD        A, #0xd
   \   00002A 8D ......    CALLF     halSpiWriteReg
    406              halSpiWriteReg(0x0E,0xB1);          //FREQ1
   \   00002E 35 B1 ....   MOV       S:?b0, #0xb1
   \   000032 A6 0E        LD        A, #0xe
   \   000034 8D ......    CALLF     halSpiWriteReg
    407              halSpiWriteReg(0x0F,0x3B);          //FREQ0
   \   000038 35 3B ....   MOV       S:?b0, #0x3b
   \   00003C A6 0F        LD        A, #0xf
   \   00003E 8D ......    CALLF     halSpiWriteReg
    408              halSpiWriteReg(0x10,0x2D);          //MDMCFG4   
   \   000042 35 2D ....   MOV       S:?b0, #0x2d
   \   000046 A6 10        LD        A, #0x10
   \   000048 8D ......    CALLF     halSpiWriteReg
    409              halSpiWriteReg(0x11,0x3B);          //MDMCFG3
   \   00004C 35 3B ....   MOV       S:?b0, #0x3b
   \   000050 A6 11        LD        A, #0x11
   \   000052 8D ......    CALLF     halSpiWriteReg
    410              halSpiWriteReg(0x12,0x13);          //MDMCFG2    0x13 GFSK
   \   000056 35 13 ....   MOV       S:?b0, #0x13
   \   00005A A6 12        LD        A, #0x12
   \   00005C 8D ......    CALLF     halSpiWriteReg
    411              halSpiWriteReg(0x15,0x62);          //DEVIATN      
   \   000060 35 62 ....   MOV       S:?b0, #0x62
   \   000064 A6 15        LD        A, #0x15
   \   000066 8D ......    CALLF     halSpiWriteReg
    412              halSpiWriteReg(0x17,0x3F);          //MCSM1 RX之后保持RX状态
   \   00006A 35 3F ....   MOV       S:?b0, #0x3f
   \   00006E A6 17        LD        A, #0x17
   \   000070 8D ......    CALLF     halSpiWriteReg
    413                
    414              halSpiWriteReg(0x18,0x18);          //MCSM0 18   
   \   000074 35 18 ....   MOV       S:?b0, #0x18
   \   000078 A6 18        LD        A, #0x18
   \   00007A 8D ......    CALLF     halSpiWriteReg
    415              halSpiWriteReg(0x19,0x1D);          //FOCCFG
   \   00007E 35 1D ....   MOV       S:?b0, #0x1d
   \   000082 A6 19        LD        A, #0x19
   \   000084 8D ......    CALLF     halSpiWriteReg
    416              halSpiWriteReg(0x1A,0x1C);          //BSCFG
   \   000088 35 1C ....   MOV       S:?b0, #0x1c
   \   00008C A6 1A        LD        A, #0x1a
   \   00008E 8D ......    CALLF     halSpiWriteReg
    417              halSpiWriteReg(0x1B,0xC7);          //AGCCTRL2
   \   000092 35 C7 ....   MOV       S:?b0, #0xc7
   \   000096 A6 1B        LD        A, #0x1b
   \   000098 8D ......    CALLF     halSpiWriteReg
    418              halSpiWriteReg(0x1C,0x00);          //AGCCTRL1
   \   00009C 3F ..        CLR       S:?b0
   \   00009E A6 1C        LD        A, #0x1c
   \   0000A0 8D ......    CALLF     halSpiWriteReg
    419              halSpiWriteReg(0x1D,0xB0);          //AGCCTRL0
   \   0000A4 35 B0 ....   MOV       S:?b0, #0xb0
   \   0000A8 A6 1D        LD        A, #0x1d
   \   0000AA 8D ......    CALLF     halSpiWriteReg
    420              halSpiWriteReg(0x21,0xB6);          //FREND1 
   \   0000AE 35 B6 ....   MOV       S:?b0, #0xb6
   \   0000B2 A6 21        LD        A, #0x21
   \   0000B4 8D ......    CALLF     halSpiWriteReg
    421              halSpiWriteReg(0x23,0xEA);          //FSCAL3
   \   0000B8 35 EA ....   MOV       S:?b0, #0xea
   \   0000BC A6 23        LD        A, #0x23
   \   0000BE 8D ......    CALLF     halSpiWriteReg
    422              halSpiWriteReg(0x24,0x2A);          //FSCAL2    
   \   0000C2 35 2A ....   MOV       S:?b0, #0x2a
   \   0000C6 A6 24        LD        A, #0x24
   \   0000C8 8D ......    CALLF     halSpiWriteReg
    423              halSpiWriteReg(0x25,0x00);          //FSCAL1
   \   0000CC 3F ..        CLR       S:?b0
   \   0000CE A6 25        LD        A, #0x25
   \   0000D0 8D ......    CALLF     halSpiWriteReg
    424              halSpiWriteReg(0x26,0x1F);          //FSCAL0     
   \   0000D4 35 1F ....   MOV       S:?b0, #0x1f
   \   0000D8 A6 26        LD        A, #0x26
   \   0000DA 8D ......    CALLF     halSpiWriteReg
    425              
    426              halSpiWriteReg(0x02,0x06);          //IOCFG0   
   \   0000DE 35 06 ....   MOV       S:?b0, #0x6
   \   0000E2 A6 02        LD        A, #0x2
   \   0000E4 8D ......    CALLF     halSpiWriteReg
    427             // halSpiWriteReg(0x02,0x0E);          //IOCFG0 
    428              
    429              halSpiWriteBurstReg(0x3E,PaTabel,8);//配置cc1101功率 
   \   0000E8 35 08 ....   MOV       S:?b0, #0x8
   \   0000EC 96           LDW       X, SP
   \   0000ED 5C           INCW      X
   \   0000EE A6 3E        LD        A, #0x3e
   \   0000F0 8D ......    CALLF     halSpiWriteBurstReg
    430          }
   \   0000F4 5B 08        ADD       SP, #0x8
   \   0000F6 87           RETF
    431          

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000 A6 10        LD        A, #0x10
   \   000002              REQUIRE ??Subroutine106_0
   \   000002              ;               // Fall through to label ??Subroutine106_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine106_0:
   \   000000 AE 5005      LDW       X, #0x5005
   \   000003 8D ......    CALLF     GPIO_ReadInputDataBit
   \   000007 A1 00        CP        A, #0x0
   \   000009 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine108_0:
   \   000000 AE 5005      LDW       X, #0x5005
   \   000003 AC ......    JPF       GPIO_SetBits

   \                                 In section .far_func.text, align 1, keep-with-next
    432          INT8U SpiTxRxByte(INT8U dat)
    433          {
   \                     SpiTxRxByte:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 3B ....      PUSH      S:?b10
   \   000007 B7 ..        LD        S:?b10, A
    434              INT8U i,temp;
    435              temp = 0;	
   \   000009 3F ..        CLR       S:?b9
    436              SCK_0 ;
   \   00000B 8D ......    CALLF     ?Subroutine42
    437              for(i=0; i<8; i++)
   \                     ??CrossCallReturnLabel_289:
   \   00000F 35 08 ....   MOV       S:?b8, #0x8
    438              {
    439                  if(dat & 0x80)  
   \                     ??SpiTxRxByte_0:
   \   000013 B6 ..        LD        A, S:?b10
   \   000015 A5 80        BCP       A, #0x80
   \   000017 27 08        JREQ      L:??SpiTxRxByte_1
    440                  {MOSI_1;}
   \   000019 A6 40        LD        A, #0x40
   \   00001B 8D ......    CALLF     ??Subroutine86_0
   \                     ??CrossCallReturnLabel_157:
   \   00001F 20 06        JRA       L:??CrossCallReturnLabel_291
    441                  else 
    442                  {MOSI_0;}
   \                     ??SpiTxRxByte_1:
   \   000021 A6 40        LD        A, #0x40
   \   000023 8D ......    CALLF     ??Subroutine110_0
    443                  dat <<= 1;
   \                     ??CrossCallReturnLabel_291:
   \   000027 B6 ..        LD        A, S:?b10
   \   000029 48           SLL       A
   \   00002A B7 ..        LD        S:?b10, A
    444                  SCK_1;
   \   00002C A6 20        LD        A, #0x20
   \   00002E 8D ......    CALLF     ??Subroutine86_0
    445                  temp <<= 1;
   \                     ??CrossCallReturnLabel_158:
   \   000032 B6 ..        LD        A, S:?b9
   \   000034 48           SLL       A
   \   000035 B7 ..        LD        S:?b9, A
    446                  if(MISO_INPUT)temp++;   
   \   000037 8D ......    CALLF     ?Subroutine40
   \                     ??CrossCallReturnLabel_271:
   \   00003B 27 05        JREQ      L:??SpiTxRxByte_2
   \   00003D B6 ..        LD        A, S:?b9
   \   00003F 4C           INC       A
   \   000040 B7 ..        LD        S:?b9, A
    447                  SCK_0; 
   \                     ??SpiTxRxByte_2:
   \   000042 8D ......    CALLF     ?Subroutine42
    448              }
   \                     ??CrossCallReturnLabel_290:
   \   000046 B6 ..        LD        A, S:?b8
   \   000048 4A           DEC       A
   \   000049 B7 ..        LD        S:?b8, A
   \   00004B 26 C6        JRNE      L:??SpiTxRxByte_0
    449              IWDG->KR = IWDG_KEY_REFRESH;    //喂狗
   \   00004D 35 AA 50E0   MOV       L:0x50e0, #0xaa
    450              return temp;
   \   000051 B6 ..        LD        A, S:?b9
   \   000053 32 ....      POP       S:?b10
   \   000056 AC ......    JPF       L:?epilogue_w4
    451          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000 A6 20        LD        A, #0x20
   \   000002              REQUIRE ??Subroutine110_0
   \   000002              ;               // Fall through to label ??Subroutine110_0

   \                                 In section .far_func.text, align 1
   \                     ??Subroutine86_0:
   \   000000 8D ......    CALLF     ??Subroutine108_0
   \                     ??CrossCallReturnLabel_278:
   \   000004 87           RETF
    452          

   \                                 In section .far_func.text, align 1, keep-with-next
    453          void Reset_CC1100(void) 
    454          {
    455              CSN_0; 
   \                     Reset_CC1100:
   \   000000 8D ......    CALLF     ??Subroutine109_0
    456              SpiTxRxByte(0x30);    
   \                     ??CrossCallReturnLabel_288:
   \   000004 A6 30        LD        A, #0x30
   \   000006 8D ......    CALLF     SpiTxRxByte
    457              CSN_1; 	  		
   \   00000A A6 04        LD        A, #0x4
   \   00000C AE 5005      LDW       X, #0x5005
   \   00000F AC ......    JPF       GPIO_SetBits
    458          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine109_0:
   \   000000 A6 04        LD        A, #0x4
   \   000002 8D ......    CALLF     ??Subroutine111_0
   \                     ??CrossCallReturnLabel_295:
   \   000006 87           RETF
    459          

   \                                 In section .far_func.text, align 1, keep-with-next
    460          void halSpiWriteReg(INT8U addr, INT8U value) 
    461          {   
   \                     halSpiWriteReg:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 B7 ..        LD        S:?b8, A
   \   000006 45 .. ..     MOV       S:?b9, S:?b0
    462              CSN_0;
   \   000009 8D ......    CALLF     ??Subroutine109_0
    463              while(MISO_INPUT);
   \                     ??CrossCallReturnLabel_287:
   \   00000D 8D ......    CALLF     ?Subroutine40
   \                     ??CrossCallReturnLabel_270:
   \   000011 26 FA        JRNE      L:??CrossCallReturnLabel_287
    464              SpiTxRxByte(addr);		
   \   000013 B6 ..        LD        A, S:?b8
   \   000015 8D ......    CALLF     SpiTxRxByte
    465              SpiTxRxByte(value);		
   \   000019 B6 ..        LD        A, S:?b9
   \   00001B 8D ......    CALLF     ?Subroutine6
    466              CSN_1;
    467          }
   \                     ??CrossCallReturnLabel_274:
   \   00001F AC ......    JPF       L:?epilogue_w4

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000 8D ......    CALLF     SpiTxRxByte
   \   000004              REQUIRE ??Subroutine107_0
   \   000004              ;               // Fall through to label ??Subroutine107_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine107_0:
   \   000000 8D ......    CALLF     ?Subroutine61
   \                     ??CrossCallReturnLabel_280:
   \   000004 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000 A6 04        LD        A, #0x4
   \   000002              REQUIRE ??Subroutine108_0
   \   000002              ;               // Fall through to label ??Subroutine108_0
    468          

   \                                 In section .far_func.text, align 1, keep-with-next
    469          void halSpiWriteBurstReg(INT8U addr, INT8U *buffer, INT8U count) 
    470          {
   \                     halSpiWriteBurstReg:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 BF ..        LDW       S:?w4, X
   \   000006 45 .. ..     MOV       S:?b11, S:?b0
    471              INT8U i, temp;
    472              temp = addr | 0x40;
   \   000009 AA 40        OR        A, #0x40
   \   00000B B7 ..        LD        S:?b10, A
    473              CSN_0;
   \   00000D 8D ......    CALLF     ??Subroutine109_0
    474              while(MISO_INPUT);	
   \                     ??CrossCallReturnLabel_286:
   \   000011 8D ......    CALLF     ?Subroutine40
   \                     ??CrossCallReturnLabel_269:
   \   000015 26 FA        JRNE      L:??CrossCallReturnLabel_286
    475              SpiTxRxByte(temp);	
   \   000017 B6 ..        LD        A, S:?b10
   \   000019 8D ......    CALLF     SpiTxRxByte
    476              for (i = 0; i < count; i++)
   \   00001D 3F ..        CLR       S:?b10
   \   00001F 20 10        JRA       L:??halSpiWriteBurstReg_0
    477              {
    478                  SpiTxRxByte(buffer[i]);
   \                     ??halSpiWriteBurstReg_1:
   \   000021 5F           CLRW      X
   \   000022 41           EXG       A, XL
   \   000023 72BB ....    ADDW      X, S:?w4
   \   000027 F6           LD        A, (X)
   \   000028 8D ......    CALLF     SpiTxRxByte
    479              }
   \   00002C B6 ..        LD        A, S:?b10
   \   00002E 4C           INC       A
   \   00002F B7 ..        LD        S:?b10, A
   \                     ??halSpiWriteBurstReg_0:
   \   000031 B6 ..        LD        A, S:?b10
   \   000033 B1 ..        CP        A, S:?b11
   \   000035 25 EA        JRC       L:??halSpiWriteBurstReg_1
    480              CSN_1;
   \   000037 8D ......    CALLF     ??Subroutine107_0
    481          }
   \                     ??CrossCallReturnLabel_276:
   \   00003B AC ......    JPF       L:?epilogue_l2
    482          

   \                                 In section .far_func.text, align 1, keep-with-next
    483          void halSpiStrobe(INT8U strobe) 
    484          {
   \                     halSpiStrobe:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 8D ......    CALLF     ?Subroutine2
    485              CSN_0;
    486              while (MISO_INPUT);
   \                     ??CrossCallReturnLabel_284:
   \   000007 8D ......    CALLF     ?Subroutine40
   \                     ??CrossCallReturnLabel_268:
   \   00000B 26 FA        JRNE      L:??CrossCallReturnLabel_284
    487              SpiTxRxByte(strobe);		
   \   00000D B6 ..        LD        A, S:?b8
   \   00000F 8D ......    CALLF     ?Subroutine6
    488              CSN_1;
    489          }
   \                     ??CrossCallReturnLabel_273:
   \   000013 32 ....      POP       S:?b8
   \   000016 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000 B7 ..        LD        S:?b8, A
   \   000002              REQUIRE ??Subroutine109_0
   \   000002              ;               // Fall through to label ??Subroutine109_0
    490          

   \                                 In section .far_func.text, align 1, keep-with-next
    491          INT8U halSpiReadReg(INT8U addr) 
    492          {
   \                     halSpiReadReg:
   \   000000 3B ....      PUSH      S:?b8
    493              INT8U temp, value;
    494              temp = addr|0x80;
   \   000003 AA 80        OR        A, #0x80
   \   000005 8D ......    CALLF     ?Subroutine2
    495              CSN_0;
    496              while (MISO_INPUT);
   \                     ??CrossCallReturnLabel_283:
   \   000009 8D ......    CALLF     ?Subroutine40
   \                     ??CrossCallReturnLabel_267:
   \   00000D 26 FA        JRNE      L:??CrossCallReturnLabel_283
    497              SpiTxRxByte(temp);
   \   00000F 8D ......    CALLF     ?Subroutine5
    498              value = SpiTxRxByte(0);
    499              CSN_1;
    500              return value;
   \                     ??CrossCallReturnLabel_9:
   \   000013 32 ....      POP       S:?b8
   \   000016 87           RETF
    501          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000 B6 ..        LD        A, S:?b8
   \   000002 8D ......    CALLF     SpiTxRxByte
   \   000006 4F           CLR       A
   \   000007 8D ......    CALLF     SpiTxRxByte
   \   00000B B7 ..        LD        S:?b8, A
   \   00000D 8D ......    CALLF     ?Subroutine61
   \                     ??CrossCallReturnLabel_281:
   \   000011 B6 ..        LD        A, S:?b8
   \   000013 87           RETF
    502          

   \                                 In section .far_func.text, align 1, keep-with-next
    503          void halSpiReadBurstReg(INT8U addr, INT8U *buffer, INT8U count) 
    504          {
   \                     halSpiReadBurstReg:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_w6
   \   000008 BF ..        LDW       S:?w4, X
   \   00000A 45 .. ..     MOV       S:?b13, S:?b0
    505              INT8U i,temp;
    506              temp = addr | 0xC0;		
   \   00000D AA C0        OR        A, #0xc0
   \   00000F B7 ..        LD        S:?b10, A
    507              CSN_0;
   \   000011 8D ......    CALLF     ??Subroutine109_0
    508              while (MISO_INPUT);
   \                     ??CrossCallReturnLabel_285:
   \   000015 8D ......    CALLF     ?Subroutine40
   \                     ??CrossCallReturnLabel_266:
   \   000019 26 FA        JRNE      L:??CrossCallReturnLabel_285
    509              SpiTxRxByte(temp);   
   \   00001B B6 ..        LD        A, S:?b10
   \   00001D 8D ......    CALLF     SpiTxRxByte
    510              for (i = 0; i < count; i++) 
   \   000021 3F ..        CLR       S:?b12
   \   000023 20 14        JRA       L:??halSpiReadBurstReg_0
    511              {
    512                  buffer[i] = SpiTxRxByte(0);
   \                     ??halSpiReadBurstReg_1:
   \   000025 5F           CLRW      X
   \   000026 41           EXG       A, XL
   \   000027 72BB ....    ADDW      X, S:?w4
   \   00002B BF ..        LDW       S:?w5, X
   \   00002D 8D ......    CALLF     SpiTxRxByte
   \   000031 92C7 ..      LD        [S:?w5.w], A
    513              }
   \   000034 B6 ..        LD        A, S:?b12
   \   000036 4C           INC       A
   \   000037 B7 ..        LD        S:?b12, A
   \                     ??halSpiReadBurstReg_0:
   \   000039 B6 ..        LD        A, S:?b12
   \   00003B B1 ..        CP        A, S:?b13
   \   00003D 25 E6        JRC       L:??halSpiReadBurstReg_1
    514              CSN_1;
   \   00003F 8D ......    CALLF     ??Subroutine107_0
    515          }
   \                     ??CrossCallReturnLabel_275:
   \   000043 AC ......    JPF       L:?epilogue_l2_w6
    516          

   \                                 In section .far_func.text, align 1, keep-with-next
    517          INT8U halSpiReadStatus(INT8U addr) 
    518          {
   \                     halSpiReadStatus:
   \   000000 3B ....      PUSH      S:?b8
    519              INT8U value,temp;
    520              temp = addr | 0xC0;		
   \   000003 AA C0        OR        A, #0xc0
   \   000005 8D ......    CALLF     ?Subroutine2
    521              CSN_0;
    522              while (MISO_INPUT);
   \                     ??CrossCallReturnLabel_282:
   \   000009 8D ......    CALLF     ?Subroutine40
   \                     ??CrossCallReturnLabel_265:
   \   00000D 26 FA        JRNE      L:??CrossCallReturnLabel_282
    523              SpiTxRxByte(temp);
   \   00000F 8D ......    CALLF     ?Subroutine5
    524              value = SpiTxRxByte(0);
    525              CSN_1;
   \                     ??CrossCallReturnLabel_8:
   \   000013 32 ....      POP       S:?b8
   \   000016 87           RETF
    526              return value;
    527          }
    528          /************  接收数据包 ******************/

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000 A6 36        LD        A, #0x36
   \   000002 8D ......    CALLF     halSpiStrobe
   \   000006 A6 34        LD        A, #0x34
   \   000008 8D ......    CALLF     halSpiStrobe
   \   00000C              REQUIRE ??Subroutine102_0
   \   00000C              ;               // Fall through to label ??Subroutine102_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine102_0:
   \   000000 8D ......    CALLF     ?Subroutine72
   \                     ??CrossCallReturnLabel_239:
   \   000004 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000 5F           CLRW      X
   \   000001 BF ..        LDW       S:?w0, X
   \   000003 5C           INCW      X
   \   000004 BF ..        LDW       S:?w1, X
   \   000006 AC ......    JPF       timer2_delay

   \                                 In section .far_func.text, align 1, keep-with-next
    529          INT8U halRfReceivePacket(INT8U *rxBuffer, INT8U *length) 
    530          {
   \                     halRfReceivePacket:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 8D ......    CALLF     L:?push_w6
   \   000008 3B ....      PUSH      S:?b10
   \   00000B 52 02        SUB       SP, #0x2
   \   00000D BF ..        LDW       S:?w6, X
   \   00000F 90BF ..      LDW       S:?w4, Y
    531              INT8U status[2];
    532              INT8U packetLength;    
    533              halSpiStrobe(0x34);                    //进入接收状态
   \   000012 A6 34        LD        A, #0x34
   \   000014 8D ......    CALLF     halSpiStrobe
    534              delay(33);                            
   \   000018 AE 0021      LDW       X, #0x21
   \   00001B 8D ......    CALLF     ?Subroutine19
    535              if ((halSpiReadStatus(0x3B) & 0x7F) )  
   \                     ??CrossCallReturnLabel_30:
   \   00001F A6 3B        LD        A, #0x3b
   \   000021 8D ......    CALLF     halSpiReadStatus
   \   000025 A5 7F        BCP       A, #0x7f
   \   000027 27 4F        JREQ      L:??halRfReceivePacket_0
    536              {         
    537                  packetLength = halSpiReadReg(0x3F);
   \   000029 A6 3F        LD        A, #0x3f
   \   00002B 8D ......    CALLF     halSpiReadReg
   \   00002F B7 ..        LD        S:?b10, A
    538                  if (packetLength <= *length+1)       
   \   000031 92C6 ..      LD        A, [S:?w4.w]
   \   000034 5F           CLRW      X
   \   000035 97           LD        XL, A
   \   000036 5C           INCW      X
   \   000037 9093         LDW       Y, X
   \   000039 5F           CLRW      X
   \   00003A 41           EXG       A, XL
   \   00003B B6 ..        LD        A, S:?b10
   \   00003D 41           EXG       A, XL
   \   00003E BF ..        LDW       S:?w0, X
   \   000040 93           LDW       X, Y
   \   000041 B3 ..        CPW       X, S:?w0
   \   000043 2F 2E        JRSLT     L:??halRfReceivePacket_1
    539                  {
    540                      halSpiReadBurstReg(0x3F, rxBuffer, packetLength);  //+1 是为了获取RSSI值
   \   000045 45 .. ..     MOV       S:?b0, S:?b10
   \   000048 BE ..        LDW       X, S:?w6
   \   00004A A6 3F        LD        A, #0x3f
   \   00004C 8D ......    CALLF     halSpiReadBurstReg
    541                      *length = packetLength;				
   \   000050 B6 ..        LD        A, S:?b10
   \   000052 92C7 ..      LD        [S:?w4.w], A
    542                      halSpiReadBurstReg(0x3F, status, 2);  //读出CRC校验位	
   \   000055 35 02 ....   MOV       S:?b0, #0x2
   \   000059 96           LDW       X, SP
   \   00005A 5C           INCW      X
   \   00005B A6 3F        LD        A, #0x3f
   \   00005D 8D ......    CALLF     halSpiReadBurstReg
    543                      halSpiStrobe(0x3A);	                  //清洗接收缓冲区           
   \   000061 A6 3A        LD        A, #0x3a
   \   000063 8D ......    CALLF     halSpiStrobe
    544                      if(status[1] && 0x80)                 //如果检验成功，则返回报文长度
   \   000067 0D 02        TNZ       (0x2,SP)
   \   000069 27 13        JREQ      L:??halRfReceivePacket_2
    545                      {
    546                          halSpiStrobe(0x36);halSpiStrobe(0x34);timer2_delay(1);             //矫正CC1101时钟
   \   00006B 8D ......    CALLF     ?Subroutine15
    547                          return(packetLength);
   \                     ??CrossCallReturnLabel_232:
   \   00006F B6 ..        LD        A, S:?b10
   \   000071 20 10        JRA       L:??halRfReceivePacket_3
    548                      }
    549                      else 
    550                      {
    551                          halSpiStrobe(0x36);halSpiStrobe(0x34);timer2_delay(1);             //矫正CC1101时钟
    552                          return 0;
    553                      }               
    554                  }
    555                  else 
    556                  {         
    557                      *length = packetLength;
   \                     ??halRfReceivePacket_1:
   \   000073 B6 ..        LD        A, S:?b10
   \   000075 92C7 ..      LD        [S:?w4.w], A
    558                      halSpiStrobe(0x3A);
    559                      halSpiStrobe(0x36);halSpiStrobe(0x34);timer2_delay(1);             //矫正CC1101时钟 
    560                      return 0;
    561                  }
    562              }
    563              else
    564              { halSpiStrobe(0x3A);halSpiStrobe(0x36);halSpiStrobe(0x34);timer2_delay(1); } //清洗接收缓冲区
   \                     ??halRfReceivePacket_0:
   \   000078 A6 3A        LD        A, #0x3a
   \   00007A 8D ......    CALLF     halSpiStrobe
   \                     ??halRfReceivePacket_2:
   \   00007E 8D ......    CALLF     ?Subroutine15
    565              return 0;        
   \                     ??CrossCallReturnLabel_233:
   \   000082 4F           CLR       A
   \                     ??halRfReceivePacket_3:
   \   000083 5B 02        ADD       SP, #0x2
   \   000085 32 ....      POP       S:?b10
   \   000088 8D ......    CALLF     L:?pop_w6
   \   00008C AC ......    JPF       L:?epilogue_w4
    566          }
    567          /************  CC1100发送一组数据 ******************/

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine103_0:
   \   000000 8D ......    CALLF     ?Subroutine82
   \                     ??CrossCallReturnLabel_249:
   \   000004 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000 BF ..        LDW       S:?w1, X
   \   000002 5F           CLRW      X
   \   000003 BF ..        LDW       S:?w0, X
   \   000005 AC ......    JPF       timer2_delay

   \                                 In section .far_func.text, align 1, keep-with-next
    568          void halRfSendPacket(INT8U *txBuffer, INT8U size) 
    569          {
   \                     halRfSendPacket:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 3B ....      PUSH      S:?b10
   \   000007 BF ..        LDW       S:?w4, X
   \   000009 B7 ..        LD        S:?b10, A
    570              halSpiWriteReg(0x3F, size);   
   \   00000B 45 .. ..     MOV       S:?b0, S:?b10
   \   00000E A6 3F        LD        A, #0x3f
   \   000010 8D ......    CALLF     halSpiWriteReg
    571              halSpiWriteBurstReg(0x3F, txBuffer, size);	//写入发送数据    
   \   000014 45 .. ..     MOV       S:?b0, S:?b10
   \   000017 BE ..        LDW       X, S:?w4
   \   000019 A6 3F        LD        A, #0x3f
   \   00001B 8D ......    CALLF     halSpiWriteBurstReg
    572              halSpiStrobe(0x35);                         //进入发送模式
   \   00001F A6 35        LD        A, #0x35
   \   000021 8D ......    CALLF     halSpiStrobe
    573              timer2_delay(5);  //5ms
   \   000025 AE 0005      LDW       X, #0x5
   \   000028 8D ......    CALLF     ??Subroutine103_0
    574              halSpiStrobe(0x3B);                        //清空发送区数据
   \                     ??CrossCallReturnLabel_246:
   \   00002C A6 3B        LD        A, #0x3b
   \   00002E 8D ......    CALLF     halSpiStrobe
    575          }
   \   000032 32 ....      POP       S:?b10
   \   000035 AC ......    JPF       L:?epilogue_w4
    576          
    577          
    578          /**
    579          @function：按键Key1处理函数 -- 选择 & 学习 
    580          **/

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000 8D ......    CALLF     Led1_Off
   \   000004 AC ......    JPF       Led2_Off

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000 5F           CLRW      X
   \   000001 CF ....      LDW       L:WaitForConfirm_time, X
   \   000004 CF ....      LDW       L:WaitForConfirm_time + 2, X
   \   000007 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
    581          void  Key1_Function(void)
    582          {      
    583              if(learn_mode == ON)
   \                     Key1_Function:
   \   000000 C6 ....      LD        A, L:learn_mode
   \   000003 A1 11        CP        A, #0x11
   \   000005 26 18        JRNE      L:??Key1_Function_0
    584              {
    585                  if(key1_time_count > 5)
   \   000007 AE ....      LDW       X, #key1_time_count
   \   00000A 8D ......    CALLF     ??Subroutine105_0
   \                     ??CrossCallReturnLabel_261:
   \   00000E 26 05        JRNE      L:??Key1_Function_1
   \   000010 BE ..        LDW       X, S:?w1
   \   000012 A3 0006      CPW       X, #0x6
   \                     ??Key1_Function_1:
   \   000015 25 08        JRC       L:??Key1_Function_0
    586                  {
    587                    Key1_InterruptPushflag  = 0;
   \   000017 725F ....    CLR       L:Key1_InterruptPushflag
    588                    Key1_Short_Pushed = 1;         
   \   00001B 35 01 ....   MOV       L:Key1_Short_Pushed, #0x1
    589                  }
    590              }
    591              if(KEY1_INPUT)
   \                     ??Key1_Function_0:
   \   00001F A6 01        LD        A, #0x1
   \   000021 8D ......    CALLF     ??Subroutine106_0
   \                     ??CrossCallReturnLabel_272:
   \   000025 27 04        JREQ      L:??Key1_Function_2
    592              {
    593                  Key1_InterruptPushflag  = 0;
   \   000027 725F ....    CLR       L:Key1_InterruptPushflag
    594              }
    595              
    596              /** 按键1-长按进入学习模式 **/
    597              if((key1_time_count > 400) && (!Key2_InterruptPushflag) && (learn_mode == OFF) )
   \                     ??Key1_Function_2:
   \   00002B AE ....      LDW       X, #key1_time_count
   \   00002E 8D ......    CALLF     ??Subroutine105_0
   \                     ??CrossCallReturnLabel_262:
   \   000032 26 05        JRNE      L:??Key1_Function_3
   \   000034 BE ..        LDW       X, S:?w1
   \   000036 A3 0191      CPW       X, #0x191
   \                     ??Key1_Function_3:
   \   000039 25 28        JRC       L:??CrossCallReturnLabel_49
   \   00003B C6 ....      LD        A, L:Key2_InterruptPushflag
   \   00003E 26 23        JRNE      L:??CrossCallReturnLabel_49
   \   000040 C6 ....      LD        A, L:learn_mode
   \   000043 A1 10        CP        A, #0x10
   \   000045 26 1C        JRNE      L:??CrossCallReturnLabel_49
    598              {        
    599                  //定时器在按键1中断中开启，至此未关闭 
    600                  Key1_InterruptPushflag = 0;
   \   000047 725F ....    CLR       L:Key1_InterruptPushflag
    601                  Led1_Off(); Led2_Off(); LED1_GREEN; 
   \   00004B 8D ......    CALLF     ?Subroutine32
   \                     ??CrossCallReturnLabel_52:
   \   00004F 8D ......    CALLF     ??Subroutine84_0
    602                  led_blink_time    = 0;
   \                     ??CrossCallReturnLabel_150:
   \   000053 725F ....    CLR       L:led_blink_time
    603                  Key1_Short_Pushed = 0;
   \   000057 8D ......    CALLF     ?Subroutine78
    604                  Key2_Short_Pushed = 0;
    605                  learn_mode          = ON;           //置学习模式标志为1                                  
   \                     ??CrossCallReturnLabel_139:
   \   00005B 35 11 ....   MOV       L:learn_mode, #0x11
    606                  WaitForConfirm_time = 0; 
   \   00005F 8D ......    CALLF     ?Subroutine29
    607              }                 
    608          }
   \                     ??CrossCallReturnLabel_49:
   \   000063 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine105_0:
   \   000000 8D ......    CALLF     L:?load32_l0_0x
   \   000004 BE ..        LDW       X, S:?w0
   \   000006 A3 0000      CPW       X, #0x0
   \   000009 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine84_0:
   \   000000 A6 04        LD        A, #0x4
   \   000002              REQUIRE ??Subroutine85_0
   \   000002              ;               // Fall through to label ??Subroutine85_0

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine78:
   \   000000 725F ....    CLR       L:Key1_Short_Pushed
   \   000004 725F ....    CLR       L:Key2_Short_Pushed
   \   000008 87           RETF
    609          
    610          /**
    611          @function：按键Key2处理函数 --  学习确认  
    612          **/

   \                                 In section .far_func.text, align 1, keep-with-next
    613          void  Key2_Function(void)
    614          {
    615              if(KEY2_INPUT)
   \                     Key2_Function:
   \   000000 8D ......    CALLF     ?Subroutine38
   \                     ??CrossCallReturnLabel_71:
   \   000004 27 24        JREQ      L:??CrossCallReturnLabel_3
    616              {
    617                  Key2_InterruptPushflag = 0;
   \   000006 725F ....    CLR       L:Key2_InterruptPushflag
    618                  if( key2_time_count < 180  )      
   \   00000A 8D ......    CALLF     ?Subroutine59
   \                     ??CrossCallReturnLabel_263:
   \   00000E 26 05        JRNE      L:??Key2_Function_0
   \   000010 BE ..        LDW       X, S:?w1
   \   000012 A3 00B4      CPW       X, #0xb4
   \                     ??Key2_Function_0:
   \   000015 24 13        JRNC      L:??CrossCallReturnLabel_3
    619                  {                                                      
    620                      Key2_Short_Pushed = 1;       
   \   000017 35 01 ....   MOV       L:Key2_Short_Pushed, #0x1
    621                      if(learn_mode == OFF)
   \   00001B C6 ....      LD        A, L:learn_mode
   \   00001E A1 10        CP        A, #0x10
   \   000020 26 71        JRNE      L:??Key2_Function_1
    622                      {
    623                          Broadcast_info();
   \   000022 8D ......    CALLF     Broadcast_info
    624                          LED1_BLUE;LED2_BLUE;                
   \   000026 8D ......    CALLF     ?Subroutine1
    625                          timer2_delay(100); 
    626                          Led1_Off(); Led2_Off();             
    627                      }
    628                  }            
    629              }
    630              if(learn_mode == OFF)
   \                     ??CrossCallReturnLabel_3:
   \   00002A C6 ....      LD        A, L:learn_mode
   \   00002D A1 10        CP        A, #0x10
   \   00002F 26 62        JRNE      L:??Key2_Function_1
    631              {       
    632                  if((key2_time_count > 400) && (!Key1_InterruptPushflag) && (learn_mode == OFF) )
   \   000031 8D ......    CALLF     ?Subroutine59
   \                     ??CrossCallReturnLabel_264:
   \   000035 26 05        JRNE      L:??Key2_Function_2
   \   000037 BE ..        LDW       X, S:?w1
   \   000039 A3 0191      CPW       X, #0x191
   \                     ??Key2_Function_2:
   \   00003C 25 55        JRC       L:??Key2_Function_1
   \   00003E C6 ....      LD        A, L:Key1_InterruptPushflag
   \   000041 26 50        JRNE      L:??Key2_Function_1
    633                  { 
    634                      Key2_InterruptPushflag = 0;
   \   000043 725F ....    CLR       L:Key2_InterruptPushflag
    635                      key2_time_count = 0;
   \   000047 5F           CLRW      X
   \   000048 CF ....      LDW       L:key2_time_count, X
   \   00004B CF ....      LDW       L:key2_time_count + 2, X
    636                      ClearFlash();             
   \   00004E 8D ......    CALLF     ClearFlash
    637                      TIM4_Cmd(DISABLE);
   \   000052 4F           CLR       A
   \   000053 8D ......    CALLF     TIM4_Cmd
    638                      auto_exit_time  = 0;           //自动退出计时清零     
   \   000057 5F           CLRW      X
   \   000058 CF ....      LDW       L:auto_exit_time, X
   \   00005B CF ....      LDW       L:auto_exit_time + 2, X
    639                      WaitForConfirm_time = 0;
   \   00005E CF ....      LDW       L:WaitForConfirm_time, X
   \   000061 CF ....      LDW       L:WaitForConfirm_time + 2, X
    640                                        
    641                      LED2_RED;LED1_RED;
   \   000064 A6 20        LD        A, #0x20
   \   000066 8D ......    CALLF     ??Subroutine104_0
   \                     ??CrossCallReturnLabel_252:
   \   00006A A6 08        LD        A, #0x8
   \   00006C 8D ......    CALLF     ??Subroutine85_0
    642                      timer2_delay(1280);            
   \                     ??CrossCallReturnLabel_148:
   \   000070 AE 0500      LDW       X, #0x500
   \   000073 8D ......    CALLF     ??Subroutine103_0
   \                     ??CrossCallReturnLabel_245:
   \   000077 20 0F        JRA       L:??CrossCallReturnLabel_1
    643                      while(led_flash < 5)
    644                      {
    645                          LED2_RED;LED1_RED;
   \                     ??Key2_Function_3:
   \   000079 A6 20        LD        A, #0x20
   \   00007B 8D ......    CALLF     ??Subroutine104_0
   \                     ??CrossCallReturnLabel_251:
   \   00007F A6 08        LD        A, #0x8
   \   000081 AE 5000      LDW       X, #0x5000
   \   000084 8D ......    CALLF     ?Subroutine0
    646                          timer2_delay(200);             //203.2ms
    647                          Led1_Off();Led2_Off();
    648                          timer2_delay(200);
    649                          led_flash++;
    650                      }
   \                     ??CrossCallReturnLabel_1:
   \   000088 C6 ....      LD        A, L:led_flash
   \   00008B A1 05        CP        A, #0x5
   \   00008D 25 EA        JRC       L:??Key2_Function_3
    651                      led_flash = 0;      
   \   00008F 725F ....    CLR       L:led_flash
    652                  }           
    653              }   
    654          }
   \                     ??Key2_Function_1:
   \   000093 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000 A6 80        LD        A, #0x80
   \   000002 AE 5005      LDW       X, #0x5005
   \   000005 8D ......    CALLF     GPIO_ReadInputDataBit
   \   000009 A1 00        CP        A, #0x0
   \   00000B 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000 A6 01        LD        A, #0x1
   \   000002 AE 5000      LDW       X, #0x5000
   \   000005 8D ......    CALLF     GPIO_SetBits
   \   000009 A6 02        LD        A, #0x2
   \   00000B 8D ......    CALLF     ??Subroutine108_0
   \                     ??CrossCallReturnLabel_277:
   \   00000F AE 0064      LDW       X, #0x64
   \   000012 8D ......    CALLF     ?Subroutine70
   \                     ??CrossCallReturnLabel_130:
   \   000016 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000 8D ......    CALLF     ?Subroutine82
   \                     ??CrossCallReturnLabel_248:
   \   000004 8D ......    CALLF     Led1_Off
   \   000008 AC ......    JPF       Led2_Off

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000 8D ......    CALLF     GPIO_SetBits
   \   000004 AE 00C8      LDW       X, #0xc8
   \   000007 8D ......    CALLF     ?Subroutine70
   \                     ??CrossCallReturnLabel_129:
   \   00000B 8D ......    CALLF     ?Subroutine71
   \                     ??CrossCallReturnLabel_132:
   \   00000F 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000 AE 00C8      LDW       X, #0xc8
   \   000003 8D ......    CALLF     ?Subroutine82
   \                     ??CrossCallReturnLabel_247:
   \   000007 C6 ....      LD        A, L:led_flash
   \   00000A 4C           INC       A
   \   00000B C7 ....      LD        L:led_flash, A
   \   00000E 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000 AE ....      LDW       X, #key2_time_count
   \   000003              REQUIRE ??Subroutine105_0
   \   000003              ;               // Fall through to label ??Subroutine105_0
    655               
    656          
    657          /**
    658          @function：无操作 定时 退出 学习模式 
    659          **/

   \                                 In section .far_func.text, align 1, keep-with-next
    660          void Auto_Exit_LearnMode_Function(void)
    661          {
    662              if(learn_mode == ON)                   
   \                     Auto_Exit_LearnMode_Function:
   \   000000 C6 ....      LD        A, L:learn_mode
   \   000003 A1 11        CP        A, #0x11
   \   000005 26 4B        JRNE      L:??Auto_Exit_LearnMode_Function_0
    663              {                         
    664                  if(auto_exit_time > 3200)                  //15s   自动退出学习模式
   \   000007 AE ....      LDW       X, #auto_exit_time
   \   00000A 8D ......    CALLF     ??Subroutine105_0
   \                     ??CrossCallReturnLabel_259:
   \   00000E 26 05        JRNE      L:??Auto_Exit_LearnMode_Function_1
   \   000010 BE ..        LDW       X, S:?w1
   \   000012 A3 0C81      CPW       X, #0xc81
   \                     ??Auto_Exit_LearnMode_Function_1:
   \   000015 25 1C        JRC       L:??CrossCallReturnLabel_53
    665                  {    
    666                      TIM4_Cmd(DISABLE);                     //关闭定时器
   \   000017 4F           CLR       A
   \   000018 8D ......    CALLF     TIM4_Cmd
    667                      led_blink_time  = 0;
   \   00001C 725F ....    CLR       L:led_blink_time
    668                      auto_exit_time  = 0;   
   \   000020 5F           CLRW      X
   \   000021 CF ....      LDW       L:auto_exit_time, X
   \   000024 CF ....      LDW       L:auto_exit_time + 2, X
    669                      Choose_Line     = 1;                //回路选择重新置1
   \   000027 35 01 ....   MOV       L:Choose_Line, #0x1
    670                      learn_mode      = OFF;              //退出学习模式，进入工作模式           
   \   00002B 35 10 ....   MOV       L:learn_mode, #0x10
    671                      Led1_Off();                         //关闭两个LED灯   
   \   00002F 8D ......    CALLF     ?Subroutine32
    672                      Led2_Off();
    673                  }
    674                  if(LearnModeWaitForConfirm == ON)
   \                     ??CrossCallReturnLabel_53:
   \   000033 C6 ....      LD        A, L:LearnModeWaitForConfirm
   \   000036 A1 11        CP        A, #0x11
   \   000038 26 18        JRNE      L:??Auto_Exit_LearnMode_Function_0
    675                  {
    676                      if(WaitForConfirm_time > 1200)      //自动退学学习确认等待
   \   00003A AE ....      LDW       X, #WaitForConfirm_time
   \   00003D 8D ......    CALLF     ??Subroutine105_0
   \                     ??CrossCallReturnLabel_260:
   \   000041 26 05        JRNE      L:??Auto_Exit_LearnMode_Function_2
   \   000043 BE ..        LDW       X, S:?w1
   \   000045 A3 04B1      CPW       X, #0x4b1
   \                     ??Auto_Exit_LearnMode_Function_2:
   \   000048 25 08        JRC       L:??Auto_Exit_LearnMode_Function_0
    677                      {
    678                           WaitForConfirm_time     = 0;
   \   00004A 8D ......    CALLF     ?Subroutine29
    679                           LearnModeWaitForConfirm = OFF;                 
   \                     ??CrossCallReturnLabel_48:
   \   00004E 35 10 ....   MOV       L:LearnModeWaitForConfirm, #0x10
    680                      }        
    681                  }
    682              } 
    683          }
   \                     ??Auto_Exit_LearnMode_Function_0:
   \   000052 87           RETF
    684          
    685          
    686          /**
    687          @function：第一次开机 Flash相关初始化
    688          **/

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000 A6 F7        LD        A, #0xf7
   \   000002 AC ......    JPF       FLASH_Unlock

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine95_0:
   \   000000 5F           CLRW      X
   \   000001 BF ..        LDW       S:?w0, X
   \   000003 AC ......    JPF       FLASH_ReadByte

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine100_0:
   \   000000 8D ......    CALLF     ?Subroutine74
   \                     ??CrossCallReturnLabel_229:
   \   000004 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000 BF ..        LDW       S:?w1, X
   \   000002              REQUIRE ??Subroutine101_0
   \   000002              ;               // Fall through to label ??Subroutine101_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine101_0:
   \   000000 5F           CLRW      X
   \   000001 BF ..        LDW       S:?w0, X
   \   000003 AC ......    JPF       FLASH_ProgramByte

   \                                 In section .far_func.text, align 1, keep-with-next
    689          void FirstPower(void)
    690          {
    691              INT8U firstpowernum;
    692              FLASH_SetProgrammingTime(FLASH_ProgramTime_Standard);      //选定Flash模式
   \                     FirstPower:
   \   000000 4F           CLR       A
   \   000001 8D ......    CALLF     FLASH_SetProgrammingTime
    693              FLASH_Unlock(FLASH_MemType_Data);                          //解锁Flash
   \   000005 8D ......    CALLF     ?Subroutine53
    694              timer2_delay(1);    
   \                     ??CrossCallReturnLabel_103:
   \   000009 8D ......    CALLF     ??Subroutine102_0
    695              firstpowernum = FLASH_ReadByte(IFFIRSTPOWERNUMADRESS);
    696              if(firstpowernum == 0x25)  //不是第一次开机
   \                     ??CrossCallReturnLabel_238:
   \   00000D AE 1002      LDW       X, #0x1002
   \   000010 8D ......    CALLF     ?Subroutine26
   \                     ??CrossCallReturnLabel_41:
   \   000014 A1 25        CP        A, #0x25
   \   000016 26 06        JRNE      L:??FirstPower_0
    697              {
    698                  firstpower = 0;                                             
   \   000018 725F ....    CLR       L:firstpower
   \   00001C 20 0D        JRA       L:??CrossCallReturnLabel_226
    699              }
    700              else       
    701              {   
    702                  //TODO 清空Flash数据
    703                  //ClearFlash();
    704                  firstpower = 1;       //第一次上电开机
   \                     ??FirstPower_0:
   \   00001E 35 01 ....   MOV       L:firstpower, #0x1
    705                  FLASH_ProgramByte(IFFIRSTPOWERNUMADRESS,0x25); 
   \   000022 A6 25        LD        A, #0x25
   \   000024 AE 1002      LDW       X, #0x1002
   \   000027 8D ......    CALLF     ??Subroutine100_0
    706              }
    707              FLASH_Lock(FLASH_MemType_Data);                            //锁定Flash  
   \                     ??CrossCallReturnLabel_226:
   \   00002B A6 F7        LD        A, #0xf7
   \   00002D AC ......    JPF       FLASH_Lock
    708          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000 BF ..        LDW       S:?w1, X
   \   000002 8D ......    CALLF     ??Subroutine95_0
   \                     ??CrossCallReturnLabel_204:
   \   000006 87           RETF
    709          
    710          /**
    711          @function：初始化读取Flash中ID
    712          **/

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000 8D ......    CALLF     L:?mul16_x_x_w0
   \   000004 1C ....      ADDW      X, #AllRadio
   \   000007 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine90_0:
   \   000000 8D ......    CALLF     L:?mul16_x_x_w0
   \   000004 1C ....      ADDW      X, #ABIO_Function
   \   000007 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000 A6 F7        LD        A, #0xf7
   \   000002 AC ......    JPF       FLASH_Lock

   \                                 In section .far_func.text, align 1, keep-with-next
    713          void ReadIdInFlash(void)
    714          {
   \                     ReadIdInFlash:
   \   000000 8D ......    CALLF     L:?push_l3
   \   000004 8D ......    CALLF     L:?push_w4
   \   000008 3B ....      PUSH      S:?b10
    715              INT8U i;
    716              INT16U flash_start = IDSTARTADDRESS;                         //Flash初始位置  
   \   00000B AE 1010      LDW       X, #0x1010
   \   00000E BF ..        LDW       S:?w6, X
    717              FLASH_Unlock(FLASH_MemType_Data);                            //解锁Flash 
   \   000010 8D ......    CALLF     ?Subroutine53
    718              timer2_delay(1);                                             //等待解锁Flash完成      
   \                     ??CrossCallReturnLabel_104:
   \   000014 8D ......    CALLF     ??Subroutine102_0
    719              if(firstpower == 1)                                          //第一次开机
   \                     ??CrossCallReturnLabel_237:
   \   000018 C6 ....      LD        A, L:firstpower
   \   00001B A1 01        CP        A, #0x1
   \   00001D 26 12        JRNE      L:??ReadIdInFlash_0
    720              {
    721                FLASH_ProgramByte(NEWIDADDRESSINFLASH_PART_1,0x10);        //将0x1010写入该位置
   \   00001F A6 10        LD        A, #0x10
   \   000021 AE 1005      LDW       X, #0x1005
   \   000024 8D ......    CALLF     ?Subroutine23
    722                FLASH_ProgramByte(NEWIDADDRESSINFLASH_PART_2,0x10);     
    723              } 
   \                     ??CrossCallReturnLabel_37:
   \   000028 AE 1006      LDW       X, #0x1006
   \   00002B 8D ......    CALLF     ??Subroutine100_0
   \                     ??CrossCallReturnLabel_225:
   \   00002F 20 21        JRA       L:??ReadIdInFlash_1
    724              else if(firstpower == 0)                                     //非第一次开机
   \                     ??ReadIdInFlash_0:
   \   000031 C6 ....      LD        A, L:firstpower
   \   000034 26 1C        JRNE      L:??ReadIdInFlash_1
    725              {
    726                Public_learned_ID_num = FLASH_ReadByte(IDCOUNTADD);
   \   000036 8D ......    CALLF     ?Subroutine11
    727                IdStartAddress = (FLASH_ReadByte(NEWIDADDRESSINFLASH_PART_1)<<8)+(FLASH_ReadByte(NEWIDADDRESSINFLASH_PART_2));
   \                     ??CrossCallReturnLabel_13:
   \   00003A 5F           CLRW      X
   \   00003B 97           LD        XL, A
   \   00003C BF ..        LDW       S:?w0, X
   \   00003E B6 ..        LD        A, S:?b8
   \   000040 41           EXG       A, XL
   \   000041 4F           CLR       A
   \   000042 02           RLWA      X, A
   \   000043 72BB ....    ADDW      X, S:?w0
   \   000047 CF ....      LDW       L:IdStartAddress, X
    728                if(IdStartAddress == 0x0)
   \   00004A 26 06        JRNE      L:??ReadIdInFlash_1
    729                {
    730                    IdStartAddress = IDSTARTADDRESS;
   \   00004C AE 1010      LDW       X, #0x1010
   \   00004F CF ....      LDW       L:IdStartAddress, X
    731                }
    732              } 
    733              for(i = 0;i < MAXLEARNNUM;i++)  //注意数组溢出                            
   \                     ??ReadIdInFlash_1:
   \   000052 3F ..        CLR       S:?b10
    734              {
    735                AllRadio[i].Id_part_1 = FLASH_ReadByte(flash_start);        //将Flash中ID读取到本地内存中
   \                     ??ReadIdInFlash_2:
   \   000054 8D ......    CALLF     ?Subroutine28
   \                     ??CrossCallReturnLabel_45:
   \   000058 8D ......    CALLF     ?Subroutine69
   \                     ??CrossCallReturnLabel_210:
   \   00005C BE ..        LDW       X, S:?w4
   \   00005E 5C           INCW      X
   \   00005F F7           LD        (X), A
    736                flash_start++;
   \   000060 BE ..        LDW       X, S:?w6
   \   000062 8D ......    CALLF     ?Subroutine27
    737                AllRadio[i].Id_part_2 = FLASH_ReadByte(flash_start);
    738                flash_start++;
    739                AllRadio[i].Id_part_3 = FLASH_ReadByte(flash_start);
    740                flash_start++;
    741                AllRadio[i].Id_part_4 = FLASH_ReadByte(flash_start);
    742                flash_start++;
    743                
    744                ABIO_Function[i].AI_Line1 = FLASH_ReadByte(flash_start);    //将Flash中开关对应的动作读取到本地内存中
    745                flash_start++;
    746                ABIO_Function[i].AO_Line1 = FLASH_ReadByte(flash_start);
    747                flash_start++;
    748                ABIO_Function[i].BI_Line1 = FLASH_ReadByte(flash_start);
    749                flash_start++;     
    750                ABIO_Function[i].BO_Line1 = FLASH_ReadByte(flash_start);
    751                flash_start++; 
    752                ABIO_Function[i].TOOGLE_Line1 = FLASH_ReadByte(flash_start);
    753                flash_start++;       
    754                     
    755                ABIO_Function[i].AI_Line2 = FLASH_ReadByte(flash_start);    
    756                flash_start++;
    757                ABIO_Function[i].AO_Line2 = FLASH_ReadByte(flash_start);
    758                flash_start++;
    759                ABIO_Function[i].BI_Line2 = FLASH_ReadByte(flash_start);
    760                flash_start++;     
    761                ABIO_Function[i].BO_Line2 = FLASH_ReadByte(flash_start);
    762                flash_start++; 
    763                ABIO_Function[i].TOOGLE_Line2 = FLASH_ReadByte(flash_start);
    764                flash_start++;       
    765                
    766                flash_start+=0x2;
    767              }   
   \                     ??CrossCallReturnLabel_43:
   \   000066 BF ..        LDW       S:?w6, X
   \   000068 B6 ..        LD        A, S:?b10
   \   00006A 4C           INC       A
   \   00006B B7 ..        LD        S:?b10, A
   \   00006D A1 0A        CP        A, #0xa
   \   00006F 25 E3        JRC       L:??ReadIdInFlash_2
    768              FLASH_Lock(FLASH_MemType_Data);   //锁定Flash
   \   000071 8D ......    CALLF     ?Subroutine52
    769          }
   \                     ??CrossCallReturnLabel_97:
   \   000075 32 ....      POP       S:?b10
   \   000078 8D ......    CALLF     L:?pop_w4
   \   00007C 8D ......    CALLF     L:?pop_l3
   \   000080 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000 8D ......    CALLF     L:?mov_w1_w6
   \   000004              REQUIRE ??Subroutine95_0
   \   000004              ;               // Fall through to label ??Subroutine95_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000 5F           CLRW      X
   \   000001 41           EXG       A, XL
   \   000002 B6 ..        LD        A, S:?b10
   \   000004 41           EXG       A, XL
   \   000005 BF ..        LDW       S:?w7, X
   \   000007 AE 0007      LDW       X, #0x7
   \   00000A BF ..        LDW       S:?w0, X
   \   00000C BE ..        LDW       X, S:?w7
   \   00000E 8D ......    CALLF     ?Subroutine83
   \                     ??CrossCallReturnLabel_175:
   \   000012 BF ..        LDW       S:?w4, X
   \   000014 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000 8D ......    CALLF     ?Subroutine66
   \                     ??CrossCallReturnLabel_127:
   \   000004 AE 000A      LDW       X, #0xa
   \   000007 BF ..        LDW       S:?w0, X
   \   000009 BE ..        LDW       X, S:?w7
   \   00000B 8D ......    CALLF     ??Subroutine90_0
   \                     ??CrossCallReturnLabel_178:
   \   00000F BF ..        LDW       S:?w4, X
   \   000011 8D ......    CALLF     ?Subroutine69
   \                     ??CrossCallReturnLabel_209:
   \   000015 92C7 ..      LD        [S:?w4.w], A
   \   000018 8D ......    CALLF     ??Subroutine96_0
   \                     ??CrossCallReturnLabel_215:
   \   00001C 5C           INCW      X
   \   00001D F7           LD        (X), A
   \   00001E BE ..        LDW       X, S:?w6
   \   000020 8D ......    CALLF     ?Subroutine66
   \                     ??CrossCallReturnLabel_128:
   \   000024 8D ......    CALLF     ?Subroutine69
   \                     ??CrossCallReturnLabel_208:
   \   000028 BE ..        LDW       X, S:?w4
   \   00002A 1C 0005      ADDW      X, #0x5
   \   00002D 8D ......    CALLF     ?Subroutine67
   \                     ??CrossCallReturnLabel_211:
   \   000031 1C 0006      ADDW      X, #0x6
   \   000034 8D ......    CALLF     ?Subroutine67
   \                     ??CrossCallReturnLabel_212:
   \   000038 1C 0007      ADDW      X, #0x7
   \   00003B 8D ......    CALLF     ?Subroutine67
   \                     ??CrossCallReturnLabel_213:
   \   00003F 1C 0008      ADDW      X, #0x8
   \   000042 8D ......    CALLF     ?Subroutine67
   \                     ??CrossCallReturnLabel_214:
   \   000046 1C 0009      ADDW      X, #0x9
   \   000049 F7           LD        (X), A
   \   00004A BE ..        LDW       X, S:?w6
   \   00004C 1C 0003      ADDW      X, #0x3
   \   00004F 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000 F7           LD        (X), A
   \   000001              REQUIRE ??Subroutine96_0
   \   000001              ;               // Fall through to label ??Subroutine96_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine96_0:
   \   000000 8D ......    CALLF     ??Subroutine97_0
   \                     ??CrossCallReturnLabel_218:
   \   000004 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000 F7           LD        (X), A
   \   000001              REQUIRE ??Subroutine97_0
   \   000001              ;               // Fall through to label ??Subroutine97_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine97_0:
   \   000000 BE ..        LDW       X, S:?w6
   \   000002              REQUIRE ??Subroutine98_0
   \   000002              ;               // Fall through to label ??Subroutine98_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine98_0:
   \   000000 5C           INCW      X
   \   000001 BF ..        LDW       S:?w6, X
   \   000003 8D ......    CALLF     L:?mov_w1_w6
   \   000007 5F           CLRW      X
   \   000008 BF ..        LDW       S:?w0, X
   \   00000A 8D ......    CALLF     FLASH_ReadByte
   \   00000E BE ..        LDW       X, S:?w4
   \   000010 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000 8D ......    CALLF     ??Subroutine98_0
   \                     ??CrossCallReturnLabel_219:
   \   000004 1C 0002      ADDW      X, #0x2
   \   000007 8D ......    CALLF     ?Subroutine81
   \                     ??CrossCallReturnLabel_216:
   \   00000B 1C 0003      ADDW      X, #0x3
   \   00000E 8D ......    CALLF     ?Subroutine81
   \                     ??CrossCallReturnLabel_217:
   \   000012 1C 0004      ADDW      X, #0x4
   \   000015 F7           LD        (X), A
   \   000016 BE ..        LDW       X, S:?w6
   \   000018 5C           INCW      X
   \   000019 BF ..        LDW       S:?w6, X
   \   00001B 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000 8D ......    CALLF     ?Subroutine74
   \                     ??CrossCallReturnLabel_228:
   \   000004 A6 10        LD        A, #0x10
   \   000006 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000 AE 1003      LDW       X, #0x1003
   \   000003 BF ..        LDW       S:?w1, X
   \   000005 8D ......    CALLF     ??Subroutine95_0
   \                     ??CrossCallReturnLabel_207:
   \   000009 C7 ....      LD        L:Public_learned_ID_num, A
   \   00000C AE 1005      LDW       X, #0x1005
   \   00000F BF ..        LDW       S:?w1, X
   \   000011 8D ......    CALLF     ??Subroutine95_0
   \                     ??CrossCallReturnLabel_206:
   \   000015 B7 ..        LD        S:?b8, A
   \   000017 AE 1006      LDW       X, #0x1006
   \   00001A BF ..        LDW       S:?w1, X
   \   00001C 8D ......    CALLF     ??Subroutine95_0
   \                     ??CrossCallReturnLabel_205:
   \   000020 87           RETF
    770          
    771          /** 
    772          @function： 在本地参数中查找ID 
    773          @parameter: 报文ID
    774          @return:    该ID在Flash中的位置（从0开始计数），若无，则返回FINDINFLASH_FAIL 
    775          **/

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine87_0:
   \   000000 9093         LDW       Y, X
   \   000002 72A9 0003    ADDW      Y, #0x3
   \   000006 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine88_0:
   \   000000 9093         LDW       Y, X
   \   000002 72A9 0002    ADDW      Y, #0x2
   \   000006 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000 61           EXG       A, YL
   \   000001              REQUIRE ??Subroutine89_0
   \   000001              ;               // Fall through to label ??Subroutine89_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine89_0:
   \   000000 8D ......    CALLF     ?Subroutine75
   \                     ??CrossCallReturnLabel_173:
   \   000004 9093         LDW       Y, X
   \   000006 905C         INCW      Y
   \   000008 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000 AE 0007      LDW       X, #0x7
   \   000003 BF ..        LDW       S:?w0, X
   \   000005 93           LDW       X, Y
   \   000006 8D ......    CALLF     ?Subroutine83
   \                     ??CrossCallReturnLabel_176:
   \   00000A 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
    776          INT8U FindIdInFlash(INT8U ID_Part1,INT8U ID_Part2,INT8U ID_Part3,INT8U ID_Part4)
    777          {
   \                     FindIdInFlash:
   \   000000 B7 ..        LD        S:?b6, A
   \   000002 45 .. ..     MOV       S:?b3, S:?b0
   \   000005 45 .. ..     MOV       S:?b4, S:?b1
    778              INT8U i;  
    779              for(i = 0 ; i < MAXLEARNNUM ; i++)       //TODO 可优化，根据学习数量来进行查找    
   \   000008 3F ..        CLR       S:?b5
    780              {           
    781                  if(AllRadio[i].Id_part_1==ID_Part1&&(AllRadio[i].Id_part_2==ID_Part2)&&(AllRadio[i].Id_part_3==ID_Part3)&&(AllRadio[i].Id_part_4==ID_Part4))
   \                     ??FindIdInFlash_0:
   \   00000A 905F         CLRW      Y
   \   00000C 61           EXG       A, YL
   \   00000D B6 ..        LD        A, S:?b5
   \   00000F 8D ......    CALLF     ?Subroutine30
   \                     ??CrossCallReturnLabel_171:
   \   000013 B6 ..        LD        A, S:?b6
   \   000015 90F1         CP        A, (Y)
   \   000017 26 1F        JRNE      L:??FindIdInFlash_1
   \   000019 8D ......    CALLF     ??Subroutine88_0
   \                     ??CrossCallReturnLabel_168:
   \   00001D B6 ..        LD        A, S:?b3
   \   00001F 90F1         CP        A, (Y)
   \   000021 26 15        JRNE      L:??FindIdInFlash_1
   \   000023 8D ......    CALLF     ??Subroutine87_0
   \                     ??CrossCallReturnLabel_163:
   \   000027 B6 ..        LD        A, S:?b4
   \   000029 90F1         CP        A, (Y)
   \   00002B 26 0B        JRNE      L:??FindIdInFlash_1
   \   00002D 1C 0004      ADDW      X, #0x4
   \   000030 B6 ..        LD        A, S:?b2
   \   000032 F1           CP        A, (X)
   \   000033 26 03        JRNE      L:??FindIdInFlash_1
    782                  {          
    783                       return(i);
   \   000035 B6 ..        LD        A, S:?b5
   \   000037 87           RETF
    784                  }        
    785              }
   \                     ??FindIdInFlash_1:
   \   000038 B6 ..        LD        A, S:?b5
   \   00003A 4C           INC       A
   \   00003B B7 ..        LD        S:?b5, A
   \   00003D A1 0A        CP        A, #0xa
   \   00003F 25 C9        JRC       L:??FindIdInFlash_0
    786              return(FINDINFLASH_FAIL);
   \   000041 A6 77        LD        A, #0x77
   \   000043 87           RETF
    787          }
    788          
    789          /**
    790          @function： 将ID写入Flash中 
    791          @parameter：需写入Flash的ID    按照空闲位置顺序写入Flash
    792          **/

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000 90F7         LD        (Y), A
   \   000002              REQUIRE ??Subroutine87_0
   \   000002              ;               // Fall through to label ??Subroutine87_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000 90F7         LD        (Y), A
   \   000002              REQUIRE ??Subroutine88_0
   \   000002              ;               // Fall through to label ??Subroutine88_0

   \                                 In section .far_func.text, align 1, keep-with-next
    793          void WriteIdInFlash(INT8U ID_Part1,INT8U ID_Part2,INT8U ID_Part3,INT8U ID_Part4)
    794          {
   \                     WriteIdInFlash:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 B7 ..        LD        S:?b11, A
   \   000006 45 .. ..     MOV       S:?b10, S:?b0
   \   000009 45 .. ..     MOV       S:?b8, S:?b1
   \   00000C 45 .. ..     MOV       S:?b9, S:?b2
    795              FLASH_Unlock(FLASH_MemType_Data);                                   //解锁Flash
   \   00000F 8D ......    CALLF     ?Subroutine53
    796              timer2_delay(1);  
   \                     ??CrossCallReturnLabel_105:
   \   000013 8D ......    CALLF     ??Subroutine102_0
    797              
    798              AllRadio[Public_learned_ID_num].Id_part_1=ID_Part1;                    //将ID保存到本地的变量中
   \                     ??CrossCallReturnLabel_236:
   \   000017 C6 ....      LD        A, L:Public_learned_ID_num
   \   00001A 905F         CLRW      Y
   \   00001C 9097         LD        YL, A
   \   00001E 8D ......    CALLF     ??Subroutine89_0
   \                     ??CrossCallReturnLabel_169:
   \   000022 B6 ..        LD        A, S:?b11
   \   000024 8D ......    CALLF     ?Subroutine47
    799              AllRadio[Public_learned_ID_num].Id_part_2=ID_Part2;
   \                     ??CrossCallReturnLabel_165:
   \   000028 B6 ..        LD        A, S:?b10
   \   00002A 8D ......    CALLF     ?Subroutine48
    800              AllRadio[Public_learned_ID_num].Id_part_3=ID_Part3;
   \                     ??CrossCallReturnLabel_160:
   \   00002E B6 ..        LD        A, S:?b8
   \   000030 90F7         LD        (Y), A
    801              AllRadio[Public_learned_ID_num].Id_part_4=ID_Part4;    
   \   000032 1C 0004      ADDW      X, #0x4
   \   000035 B6 ..        LD        A, S:?b9
   \   000037 F7           LD        (X), A
    802              Public_learned_ID_num++;                                               //已学习ID数量加1
   \   000038 C6 ....      LD        A, L:Public_learned_ID_num
   \   00003B 4C           INC       A
   \   00003C 8D ......    CALLF     ?Subroutine25
    803              FLASH_ProgramByte(IDCOUNTADD,Public_learned_ID_num);                                   
    804                  
    805              FLASH_ProgramByte(IdStartAddress,ID_Part1);                            //将ID分开写入Flash中
   \                     ??CrossCallReturnLabel_221:
   \   000040 B6 ..        LD        A, S:?b11
   \   000042 CE ....      LDW       X, L:IdStartAddress
   \   000045 8D ......    CALLF     ?Subroutine13
    806              IdStartAddress++;
    807              FLASH_ProgramByte(IdStartAddress,ID_Part2);
   \                     ??CrossCallReturnLabel_16:
   \   000049 B6 ..        LD        A, S:?b10
   \   00004B 8D ......    CALLF     ?Subroutine13
    808              IdStartAddress++;
    809              FLASH_ProgramByte(IdStartAddress,ID_Part3);
   \                     ??CrossCallReturnLabel_17:
   \   00004F B6 ..        LD        A, S:?b8
   \   000051 8D ......    CALLF     ?Subroutine13
    810              IdStartAddress++;
    811              FLASH_ProgramByte(IdStartAddress,ID_Part4);   
   \                     ??CrossCallReturnLabel_18:
   \   000055 B6 ..        LD        A, S:?b9
   \   000057 8D ......    CALLF     ?Subroutine21
    812              IdStartAddress += 0xD;
   \                     ??CrossCallReturnLabel_34:
   \   00005B 1C 000D      ADDW      X, #0xd
   \   00005E CF ....      LDW       L:IdStartAddress, X
    813              
    814              FLASH_ProgramByte(NEWIDADDRESSINFLASH_PART_1,(IdStartAddress >> 8));   //将IdStartAddress写入该位置
   \   000061 4F           CLR       A
   \   000062 01           RRWA      X, A
   \   000063 9F           LD        A, XL
   \   000064 AE 1005      LDW       X, #0x1005
   \   000067 8D ......    CALLF     ?Subroutine21
    815              FLASH_ProgramByte(NEWIDADDRESSINFLASH_PART_2,(IdStartAddress & 0xff));
   \                     ??CrossCallReturnLabel_35:
   \   00006B 9F           LD        A, XL
   \   00006C AE 1006      LDW       X, #0x1006
   \   00006F 8D ......    CALLF     ??Subroutine100_0
    816              
    817              FLASH_Lock(FLASH_MemType_Data);                                     //锁定Flash
   \                     ??CrossCallReturnLabel_224:
   \   000073 8D ......    CALLF     ?Subroutine52
    818          }
   \                     ??CrossCallReturnLabel_98:
   \   000077 AC ......    JPF       L:?epilogue_l2

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000 8D ......    CALLF     ?Subroutine73
   \                     ??CrossCallReturnLabel_133:
   \   000004 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000 BF ..        LDW       S:?w1, X
   \   000002 5F           CLRW      X
   \   000003 BF ..        LDW       S:?w0, X
   \   000005 8D ......    CALLF     FLASH_ProgramByte
   \   000009 CE ....      LDW       X, L:IdStartAddress
   \   00000C 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000 8D ......    CALLF     ?Subroutine73
   \                     ??CrossCallReturnLabel_134:
   \   000004 5C           INCW      X
   \   000005 CF ....      LDW       L:IdStartAddress, X
   \   000008 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000 C7 ....      LD        L:Public_learned_ID_num, A
   \   000003              REQUIRE ??Subroutine99_0
   \   000003              ;               // Fall through to label ??Subroutine99_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine99_0:
   \   000000 AE 1003      LDW       X, #0x1003
   \   000003              REQUIRE ??Subroutine100_0
   \   000003              ;               // Fall through to label ??Subroutine100_0
    819          
    820          
    821          /**
    822          @function： 将开关的键值对应的操作写入Flash中 
    823          @parameter：key1 & key2： 开关中一路中两个按键的键值
    824          @parameter：ABIO_Line：   对应执行器中的回路
    825          @parameter：ID_NUM：      对应Flash中条目的编号（从0开始计数）
    826          **/

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000 AE 000A      LDW       X, #0xa
   \   000003 BF ..        LDW       S:?w0, X
   \   000005 93           LDW       X, Y
   \   000006              REQUIRE ??Subroutine90_0
   \   000006              ;               // Fall through to label ??Subroutine90_0

   \                                 In section .far_func.text, align 1, keep-with-next
    827          void WriteKeyOperationInFlash(INT8U ABIO_Line,INT8U ID_NUM)
    828          {
   \                     WriteKeyOperationInFlash:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_w6
   \   000008 B7 ..        LD        S:?b8, A
   \   00000A 45 .. ..     MOV       S:?b9, S:?b0
    829              FLASH_Unlock(FLASH_MemType_Data);   //解锁Flash
   \   00000D 8D ......    CALLF     ?Subroutine12
    830              timer2_delay(1); 
    831              uclong need_adress;
    832              if(ABIO_Line == A_LINE1)               //AI_Line1 & AO_Line1 
   \                     ??CrossCallReturnLabel_15:
   \   000011 A1 11        CP        A, #0x11
   \   000013 26 19        JRNE      L:??WriteKeyOperationInFlash_0
    833              {
    834                  need_adress = (IDSTARTADDRESS+0x10*ID_NUM+0x4);
   \   000015 1C 1014      ADDW      X, #0x1014
   \   000018 8D ......    CALLF     ?Subroutine56
    835                  FLASH_ProgramByte(need_adress,AI);        //Line1 将AI:0x10 & AO:0x30写入flash
   \                     ??CrossCallReturnLabel_112:
   \   00001C 8D ......    CALLF     FLASH_ProgramByte
    836                  ABIO_Function[ID_NUM].AI_Line1 = AI;      //写入用于本地使用的数组
   \   000020 A6 10        LD        A, #0x10
   \   000022 92C7 ..      LD        [S:?w6.w], A
    837                  need_adress ++;
    838                  FLASH_ProgramByte(need_adress,AO);
   \   000025 A6 30        LD        A, #0x30
   \   000027 8D ......    CALLF     ??Subroutine92_0
    839                  ABIO_Function[ID_NUM].AO_Line1 = AO; 
    840              }
   \                     ??CrossCallReturnLabel_190:
   \   00002B 5C           INCW      X
   \   00002C 20 4F        JRA       ??WriteKeyOperationInFlash_1
    841              if(ABIO_Line == B_LINE1)      //BI_Line1 & BO_Line1
   \                     ??WriteKeyOperationInFlash_0:
   \   00002E A1 12        CP        A, #0x12
   \   000030 26 17        JRNE      L:??WriteKeyOperationInFlash_2
    842              {   
    843                  need_adress = (IDSTARTADDRESS+0x10*ID_NUM+0x6);
   \   000032 1C 1016      ADDW      X, #0x1016
   \   000035 8D ......    CALLF     ?Subroutine57
    844                  FLASH_ProgramByte(need_adress,BI);                   //Line1 将BI:0x50 & BO:0x70写入flash
    845                  ABIO_Function[ID_NUM].BI_Line1 = BI;            
    846                  need_adress++;
    847                  FLASH_ProgramByte(need_adress,BO);  
    848                  ABIO_Function[ID_NUM].BO_Line1 = BO;          
    849              } 
   \                     ??CrossCallReturnLabel_114:
   \   000039 8D ......    CALLF     ??Subroutine94_0
   \                     ??CrossCallReturnLabel_199:
   \   00003D 1C 0002      ADDW      X, #0x2
   \   000040 8D ......    CALLF     ?Subroutine51
   \                     ??CrossCallReturnLabel_186:
   \   000044 1C 0003      ADDW      X, #0x3
   \   000047 20 51        JRA       ??WriteKeyOperationInFlash_3
    850              if(ABIO_Line == ABIO_TOOGLE_LINE1)
   \                     ??WriteKeyOperationInFlash_2:
   \   000049 A1 18        CP        A, #0x18
   \   00004B 26 12        JRNE      L:??WriteKeyOperationInFlash_4
    851              {
    852                  need_adress = (IDSTARTADDRESS+0x10*ID_NUM+0x8);
    853                  FLASH_ProgramByte(need_adress,ABIO_TOOGLE);         //Line1 反转操作写入flash
   \   00004D A6 20        LD        A, #0x20
   \   00004F 1C 1018      ADDW      X, #0x1018
   \   000052 8D ......    CALLF     L:?sext32_l0_x
   \   000056 8D ......    CALLF     ??Subroutine94_0
    854                  ABIO_Function[ID_NUM].TOOGLE_Line1 = ABIO_TOOGLE;
    855              }
   \                     ??CrossCallReturnLabel_200:
   \   00005A 1C 0004      ADDW      X, #0x4
   \   00005D 20 53        JRA       ??WriteKeyOperationInFlash_5
    856              
    857               
    858              /*****  LINE2  *****/       
    859              if(ABIO_Line == A_LINE2)      //AI_Line2 & AO_Line2
   \                     ??WriteKeyOperationInFlash_4:
   \   00005F A1 13        CP        A, #0x13
   \   000061 26 1E        JRNE      L:??WriteKeyOperationInFlash_6
    860              {
    861                  need_adress = (IDSTARTADDRESS+0x10*ID_NUM+0x9);
   \   000063 1C 1019      ADDW      X, #0x1019
   \   000066 8D ......    CALLF     ?Subroutine56
    862                  FLASH_ProgramByte(need_adress,0x10);                //Line2 将AI:0x10 & AO:0x30写入flash
   \                     ??CrossCallReturnLabel_113:
   \   00006A 8D ......    CALLF     ??Subroutine94_0
    863                  ABIO_Function[ID_NUM].AI_Line2 = AI;
   \                     ??CrossCallReturnLabel_201:
   \   00006E 1C 0005      ADDW      X, #0x5
   \   000071 A6 10        LD        A, #0x10
   \   000073 F7           LD        (X), A
    864                  need_adress++;
    865                  FLASH_ProgramByte(need_adress,0x30); 
   \   000074 A6 30        LD        A, #0x30
   \   000076 8D ......    CALLF     ??Subroutine92_0
    866                  ABIO_Function[ID_NUM].AO_Line2 = AO;
    867              }  
   \                     ??CrossCallReturnLabel_191:
   \   00007A 1C 0006      ADDW      X, #0x6
   \                     ??WriteKeyOperationInFlash_1:
   \   00007D A6 30        LD        A, #0x30
   \   00007F 20 33        JRA       ??WriteKeyOperationInFlash_7
    868              if(ABIO_Line == B_LINE2)      //BI_Line2 & BO_Line2
   \                     ??WriteKeyOperationInFlash_6:
   \   000081 A1 14        CP        A, #0x14
   \   000083 26 19        JRNE      L:??WriteKeyOperationInFlash_8
    869              {
    870                  need_adress = (IDSTARTADDRESS+0x10*ID_NUM+0xB);
   \   000085 1C 101B      ADDW      X, #0x101b
   \   000088 8D ......    CALLF     ?Subroutine57
    871                  FLASH_ProgramByte(need_adress,BI);                  //Line2 将BI:0x50 & BO:0x70写入flash
    872                  ABIO_Function[ID_NUM].BI_Line2 = BI;
    873                  need_adress++;
    874                  FLASH_ProgramByte(need_adress,BO);
    875                  ABIO_Function[ID_NUM].BO_Line2 = BO;
    876              }
   \                     ??CrossCallReturnLabel_115:
   \   00008C 8D ......    CALLF     ??Subroutine94_0
   \                     ??CrossCallReturnLabel_202:
   \   000090 1C 0007      ADDW      X, #0x7
   \   000093 8D ......    CALLF     ?Subroutine51
   \                     ??CrossCallReturnLabel_187:
   \   000097 1C 0008      ADDW      X, #0x8
   \                     ??WriteKeyOperationInFlash_3:
   \   00009A A6 70        LD        A, #0x70
   \   00009C 20 16        JRA       ??WriteKeyOperationInFlash_7
    877              if(ABIO_Line == ABIO_TOOGLE_LINE2)
   \                     ??WriteKeyOperationInFlash_8:
   \   00009E A1 19        CP        A, #0x19
   \   0000A0 26 13        JRNE      L:??WriteKeyOperationInFlash_9
    878              {
    879                  need_adress = (IDSTARTADDRESS+0x10*ID_NUM+0xD);
    880                  FLASH_ProgramByte(need_adress,ABIO_TOOGLE);        //Line2 反转操作写入flash
   \   0000A2 A6 20        LD        A, #0x20
   \   0000A4 1C 101D      ADDW      X, #0x101d
   \   0000A7 8D ......    CALLF     L:?sext32_l0_x
   \   0000AB 8D ......    CALLF     ??Subroutine94_0
    881                  ABIO_Function[ID_NUM].TOOGLE_Line2 = ABIO_TOOGLE;
    882              }
   \                     ??CrossCallReturnLabel_203:
   \   0000AF 1C 0009      ADDW      X, #0x9
   \                     ??WriteKeyOperationInFlash_5:
   \   0000B2 A6 20        LD        A, #0x20
   \                     ??WriteKeyOperationInFlash_7:
   \   0000B4 F7           LD        (X), A
    883              
    884              FLASH_Lock(FLASH_MemType_Data);    //锁定Flash
   \                     ??WriteKeyOperationInFlash_9:
   \   0000B5 8D ......    CALLF     ?Subroutine52
    885          }
   \                     ??CrossCallReturnLabel_99:
   \   0000B9 AC ......    JPF       L:?epilogue_l2_w6

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000 8D ......    CALLF     ?Subroutine79
   \                     ??CrossCallReturnLabel_144:
   \   000004 A6 50        LD        A, #0x50
   \   000006 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000 8D ......    CALLF     L:?sext32_l0_x
   \   000004 AC ......    JPF       L:?mov_l2_l0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000 8D ......    CALLF     ?Subroutine79
   \                     ??CrossCallReturnLabel_143:
   \   000004 A6 10        LD        A, #0x10
   \   000006 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000 A6 50        LD        A, #0x50
   \   000002 F7           LD        (X), A
   \   000003 A6 70        LD        A, #0x70
   \   000005              REQUIRE ??Subroutine92_0
   \   000005              ;               // Fall through to label ??Subroutine92_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine92_0:
   \   000000 8D ......    CALLF     L:?inc32_l2_l2
   \   000004              REQUIRE ??Subroutine93_0
   \   000004              ;               // Fall through to label ??Subroutine93_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine93_0:
   \   000000 8D ......    CALLF     L:?mov_l0_l2
   \   000004              REQUIRE ??Subroutine94_0
   \   000004              ;               // Fall through to label ??Subroutine94_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine94_0:
   \   000000 8D ......    CALLF     FLASH_ProgramByte
   \   000004 BE ..        LDW       X, S:?w6
   \   000006 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000 A6 F7        LD        A, #0xf7
   \   000002 8D ......    CALLF     FLASH_Unlock
   \   000006 8D ......    CALLF     ?Subroutine72
   \                     ??CrossCallReturnLabel_240:
   \   00000A 5F           CLRW      X
   \   00000B 41           EXG       A, XL
   \   00000C B6 ..        LD        A, S:?b9
   \   00000E 41           EXG       A, XL
   \   00000F 9093         LDW       Y, X
   \   000011 8D ......    CALLF     ?Subroutine76
   \                     ??CrossCallReturnLabel_179:
   \   000015 BF ..        LDW       S:?w6, X
   \   000017 93           LDW       X, Y
   \   000018 58           SLLW      X
   \   000019 58           SLLW      X
   \   00001A 58           SLLW      X
   \   00001B 58           SLLW      X
   \   00001C B6 ..        LD        A, S:?b8
   \   00001E 87           RETF
    886          
    887          
    888          /**
    889          @function： 远程学习  将一路数据全部写入Flash中 
    890          @parameter：ABIOT 参数
    891          @parameter：Line_num 对应执行器的回路1 或 2
    892          @parameter：LearnedIdNum 对应Flash中条目的编号（从0开始计数）
    893          **/

   \                                 In section .far_func.text, align 1, keep-with-next
    894          void ControlByAirLearn_NewWriteInFlash(INT8U AI_Data,INT8U AO_Data,INT8U BI_Data,INT8U BO_Data,INT8U Toogle_Data,INT8U Line_num ,INT8U LearnedIdNum)
    895          {
   \                     ControlByAirLearn_NewWriteInFlash:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_l3
   \   000008 3B ....      PUSH      S:?b1
   \   00000B 3B ....      PUSH      S:?b2
   \   00000E 3B ....      PUSH      S:?b3
   \   000011 B7 ..        LD        S:?b14, A
   \   000013 45 .. ..     MOV       S:?b15, S:?b0
   \   000016 45 .. ..     MOV       S:?b8, S:?b4
   \   000019 45 .. ..     MOV       S:?b9, S:?b5
    896              FLASH_Unlock(FLASH_MemType_Data);   //解锁Flash
   \   00001C 8D ......    CALLF     ?Subroutine12
    897              timer2_delay(1);
   \                     ??CrossCallReturnLabel_14:
   \   000020 A1 16        CP        A, #0x16
   \   000022 26 45        JRNE      L:??ControlByAirLearn_NewWriteInFlash_0
    898              
    899              uclong need_adress;
    900              
    901              if(Line_num == LINE_1)
    902              {
    903                  need_adress = (IDSTARTADDRESS + 0x10 * LearnedIdNum + 0x4);
   \   000024 1C 1014      ADDW      X, #0x1014
   \   000027 8D ......    CALLF     ?Subroutine55
    904                  FLASH_ProgramByte(need_adress,AI_Data);                 // AI_Data 写入Flash 中AI_Line1 位置
   \                     ??CrossCallReturnLabel_110:
   \   00002B 8D ......    CALLF     FLASH_ProgramByte
    905                  ABIO_Function[LearnedIdNum].AI_Line1 = AI_Data;         //写入用于本地使用的数组        
   \   00002F B6 ..        LD        A, S:?b14
   \   000031 92C7 ..      LD        [S:?w6.w], A
    906                  need_adress++;
   \   000034 8D ......    CALLF     L:?inc32_l2_l2
    907                  FLASH_ProgramByte(need_adress,AO_Data);
   \   000038 B6 ..        LD        A, S:?b15
   \   00003A 8D ......    CALLF     ??Subroutine93_0
    908                  ABIO_Function[LearnedIdNum].AO_Line1 = AO_Data; 
   \                     ??CrossCallReturnLabel_192:
   \   00003E 5C           INCW      X
   \   00003F 8D ......    CALLF     ?Subroutine58
    909                  need_adress++;
    910                  FLASH_ProgramByte(need_adress,BI_Data);
   \                     ??CrossCallReturnLabel_185:
   \   000043 7B 03        LD        A, (0x3,SP)
   \   000045 8D ......    CALLF     ??Subroutine93_0
    911                  ABIO_Function[LearnedIdNum].BI_Line1 = BI_Data; 
   \                     ??CrossCallReturnLabel_193:
   \   000049 1C 0002      ADDW      X, #0x2
   \   00004C 7B 03        LD        A, (0x3,SP)
   \   00004E 8D ......    CALLF     ??Subroutine91_0
    912                  need_adress++;        
    913                  FLASH_ProgramByte(need_adress,BO_Data);
   \                     ??CrossCallReturnLabel_183:
   \   000052 7B 02        LD        A, (0x2,SP)
   \   000054 8D ......    CALLF     ??Subroutine93_0
    914                  ABIO_Function[LearnedIdNum].BO_Line1 = BO_Data; 
   \                     ??CrossCallReturnLabel_194:
   \   000058 1C 0003      ADDW      X, #0x3
   \   00005B 7B 02        LD        A, (0x2,SP)
   \   00005D F7           LD        (X), A
    915                  need_adress++;      
    916                  FLASH_ProgramByte(need_adress,Toogle_Data);
   \   00005E 7B 01        LD        A, (0x1,SP)
   \   000060 8D ......    CALLF     ??Subroutine92_0
    917                  ABIO_Function[LearnedIdNum].TOOGLE_Line1 = Toogle_Data; 
    918                  need_adress++;                  
    919              }
   \                     ??CrossCallReturnLabel_188:
   \   000064 1C 0004      ADDW      X, #0x4
   \   000067 20 49        JRA       ??ControlByAirLearn_NewWriteInFlash_1
    920              else if(Line_num == LINE_2)
   \                     ??ControlByAirLearn_NewWriteInFlash_0:
   \   000069 A1 17        CP        A, #0x17
   \   00006B 26 48        JRNE      L:??ControlByAirLearn_NewWriteInFlash_2
    921              {
    922                  need_adress = (IDSTARTADDRESS + 0x10 * LearnedIdNum + 0x9);
   \   00006D 1C 1019      ADDW      X, #0x1019
   \   000070 8D ......    CALLF     ?Subroutine55
    923                  FLASH_ProgramByte(need_adress,AI_Data);                 // AI_Data 写入Flash 中AI_Line2 位置
   \                     ??CrossCallReturnLabel_111:
   \   000074 8D ......    CALLF     ??Subroutine94_0
    924                  ABIO_Function[LearnedIdNum].AI_Line2 = AI_Data;         //写入用于本地使用的数组        
   \                     ??CrossCallReturnLabel_198:
   \   000078 1C 0005      ADDW      X, #0x5
   \   00007B B6 ..        LD        A, S:?b14
   \   00007D 8D ......    CALLF     ??Subroutine91_0
    925                  need_adress++;
    926                  FLASH_ProgramByte(need_adress,AO_Data);
   \                     ??CrossCallReturnLabel_182:
   \   000081 B6 ..        LD        A, S:?b15
   \   000083 8D ......    CALLF     ??Subroutine93_0
    927                  ABIO_Function[LearnedIdNum].AO_Line2 = AO_Data; 
   \                     ??CrossCallReturnLabel_195:
   \   000087 1C 0006      ADDW      X, #0x6
   \   00008A 8D ......    CALLF     ?Subroutine58
    928                  need_adress++;
    929                  FLASH_ProgramByte(need_adress,BI_Data);
   \                     ??CrossCallReturnLabel_184:
   \   00008E 7B 03        LD        A, (0x3,SP)
   \   000090 8D ......    CALLF     ??Subroutine93_0
    930                  ABIO_Function[LearnedIdNum].BI_Line2 = BI_Data; 
   \                     ??CrossCallReturnLabel_196:
   \   000094 1C 0007      ADDW      X, #0x7
   \   000097 7B 03        LD        A, (0x3,SP)
   \   000099 8D ......    CALLF     ??Subroutine91_0
    931                  need_adress++;        
    932                  FLASH_ProgramByte(need_adress,BO_Data);
   \                     ??CrossCallReturnLabel_181:
   \   00009D 7B 02        LD        A, (0x2,SP)
   \   00009F 8D ......    CALLF     ??Subroutine93_0
    933                  ABIO_Function[LearnedIdNum].BO_Line2 = BO_Data; 
   \                     ??CrossCallReturnLabel_197:
   \   0000A3 1C 0008      ADDW      X, #0x8
   \   0000A6 7B 02        LD        A, (0x2,SP)
   \   0000A8 F7           LD        (X), A
    934                  need_adress++;      
    935                  FLASH_ProgramByte(need_adress,Toogle_Data);
   \   0000A9 7B 01        LD        A, (0x1,SP)
   \   0000AB 8D ......    CALLF     ??Subroutine92_0
    936                  ABIO_Function[LearnedIdNum].TOOGLE_Line2 = Toogle_Data; 
   \                     ??CrossCallReturnLabel_189:
   \   0000AF 1C 0009      ADDW      X, #0x9
   \                     ??ControlByAirLearn_NewWriteInFlash_1:
   \   0000B2 7B 01        LD        A, (0x1,SP)
   \   0000B4 F7           LD        (X), A
    937                  need_adress++;       
    938              }
    939              FLASH_Lock(FLASH_MemType_Data);   //锁定Flash
   \                     ??ControlByAirLearn_NewWriteInFlash_2:
   \   0000B5 8D ......    CALLF     ?Subroutine52
    940          }
   \                     ??CrossCallReturnLabel_100:
   \   0000B9 5B 03        ADD       SP, #0x3
   \   0000BB AC ......    JPF       L:?epilogue_l2_l3

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000 B6 ..        LD        A, S:?b15
   \   000002              REQUIRE ??Subroutine91_0
   \   000002              ;               // Fall through to label ??Subroutine91_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine91_0:
   \   000000 F7           LD        (X), A
   \   000001 AC ......    JPF       L:?inc32_l2_l2

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000 8D ......    CALLF     ?Subroutine79
   \                     ??CrossCallReturnLabel_142:
   \   000004 B6 ..        LD        A, S:?b14
   \   000006 87           RETF
    941          
    942          
    943          /**
    944          @function： 远程学习中  删除一个条目后  对Flash中数据排位进行   更新  
    945          @parameter：对应Flash中条目的编号（从0开始计数）
    946          **/

   \                                 In section .far_func.text, align 1, keep-with-next
    947          void UpdateDatasAdressInFlash(INT8U NumOfDeleteData)
    948          {
   \                     UpdateDatasAdressInFlash:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_l3
   \   000008 52 05        SUB       SP, #0x5
   \   00000A B7 ..        LD        S:?b12, A
    949              INT8U  i,j =0;
    950              INT8U  need_num;
    951              uclong need_adress;
    952              INT16U flash_start = IDSTARTADDRESS; 
   \   00000C AE 1010      LDW       X, #0x1010
   \   00000F 1F 04        LDW       (0x4,SP), X
    953              FLASH_Unlock(FLASH_MemType_Data);   //解锁Flash
   \   000011 8D ......    CALLF     ?Subroutine53
    954              timer2_delay(1); 
   \                     ??CrossCallReturnLabel_106:
   \   000015 8D ......    CALLF     ??Subroutine102_0
    955              
    956              INT8U  numNeedMove = 0;
    957              numNeedMove = Public_learned_ID_num - NumOfDeleteData;
    958              numNeedMove = numNeedMove - 1;
   \                     ??CrossCallReturnLabel_235:
   \   000019 C6 ....      LD        A, L:Public_learned_ID_num
   \   00001C B0 ..        SUB       A, S:?b12
   \   00001E 4A           DEC       A
   \   00001F 6B 03        LD        (0x3,SP), A
    959                    
    960              need_adress = (IDSTARTADDRESS + 0x10 * NumOfDeleteData);
   \   000021 5F           CLRW      X
   \   000022 41           EXG       A, XL
   \   000023 B6 ..        LD        A, S:?b12
   \   000025 41           EXG       A, XL
   \   000026 58           SLLW      X
   \   000027 58           SLLW      X
   \   000028 58           SLLW      X
   \   000029 58           SLLW      X
   \   00002A 1C 1010      ADDW      X, #0x1010
   \   00002D 8D ......    CALLF     ?Subroutine79
    961              need_num = NumOfDeleteData+1;    
   \                     ??CrossCallReturnLabel_140:
   \   000031 B6 ..        LD        A, S:?b12
   \   000033 4C           INC       A
   \   000034 6B 01        LD        (0x1,SP), A
    962              for(i = 0 ; i < numNeedMove ; i++)
   \   000036 4F           CLR       A
   \   000037 AC ......    JPF       ??UpdateDatasAdressInFlash_0
   \                     ??UpdateDatasAdressInFlash_1:
   \   00003B 7B 01        LD        A, (0x1,SP)
   \   00003D 905F         CLRW      Y
   \   00003F 9097         LD        YL, A
   \   000041 8D ......    CALLF     ?Subroutine75
   \                     ??CrossCallReturnLabel_172:
   \   000045 BF ..        LDW       S:?w6, X
   \   000047 5C           INCW      X
   \   000048 8D ......    CALLF     ?Subroutine46
    963              {
    964                  //ID区域
    965                  FLASH_ProgramByte(need_adress,AllRadio[need_num].Id_part_1);
    966                  need_adress++;
    967                  FLASH_ProgramByte(need_adress,AllRadio[need_num].Id_part_2);
   \                     ??CrossCallReturnLabel_90:
   \   00004C 1C 0002      ADDW      X, #0x2
   \   00004F 8D ......    CALLF     ?Subroutine46
    968                  need_adress++;
    969                  FLASH_ProgramByte(need_adress,AllRadio[need_num].Id_part_3);
   \                     ??CrossCallReturnLabel_91:
   \   000053 1C 0003      ADDW      X, #0x3
   \   000056 8D ......    CALLF     ?Subroutine46
    970                  need_adress++;
    971                  FLASH_ProgramByte(need_adress,AllRadio[need_num].Id_part_4);
   \                     ??CrossCallReturnLabel_92:
   \   00005A 1C 0004      ADDW      X, #0x4
   \   00005D F6           LD        A, (X)
   \   00005E 8D ......    CALLF     ?Subroutine54
    972                  need_adress++;        
   \                     ??CrossCallReturnLabel_108:
   \   000062 8D ......    CALLF     L:?mov_l3_l2
    973                  // Line1 区域
    974                  FLASH_ProgramByte(need_adress,ABIO_Function[need_num].AI_Line1);
   \   000066 7B 01        LD        A, (0x1,SP)
   \   000068 905F         CLRW      Y
   \   00006A 9097         LD        YL, A
   \   00006C 8D ......    CALLF     ?Subroutine31
   \                     ??CrossCallReturnLabel_51:
   \   000070 92C6 ..      LD        A, [S:?w4.w]
   \   000073 8D ......    CALLF     L:?mov_l0_l3
   \   000077 8D ......    CALLF     FLASH_ProgramByte
    975                  need_adress++;
   \   00007B 8D ......    CALLF     L:?inc32_l3_l3
    976                  FLASH_ProgramByte(need_adress,ABIO_Function[need_num].AO_Line1);
   \   00007F BE ..        LDW       X, S:?w4
   \   000081 5C           INCW      X
   \   000082 8D ......    CALLF     ?Subroutine45
    977                  need_adress++;
    978                  FLASH_ProgramByte(need_adress,ABIO_Function[need_num].BI_Line1);
   \                     ??CrossCallReturnLabel_82:
   \   000086 1C 0002      ADDW      X, #0x2
   \   000089 8D ......    CALLF     ?Subroutine45
    979                  need_adress++;
    980                  FLASH_ProgramByte(need_adress,ABIO_Function[need_num].BO_Line1);   
   \                     ??CrossCallReturnLabel_83:
   \   00008D 1C 0003      ADDW      X, #0x3
   \   000090 8D ......    CALLF     ?Subroutine45
    981                  need_adress++;
    982                  FLASH_ProgramByte(need_adress,ABIO_Function[need_num].TOOGLE_Line1);
   \                     ??CrossCallReturnLabel_84:
   \   000094 1C 0004      ADDW      X, #0x4
   \   000097 8D ......    CALLF     ?Subroutine45
    983                  need_adress++;
    984                  //Line2 区域
    985                  FLASH_ProgramByte(need_adress,ABIO_Function[need_num].AI_Line2);
   \                     ??CrossCallReturnLabel_85:
   \   00009B 1C 0005      ADDW      X, #0x5
   \   00009E 8D ......    CALLF     ?Subroutine45
    986                  need_adress++;
    987                  FLASH_ProgramByte(need_adress,ABIO_Function[need_num].AO_Line2);
   \                     ??CrossCallReturnLabel_86:
   \   0000A2 1C 0006      ADDW      X, #0x6
   \   0000A5 8D ......    CALLF     ?Subroutine45
    988                  need_adress++;
    989                  FLASH_ProgramByte(need_adress,ABIO_Function[need_num].BI_Line2);
   \                     ??CrossCallReturnLabel_87:
   \   0000A9 1C 0007      ADDW      X, #0x7
   \   0000AC 8D ......    CALLF     ?Subroutine45
    990                  need_adress++;
    991                  FLASH_ProgramByte(need_adress,ABIO_Function[need_num].BO_Line2);   
   \                     ??CrossCallReturnLabel_88:
   \   0000B0 1C 0008      ADDW      X, #0x8
   \   0000B3 8D ......    CALLF     ?Subroutine45
    992                  need_adress++;
    993                  FLASH_ProgramByte(need_adress,ABIO_Function[need_num].TOOGLE_Line2);               
   \                     ??CrossCallReturnLabel_89:
   \   0000B7 1C 0009      ADDW      X, #0x9
   \   0000BA 8D ......    CALLF     ?Subroutine77
    994                       
    995                  need_adress+=0x3; 
   \                     ??CrossCallReturnLabel_136:
   \   0000BE AE 0003      LDW       X, #0x3
   \   0000C1 BF ..        LDW       S:?w3, X
   \   0000C3 5F           CLRW      X
   \   0000C4 BF ..        LDW       S:?w2, X
   \   0000C6 8D ......    CALLF     L:?mov_l0_l3
   \   0000CA 8D ......    CALLF     L:?add32_l0_l0_l1
   \   0000CE 8D ......    CALLF     L:?mov_l2_l0
    996                  need_num++;
   \   0000D2 7B 01        LD        A, (0x1,SP)
   \   0000D4 4C           INC       A
   \   0000D5 6B 01        LD        (0x1,SP), A
    997              }  
   \   0000D7 7B 02        LD        A, (0x2,SP)
   \   0000D9 4C           INC       A
   \                     ??UpdateDatasAdressInFlash_0:
   \   0000DA 6B 02        LD        (0x2,SP), A
   \   0000DC 11 03        CP        A, (0x3,SP)
   \   0000DE 24 03        JRNC      ??lb_9
   \   0000E0 CC ....      JP        L:??UpdateDatasAdressInFlash_1
    998              //将原来排在最后的删除
    999              need_adress = (IDSTARTADDRESS + 0x10 * (Public_learned_ID_num-1));
   \                     ??lb_9:
   \   0000E3 C6 ....      LD        A, L:Public_learned_ID_num
   \   0000E6 5F           CLRW      X
   \   0000E7 97           LD        XL, A
   \   0000E8 58           SLLW      X
   \   0000E9 58           SLLW      X
   \   0000EA 58           SLLW      X
   \   0000EB 58           SLLW      X
   \   0000EC 1C 1000      ADDW      X, #0x1000
   \   0000EF 8D ......    CALLF     ?Subroutine79
   1000              for(j=0;j<0x10;j++)
   \                     ??CrossCallReturnLabel_141:
   \   0000F3 35 10 ....   MOV       S:?b12, #0x10
   1001              {
   1002                  FLASH_ProgramByte(need_adress,0x00);
   \                     ??UpdateDatasAdressInFlash_2:
   \   0000F7 4F           CLR       A
   \   0000F8 8D ......    CALLF     ?Subroutine54
   1003                  need_adress++;    
   1004              }
   \                     ??CrossCallReturnLabel_109:
   \   0000FC B6 ..        LD        A, S:?b12
   \   0000FE 4A           DEC       A
   \   0000FF B7 ..        LD        S:?b12, A
   \   000101 26 F4        JRNE      L:??UpdateDatasAdressInFlash_2
   1005                  
   1006              //更新已学习数量在Flash中的数据
   1007              FLASH_ProgramByte(NEWIDADDRESSINFLASH_PART_2,0x10*Public_learned_ID_num);
   \   000103 C6 ....      LD        A, L:Public_learned_ID_num
   \   000106 4E           SWAP      A
   \   000107 A4 F0        AND       A, #0xf0
   \   000109 AE 1006      LDW       X, #0x1006
   \   00010C 8D ......    CALLF     ??Subroutine100_0
   1008              Public_learned_ID_num--;
   \                     ??CrossCallReturnLabel_223:
   \   000110 C6 ....      LD        A, L:Public_learned_ID_num
   \   000113 4A           DEC       A
   \   000114 8D ......    CALLF     ?Subroutine25
   1009              FLASH_ProgramByte(IDCOUNTADD,Public_learned_ID_num);     
   1010              
   1011              //更新本地数据     
   1012              Public_learned_ID_num = FLASH_ReadByte(IDCOUNTADD);
   \                     ??CrossCallReturnLabel_220:
   \   000118 8D ......    CALLF     ?Subroutine11
   1013              IdStartAddress = (FLASH_ReadByte(NEWIDADDRESSINFLASH_PART_1)<<8)+(FLASH_ReadByte(NEWIDADDRESSINFLASH_PART_2));    
   \                     ??CrossCallReturnLabel_12:
   \   00011C 905F         CLRW      Y
   \   00011E 9097         LD        YL, A
   \   000120 5F           CLRW      X
   \   000121 41           EXG       A, XL
   \   000122 B6 ..        LD        A, S:?b8
   \   000124 41           EXG       A, XL
   \   000125 4F           CLR       A
   \   000126 02           RLWA      X, A
   \   000127 90BF ..      LDW       S:?w0, Y
   \   00012A 72BB ....    ADDW      X, S:?w0
   \   00012E CF ....      LDW       L:IdStartAddress, X
   1014              for(i = 0;i < MAXLEARNNUM;i++)           //注意数组溢出   0x1100 -- 0x110F                           
   \   000131 3F ..        CLR       S:?b10
   1015              {
   1016                AllRadio[i].Id_part_1 = FLASH_ReadByte(flash_start);        //将Flash中ID读取到本地内存中
   \                     ??UpdateDatasAdressInFlash_3:
   \   000133 8D ......    CALLF     ?Subroutine28
   \                     ??CrossCallReturnLabel_44:
   \   000137 1E 04        LDW       X, (0x4,SP)
   \   000139 8D ......    CALLF     ?Subroutine26
   \                     ??CrossCallReturnLabel_40:
   \   00013D BE ..        LDW       X, S:?w4
   \   00013F 5C           INCW      X
   \   000140 F7           LD        (X), A
   1017                flash_start++;
   \   000141 1E 04        LDW       X, (0x4,SP)
   \   000143 8D ......    CALLF     ?Subroutine27
   1018                AllRadio[i].Id_part_2 = FLASH_ReadByte(flash_start);
   1019                flash_start++;
   1020                AllRadio[i].Id_part_3 = FLASH_ReadByte(flash_start);
   1021                flash_start++;
   1022                AllRadio[i].Id_part_4 = FLASH_ReadByte(flash_start);
   1023                flash_start++;
   1024                
   1025                ABIO_Function[i].AI_Line1 = FLASH_ReadByte(flash_start);    //将Flash中开关对应的动作读取到本地内存中
   1026                flash_start++;
   1027                ABIO_Function[i].AO_Line1 = FLASH_ReadByte(flash_start);
   1028                flash_start++;
   1029                ABIO_Function[i].BI_Line1 = FLASH_ReadByte(flash_start);
   1030                flash_start++;     
   1031                ABIO_Function[i].BO_Line1 = FLASH_ReadByte(flash_start);
   1032                flash_start++; 
   1033                ABIO_Function[i].TOOGLE_Line1 = FLASH_ReadByte(flash_start);
   1034                flash_start++;       
   1035                     
   1036                ABIO_Function[i].AI_Line2 = FLASH_ReadByte(flash_start);    
   1037                flash_start++;
   1038                ABIO_Function[i].AO_Line2 = FLASH_ReadByte(flash_start);
   1039                flash_start++;
   1040                ABIO_Function[i].BI_Line2 = FLASH_ReadByte(flash_start);
   1041                flash_start++;     
   1042                ABIO_Function[i].BO_Line2 = FLASH_ReadByte(flash_start);
   1043                flash_start++; 
   1044                ABIO_Function[i].TOOGLE_Line2 = FLASH_ReadByte(flash_start);
   1045                flash_start++;            
   1046                flash_start+=0x2;
   1047              }    
   \                     ??CrossCallReturnLabel_42:
   \   000147 1F 04        LDW       (0x4,SP), X
   \   000149 B6 ..        LD        A, S:?b10
   \   00014B 4C           INC       A
   \   00014C B7 ..        LD        S:?b10, A
   \   00014E A1 0A        CP        A, #0xa
   \   000150 25 E1        JRC       L:??UpdateDatasAdressInFlash_3
   1048                 
   1049              FLASH_Lock(FLASH_MemType_Data);   //锁定Flash  
   \   000152 8D ......    CALLF     ?Subroutine52
   1050          }
   \                     ??CrossCallReturnLabel_101:
   \   000156 5B 05        ADD       SP, #0x5
   \   000158 AC ......    JPF       L:?epilogue_l2_l3

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000 8D ......    CALLF     ?Subroutine80
   \                     ??CrossCallReturnLabel_146:
   \   000004 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000 8D ......    CALLF     L:?mov_l0_l2
   \   000004 8D ......    CALLF     FLASH_ProgramByte
   \   000008 AC ......    JPF       L:?inc32_l2_l2

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000 F6           LD        A, (X)
   \   000001 8D ......    CALLF     ?Subroutine80
   \                     ??CrossCallReturnLabel_145:
   \   000005 BE ..        LDW       X, S:?w6
   \   000007 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000 8D ......    CALLF     ?Subroutine77
   \                     ??CrossCallReturnLabel_135:
   \   000004 8D ......    CALLF     L:?inc32_l3_l3
   \   000008 BE ..        LDW       X, S:?w4
   \   00000A 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000 F6           LD        A, (X)
   \   000001 8D ......    CALLF     L:?mov_l0_l3
   \   000005 AC ......    JPF       FLASH_ProgramByte

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000 8D ......    CALLF     ?Subroutine76
   \                     ??CrossCallReturnLabel_180:
   \   000004 BF ..        LDW       S:?w4, X
   \   000006 87           RETF
   1051          
   1052          
   1053          /**
   1054          @function：清空Flash 
   1055          **/

   \                                 In section .far_func.text, align 1, keep-with-next
   1056          void ClearFlash(void)
   1057          {
   \                     ClearFlash:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 3B ....      PUSH      S:?b10
   1058              INT8U   i;
   1059              INT16U  add = IDSTARTADDRESS - 0x10;
   \   000007 AE 1000      LDW       X, #0x1000
   \   00000A BF ..        LDW       S:?w4, X
   1060              FLASH_Unlock(FLASH_MemType_Data);                     //解锁Flash
   \   00000C 8D ......    CALLF     ?Subroutine53
   1061              timer2_delay(1); 
   \                     ??CrossCallReturnLabel_107:
   \   000010 8D ......    CALLF     ??Subroutine102_0
   1062              FLASH_ProgramByte(IFFIRSTPOWERNUMADRESS,0x00);           //清空Flash相关的参数
   \                     ??CrossCallReturnLabel_234:
   \   000014 4F           CLR       A
   \   000015 AE 1002      LDW       X, #0x1002
   \   000018 8D ......    CALLF     ?Subroutine23
   \                     ??CrossCallReturnLabel_36:
   \   00001C AE 1005      LDW       X, #0x1005
   \   00001F 8D ......    CALLF     ?Subroutine24
   \                     ??CrossCallReturnLabel_38:
   \   000023 AE 1006      LDW       X, #0x1006
   \   000026 8D ......    CALLF     ?Subroutine24
   1063              FLASH_ProgramByte(NEWIDADDRESSINFLASH_PART_1,0x10);
   1064              FLASH_ProgramByte(NEWIDADDRESSINFLASH_PART_2,0x00);
   1065              FLASH_ProgramByte(IDCOUNTADD,0x00);
   \                     ??CrossCallReturnLabel_39:
   \   00002A 8D ......    CALLF     ??Subroutine99_0
   1066              for(i = 0 ; i <= MAXLEARNNUM * 0x10 ; i++)
   \                     ??CrossCallReturnLabel_222:
   \   00002E 35 A1 ....   MOV       S:?b10, #0xa1
   1067              {
   1068                  FLASH_ProgramByte(add,0x00);
   \                     ??ClearFlash_0:
   \   000032 4F           CLR       A
   \   000033 8D ......    CALLF     L:?mov_w1_w4
   \   000037 8D ......    CALLF     ??Subroutine101_0
   1069                  add ++ ;  
   \                     ??CrossCallReturnLabel_227:
   \   00003B BE ..        LDW       X, S:?w4
   \   00003D 5C           INCW      X
   \   00003E BF ..        LDW       S:?w4, X
   1070              }
   \   000040 B6 ..        LD        A, S:?b10
   \   000042 4A           DEC       A
   \   000043 B7 ..        LD        S:?b10, A
   \   000045 26 EB        JRNE      L:??ClearFlash_0
   1071              for(i = 0 ; i < MAXLEARNNUM ; i ++)
   \   000047 3F ..        CLR       S:?b2
   1072              {   //清空本地中的数据
   1073                  AllRadio[i].Id_part_1 = 0x00; 
   \                     ??ClearFlash_1:
   \   000049 905F         CLRW      Y
   \   00004B 61           EXG       A, YL
   \   00004C B6 ..        LD        A, S:?b2
   \   00004E 8D ......    CALLF     ?Subroutine30
   \                     ??CrossCallReturnLabel_170:
   \   000052 4F           CLR       A
   \   000053 8D ......    CALLF     ?Subroutine47
   1074                  AllRadio[i].Id_part_2 = 0x00;
   \                     ??CrossCallReturnLabel_164:
   \   000057 8D ......    CALLF     ?Subroutine48
   1075                  AllRadio[i].Id_part_3 = 0x00;
   \                     ??CrossCallReturnLabel_159:
   \   00005B 90F7         LD        (Y), A
   1076                  AllRadio[i].Id_part_4 = 0x00;
   \   00005D 1C 0004      ADDW      X, #0x4
   \   000060 F7           LD        (X), A
   1077              }
   \   000061 B6 ..        LD        A, S:?b2
   \   000063 4C           INC       A
   \   000064 B7 ..        LD        S:?b2, A
   \   000066 A1 0A        CP        A, #0xa
   \   000068 25 DF        JRC       L:??ClearFlash_1
   1078                 
   1079              FLASH_Lock(FLASH_MemType_Data);                       //锁定Flash
   \   00006A 8D ......    CALLF     ?Subroutine52
   1080          }
   \                     ??CrossCallReturnLabel_102:
   \   00006E 32 ....      POP       S:?b10
   \   000071 AC ......    JPF       L:?epilogue_w4

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000 8D ......    CALLF     ?Subroutine74
   \                     ??CrossCallReturnLabel_230:
   \   000004 4F           CLR       A
   \   000005 87           RETF
   1081          
   1082          
   1083          /**
   1084          @function：将设备自身信息广播 
   1085          **/

   \                                 In section .far_func.text, align 1, keep-with-next
   1086          void Broadcast_info(void)
   1087          {
   \                     Broadcast_info:
   \   000000 52 06        SUB       SP, #0x6
   1088              INT8U broadcast_data[6]={0x1,DEVICE_ID_4,DEVICE_ID_3,DEVICE_ID_2,DEVICE_ID_1,DEVICE_TYPE};
   \   000002 90AE ....    LDW       Y, #?_1
   \   000006 96           LDW       X, SP
   \   000007 5C           INCW      X
   \   000008 89           PUSHW     X
   \   000009 A6 06        LD        A, #0x6
   \   00000B 8D ......    CALLF     L:?move1616_v_x_y_a
   \   00000F 85           POPW      X
   1089              halRfSendPacket( broadcast_data, 6 );
   \   000010 A6 06        LD        A, #0x6
   \   000012 96           LDW       X, SP
   \   000013 5C           INCW      X
   \   000014 8D ......    CALLF     halRfSendPacket
   1090          }
   \   000018 5B 06        ADD       SP, #0x6
   \   00001A 87           RETF
   1091          
   1092          /**
   1093          @function：学习模式中  按键 & 指示灯  处理函数 
   1094          **/

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000 3F ..        CLR       S:?b3
   \   000002 3F ..        CLR       S:?b2
   \   000004 3F ..        CLR       S:?b1
   \   000006 3F ..        CLR       S:?b0
   \   000008 4F           CLR       A
   \   000009 AC ......    JPF       ControlByAirLearn_NewWriteInFlash

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000 C6 ....      LD        A, L:Radio_Data + 4
   \   000003 B7 ..        LD        S:?b2, A
   \   000005 C6 ....      LD        A, L:Radio_Data + 3
   \   000008 B7 ..        LD        S:?b1, A
   \   00000A C6 ....      LD        A, L:Radio_Data + 2
   \   00000D B7 ..        LD        S:?b0, A
   \   00000F C6 ....      LD        A, L:Radio_Data + 1
   \   000012 AC ......    JPF       FindIdInFlash

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000 8D ......    CALLF     ?Subroutine62
   \                     ??CrossCallReturnLabel_297:
   \   000004 AC ......    JPF       Led1_Off

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000 8D ......    CALLF     ?Subroutine71
   \                     ??CrossCallReturnLabel_131:
   \   000004 87           RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000 A6 10        LD        A, #0x10
   \   000002 8D ......    CALLF     ?Subroutine68
   \                     ??CrossCallReturnLabel_303:
   \   000006 AC ......    JPF       Led2_Off

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000 AE 00C8      LDW       X, #0xc8
   \   000003              REQUIRE ??Subroutine103_0
   \   000003              ;               // Fall through to label ??Subroutine103_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000 A6 40        LD        A, #0x40
   \   000002              REQUIRE ??Subroutine104_0
   \   000002              ;               // Fall through to label ??Subroutine104_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000 A6 80        LD        A, #0x80
   \   000002              REQUIRE ??Subroutine86_0
   \   000002              ;               // Fall through to label ??Subroutine86_0

   \                                 In section .far_func.text, align 1
   1095          void LearnMode_Function(void)
   1096          {
   \                     LearnMode_Function:
   \   000000 3B ....      PUSH      S:?b8
   1097              INT8U findInFlashReturnAdress = 0;
   1098              if(learn_mode == ON )
   \   000003 C6 ....      LD        A, L:learn_mode
   \   000006 A1 11        CP        A, #0x11
   \   000008 27 03        JREQ      ??lb_7
   \   00000A CC ....      JP        L:??CrossCallReturnLabel_2
   1099              {
   1100                  /* 按键1短按按下确认   在双路中循环    */
   1101                  if( (Key1_Short_Pushed == 1) && (LearnModeWaitForConfirm == OFF) )   //处于非确认等待期间
   \                     ??lb_7:
   \   00000D C6 ....      LD        A, L:Key1_Short_Pushed
   \   000010 A1 01        CP        A, #0x1
   \   000012 26 2A        JRNE      L:??LearnMode_Function_0
   \   000014 C6 ....      LD        A, L:LearnModeWaitForConfirm
   \   000017 A1 10        CP        A, #0x10
   \   000019 26 23        JRNE      L:??LearnMode_Function_0
   1102                  {    
   1103                      Key1_Short_Pushed = 0;                       //短按按键1标识清零
   \   00001B 725F ....    CLR       L:Key1_Short_Pushed
   1104                      switch(Choose_Line)
   \   00001F C6 ....      LD        A, L:Choose_Line
   \   000022 4A           DEC       A
   \   000023 27 05        JREQ      L:??LearnMode_Function_1
   \   000025 4A           DEC       A
   \   000026 27 0C        JREQ      L:??LearnMode_Function_2
   \   000028 20 14        JRA       L:??LearnMode_Function_0
   1105                      {
   1106                          case 1:
   1107                            {
   1108                                CLOSE_LINE1;
   \                     ??LearnMode_Function_1:
   \   00002A 8D ......    CALLF     ?Subroutine33
   1109                                Led1_Off();
   1110                                Choose_Line = 2;
   \                     ??CrossCallReturnLabel_59:
   \   00002E 35 02 ....   MOV       L:Choose_Line, #0x2
   1111                                break;                  
   \   000032 20 4D        JRA       L:??LearnMode_Function_3
   1112                            }
   1113                          case 2:
   1114                            {
   1115                                CLOSE_LINE2;
   \                     ??LearnMode_Function_2:
   \   000034 8D ......    CALLF     ?Subroutine14
   1116                                Led2_Off();                 
   1117                                Choose_Line = 1;
   \                     ??CrossCallReturnLabel_20:
   \   000038 35 01 ....   MOV       L:Choose_Line, #0x1
   1118                                break;
   \   00003C 20 07        JRA       L:??LearnMode_Function_4
   1119                            }
   1120                      }                 
   1121                  }   
   1122                  /* 学习模式时 LED指示灯与继电器提示  */
   1123                  if(Choose_Line == 1)
   \                     ??LearnMode_Function_0:
   \   00003E C6 ....      LD        A, L:Choose_Line
   \   000041 A1 01        CP        A, #0x1
   \   000043 26 38        JRNE      L:??LearnMode_Function_5
   1124                  {
   1125                      if(led_blink_time == 0x50)
   \                     ??LearnMode_Function_4:
   \   000045 C6 ....      LD        A, L:led_blink_time
   \   000048 A1 50        CP        A, #0x50
   \   00004A 26 74        JRNE      L:??CrossCallReturnLabel_19
   1126                      { 
   1127                          led_blink_time = 0;
   \   00004C 725F ....    CLR       L:led_blink_time
   1128                          if(GPIO_ReadOutputDataBit(LINE1_PORT, LINE1_PIN) == 0 )
   \   000050 A6 80        LD        A, #0x80
   \   000052 AE 5005      LDW       X, #0x5005
   \   000055 8D ......    CALLF     GPIO_ReadOutputDataBit
   \   000059 A1 00        CP        A, #0x0
   \   00005B 26 1A        JRNE      L:??LearnMode_Function_6
   1129                          {
   1130                              OPEN_LINE1;
   \   00005D 8D ......    CALLF     ?Subroutine10
   1131                              if(LearnModeWaitForConfirm == OFF)
   \                     ??CrossCallReturnLabel_156:
   \   000061 C6 ....      LD        A, L:LearnModeWaitForConfirm
   \   000064 A1 10        CP        A, #0x10
   \   000066 26 04        JRNE      L:??LearnMode_Function_7
   1132                              {LED1_GREEN;}
   \   000068 A6 04        LD        A, #0x4
   \   00006A 20 06        JRA       ??LearnMode_Function_8
   1133                              else  if(LearnModeWaitForConfirm == ON)           //处于等待学习确认阶段，闪蓝色LED
   \                     ??LearnMode_Function_7:
   \   00006C A1 11        CP        A, #0x11
   \   00006E 26 50        JRNE      L:??CrossCallReturnLabel_19
   1134                              {LED1_BLUE;}
   \   000070 A6 01        LD        A, #0x1
   \                     ??LearnMode_Function_8:
   \   000072 AE 5000      LDW       X, #0x5000
   \   000075 20 3F        JRA       ??LearnMode_Function_9
   1135                          }
   1136                          else
   1137                          {
   1138                              CLOSE_LINE1;
   \                     ??LearnMode_Function_6:
   \   000077 8D ......    CALLF     ?Subroutine33
   1139                              Led1_Off();
   1140                          }               
   1141                      }        
   1142                  }
   \                     ??CrossCallReturnLabel_58:
   \   00007B 20 43        JRA       L:??CrossCallReturnLabel_19
   1143                  else if(Choose_Line==2)
   \                     ??LearnMode_Function_5:
   \   00007D A1 02        CP        A, #0x2
   \   00007F 26 3F        JRNE      L:??CrossCallReturnLabel_19
   1144                  {
   1145                      if(led_blink_time==0x50)
   \                     ??LearnMode_Function_3:
   \   000081 C6 ....      LD        A, L:led_blink_time
   \   000084 A1 50        CP        A, #0x50
   \   000086 26 38        JRNE      L:??CrossCallReturnLabel_19
   1146                      { 
   1147                          led_blink_time=0;
   \   000088 725F ....    CLR       L:led_blink_time
   1148                          if(GPIO_ReadOutputDataBit(LINE2_PORT, LINE2_PIN)==0 )
   \   00008C A6 10        LD        A, #0x10
   \   00008E AE 500A      LDW       X, #0x500a
   \   000091 8D ......    CALLF     GPIO_ReadOutputDataBit
   \   000095 A1 00        CP        A, #0x0
   \   000097 26 23        JRNE      L:??LearnMode_Function_10
   1149                          {
   1150                              OPEN_LINE2;
   \   000099 A6 10        LD        A, #0x10
   \   00009B 8D ......    CALLF     ??Subroutine104_0
   1151                              if(LearnModeWaitForConfirm == OFF)
   \                     ??CrossCallReturnLabel_253:
   \   00009F C6 ....      LD        A, L:LearnModeWaitForConfirm
   \   0000A2 A1 10        CP        A, #0x10
   \   0000A4 26 07        JRNE      L:??LearnMode_Function_11
   1152                              {LED2_GREEN;}
   \   0000A6 A6 40        LD        A, #0x40
   \   0000A8 AE 500A      LDW       X, #0x500a
   \   0000AB 20 09        JRA       ??LearnMode_Function_9
   1153                              else if(LearnModeWaitForConfirm == ON)
   \                     ??LearnMode_Function_11:
   \   0000AD A1 11        CP        A, #0x11
   \   0000AF 26 0F        JRNE      L:??CrossCallReturnLabel_19
   1154                              {LED2_BLUE;}
   \   0000B1 A6 02        LD        A, #0x2
   \   0000B3 AE 5005      LDW       X, #0x5005
   \                     ??LearnMode_Function_9:
   \   0000B6 8D ......    CALLF     GPIO_SetBits
   \   0000BA 20 04        JRA       L:??CrossCallReturnLabel_19
   1155                          }
   1156                          else
   1157                          {
   1158                              CLOSE_LINE2;
   \                     ??LearnMode_Function_10:
   \   0000BC 8D ......    CALLF     ?Subroutine14
   1159                              Led2_Off();
   1160                          }               
   1161                      }        
   1162                  }        
   1163                  /*  学习模式时，用于确认 */
   1164                  if((Key1_Short_Pushed == 1) && (LearnModeWaitForConfirm == ON))               //若key1按键按下，则已经确认，则将报文信息写入Flash
   \                     ??CrossCallReturnLabel_19:
   \   0000C0 C6 ....      LD        A, L:Key1_Short_Pushed
   \   0000C3 A1 01        CP        A, #0x1
   \   0000C5 26 68        JRNE      L:??LearnMode_Function_12
   \   0000C7 C6 ....      LD        A, L:LearnModeWaitForConfirm
   \   0000CA A1 11        CP        A, #0x11
   \   0000CC 26 61        JRNE      L:??LearnMode_Function_12
   1165                  {
   1166                      TIM4_Cmd(DISABLE);                     //关闭定时器                  
   \   0000CE 4F           CLR       A
   \   0000CF 8D ......    CALLF     TIM4_Cmd
   1167                      LearnModeWaitForConfirm = OFF;         //已经确认，取消等待状态
   \   0000D3 35 10 ....   MOV       L:LearnModeWaitForConfirm, #0x10
   1168                      learn_mode              = OFF;         //退出学习模式，进入工作模式 
   \   0000D7 35 10 ....   MOV       L:learn_mode, #0x10
   1169                      SaveInfoInFlash();                     //保存信息  ************          
   \   0000DB 8D ......    CALLF     SaveInfoInFlash
   1170                      Key1_Short_Pushed = 0;Key2_Short_Pushed = 0;    
   \   0000DF 8D ......    CALLF     ?Subroutine78
   1171                                
   1172                      //led提示写入成功
   1173                      if(Choose_Line == 1)
   \                     ??CrossCallReturnLabel_137:
   \   0000E3 C6 ....      LD        A, L:Choose_Line
   \   0000E6 A1 01        CP        A, #0x1
   \   0000E8 27 19        JREQ      L:??CrossCallReturnLabel_27
   1174                      {                
   1175                          while(led_flash < 5)
   1176                          {
   1177                              LED1_GREEN;
   1178                              timer2_delay(200);             //203.2ms
   1179                              Led1_Off();
   1180                              timer2_delay(200);
   1181                              led_flash++;
   1182                          }
   1183                          led_flash = 0;                                
   1184                      }
   1185                      else if(Choose_Line == 2)
   \   0000EA A1 02        CP        A, #0x2
   \   0000EC 27 03        JREQ      ??lb_8
   \   0000EE CC ....      JP        L:??CrossCallReturnLabel_2
   \                     ??lb_8:
   \   0000F1 20 2D        JRA       L:??CrossCallReturnLabel_28
   \                     ??LearnMode_Function_13:
   \   0000F3 8D ......    CALLF     ??Subroutine84_0
   \                     ??CrossCallReturnLabel_151:
   \   0000F7 8D ......    CALLF     ?Subroutine18
   \                     ??CrossCallReturnLabel_241:
   \   0000FB 8D ......    CALLF     Led1_Off
   \   0000FF 8D ......    CALLF     ?Subroutine17
   \                     ??CrossCallReturnLabel_27:
   \   000103 C6 ....      LD        A, L:led_flash
   \   000106 A1 05        CP        A, #0x5
   \   000108 25 E9        JRC       L:??LearnMode_Function_13
   \   00010A 725F ....    CLR       L:led_flash
   \   00010E 20 1F        JRA       L:??LearnMode_Function_12
   1186                      {
   1187                          while(led_flash < 5)
   1188                          {
   1189                              LED2_GREEN;
   \                     ??LearnMode_Function_14:
   \   000110 8D ......    CALLF     ?Subroutine9
   1190                              timer2_delay(200);             //203.2ms
   \                     ??CrossCallReturnLabel_256:
   \   000114 8D ......    CALLF     ?Subroutine18
   1191                              Led2_Off();
   \                     ??CrossCallReturnLabel_242:
   \   000118 8D ......    CALLF     Led2_Off
   1192                              timer2_delay(200);
   \   00011C 8D ......    CALLF     ?Subroutine17
   1193                              led_flash++;
   1194                          }
   \                     ??CrossCallReturnLabel_28:
   \   000120 C6 ....      LD        A, L:led_flash
   \   000123 A1 05        CP        A, #0x5
   \   000125 25 E9        JRC       L:??LearnMode_Function_14
   1195                          led_flash = 0;
   \   000127 725F ....    CLR       L:led_flash
   1196                          Choose_Line = 1;    
   \   00012B 35 01 ....   MOV       L:Choose_Line, #0x1
   1197                      }                        
   1198                  }   
   1199                  /*  学习模式时，用于删除 */  
   1200                  if((Key2_Short_Pushed == 1) && (LearnModeWaitForConfirm == ON))                      
   \                     ??LearnMode_Function_12:
   \   00012F C6 ....      LD        A, L:Key2_Short_Pushed
   \   000132 A1 01        CP        A, #0x1
   \   000134 26 57        JRNE      L:??CrossCallReturnLabel_55
   \   000136 C6 ....      LD        A, L:LearnModeWaitForConfirm
   \   000139 A1 11        CP        A, #0x11
   \   00013B 26 57        JRNE      L:??LearnMode_Function_15
   1201                  {
   1202                      //学习模式等待确认期间，按下按键2，   则删除该条目    退出确认模式，返回学习模式，
   1203                      LearnModeWaitForConfirm = OFF; 
   \   00013D 35 10 ....   MOV       L:LearnModeWaitForConfirm, #0x10
   1204                      Key1_Short_Pushed    = 0;
   \   000141 8D ......    CALLF     ?Subroutine49
   1205                      Key2_Short_Pushed    = 0;
   1206                      Choose_Line = 1;
   1207                      WaitForConfirm_time  = 0; 
   \                     ??CrossCallReturnLabel_93:
   \   000145 8D ......    CALLF     ?Subroutine29
   1208                      learn_mode           = OFF;             
   \                     ??CrossCallReturnLabel_47:
   \   000149 35 10 ....   MOV       L:learn_mode, #0x10
   1209                      //todo 确认期间按下key2 则删除该条目 
   1210                      findInFlashReturnAdress = FindIdInFlash(Radio_Data[1],Radio_Data[2],Radio_Data[3],Radio_Data[4]);
   \   00014D 8D ......    CALLF     ?Subroutine35
   \                     ??CrossCallReturnLabel_64:
   \   000151 B7 ..        LD        S:?b8, A
   1211                      if(findInFlashReturnAdress != FINDINFLASH_FAIL)  
   \   000153 A1 77        CP        A, #0x77
   \   000155 27 32        JREQ      L:??LearnMode_Function_16
   1212                      {
   1213                          ControlByAirLearn_NewWriteInFlash(0x00,0x00,0x00,0x00,0x00, LINE_1, findInFlashReturnAdress );  //对数据区域写 0x00
   \   000157 45 .. ..     MOV       S:?b5, S:?b8
   \   00015A 8D ......    CALLF     ?Subroutine36
   1214                          ControlByAirLearn_NewWriteInFlash(0x00,0x00,0x00,0x00,0x00, LINE_2, findInFlashReturnAdress );                                
   \                     ??CrossCallReturnLabel_67:
   \   00015E 45 .. ..     MOV       S:?b5, S:?b8
   \   000161 8D ......    CALLF     ?Subroutine37
   1215                          //更新Flash中所有条目的排位
   1216                          UpdateDatasAdressInFlash(findInFlashReturnAdress);
   \                     ??CrossCallReturnLabel_69:
   \   000165 B6 ..        LD        A, S:?b8
   \   000167 8D ......    CALLF     UpdateDatasAdressInFlash
   \   00016B 20 0F        JRA       L:??CrossCallReturnLabel_0
   1217                          //led提示删除成功               
   1218                          while(led_flash < 4)
   1219                          {
   1220                              LED1_RED;LED2_RED;
   \                     ??LearnMode_Function_17:
   \   00016D A6 08        LD        A, #0x8
   \   00016F 8D ......    CALLF     ??Subroutine85_0
   \                     ??CrossCallReturnLabel_149:
   \   000173 A6 20        LD        A, #0x20
   \   000175 AE 500A      LDW       X, #0x500a
   \   000178 8D ......    CALLF     ?Subroutine0
   1221                              timer2_delay(200);             //203.2ms
   1222                              Led1_Off();Led2_Off();
   1223                              timer2_delay(200);
   1224                              led_flash++;
   1225                          }
   \                     ??CrossCallReturnLabel_0:
   \   00017C C6 ....      LD        A, L:led_flash
   \   00017F A1 04        CP        A, #0x4
   \   000181 25 EA        JRC       L:??LearnMode_Function_17
   1226                          led_flash = 0;                                        
   \   000183 725F ....    CLR       L:led_flash
   \   000187 20 04        JRA       L:??CrossCallReturnLabel_55
   1227                      }
   1228                      else if(findInFlashReturnAdress == FINDINFLASH_FAIL)
   1229                      {  
   1230                          Led1_Off();Led2_Off();
   \                     ??LearnMode_Function_16:
   \   000189 8D ......    CALLF     ?Subroutine32
   1231                      }
   1232                  }       
   1233                  // 非确认期间 按下按键2 则退出学习模式
   1234                  if((Key2_Short_Pushed == 1) && (LearnModeWaitForConfirm == OFF) )         
   \                     ??CrossCallReturnLabel_55:
   \   00018D C6 ....      LD        A, L:Key2_Short_Pushed
   \   000190 A1 01        CP        A, #0x1
   \   000192 26 1C        JRNE      L:??CrossCallReturnLabel_2
   \                     ??LearnMode_Function_15:
   \   000194 C6 ....      LD        A, L:LearnModeWaitForConfirm
   \   000197 A1 10        CP        A, #0x10
   \   000199 26 15        JRNE      L:??CrossCallReturnLabel_2
   1235                  {
   1236                      TIM4_Cmd(DISABLE);                     //关闭定时器
   \   00019B 4F           CLR       A
   \   00019C 8D ......    CALLF     TIM4_Cmd
   1237                      learn_mode              = OFF;         //退出学习模式，进入工作模式 
   \   0001A0 35 10 ....   MOV       L:learn_mode, #0x10
   1238                      Key1_Short_Pushed = 0;  Key2_Short_Pushed = 0;
   \   0001A4 8D ......    CALLF     ?Subroutine49
   1239                      Choose_Line = 1;
   1240                      Led1_Off();Led2_Off();
   \                     ??CrossCallReturnLabel_94:
   \   0001A8 8D ......    CALLF     ?Subroutine32
   1241                      LED1_BLUE; LED2_BLUE;
   \                     ??CrossCallReturnLabel_54:
   \   0001AC 8D ......    CALLF     ?Subroutine1
   1242                      timer2_delay(100);
   1243                      Led1_Off();Led2_Off();          
   1244                  }        
   1245              }
   1246          }
   \                     ??CrossCallReturnLabel_2:
   \   0001B0 32 ....      POP       S:?b8
   \   0001B3 87           RETF

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine49:
   \   000000 8D ......    CALLF     ?Subroutine78
   \                     ??CrossCallReturnLabel_138:
   \   000004 35 01 ....   MOV       L:Choose_Line, #0x1
   \   000008 87           RETF

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine37:
   \   000000 35 17 ....   MOV       S:?b4, #0x17
   \   000004 8D ......    CALLF     ?Subroutine65
   \                     ??CrossCallReturnLabel_126:
   \   000008 87           RETF

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine36:
   \   000000 35 16 ....   MOV       S:?b4, #0x16
   \   000004 8D ......    CALLF     ?Subroutine65
   \                     ??CrossCallReturnLabel_125:
   \   000008 87           RETF
   1247          
   1248          
   1249          /**
   1250          @function：学习模式中  确认后，保存信息 
   1251          **/

   \                                 In section .far_func.text, align 1
   1252          void SaveInfoInFlash(void)
   1253          {
   \                     SaveInfoInFlash:
   \   000000 8D ......    CALLF     L:?push_l2
   1254              FindIdInFlash_return_num = FindIdInFlash(Radio_Data[1],Radio_Data[2],Radio_Data[3],Radio_Data[4]);   //在本地查找是否已经记录过该ID对应的设备
   \   000004 C6 ....      LD        A, L:Radio_Data + 1
   \   000007 B7 ..        LD        S:?b8, A
   \   000009 C6 ....      LD        A, L:Radio_Data + 2
   \   00000C B7 ..        LD        S:?b9, A
   \   00000E C6 ....      LD        A, L:Radio_Data + 3
   \   000011 B7 ..        LD        S:?b10, A
   \   000013 C6 ....      LD        A, L:Radio_Data + 4
   \   000016 B7 ..        LD        S:?b11, A
   \   000018 8D ......    CALLF     ?Subroutine50
   \                     ??CrossCallReturnLabel_95:
   \   00001C 8D ......    CALLF     FindIdInFlash
   \   000020 C7 ....      LD        L:FindIdInFlash_return_num, A
   1255                             
   1256              if(FindIdInFlash_return_num == FINDINFLASH_FAIL)                             //在Flash中没有找到ID,这是一个新的开关   
   \   000023 A1 77        CP        A, #0x77
   \   000025 26 0E        JRNE      L:??SaveInfoInFlash_0
   1257              {   
   1258                  WriteIdInFlash(Radio_Data[1],Radio_Data[2],Radio_Data[3],Radio_Data[4]);                         //将ID写入Flash
   \   000027 8D ......    CALLF     ?Subroutine50
   \                     ??CrossCallReturnLabel_96:
   \   00002B 8D ......    CALLF     WriteIdInFlash
   1259                  IdNum = Public_learned_ID_num - 1;
   \   00002F C6 ....      LD        A, L:Public_learned_ID_num
   \   000032 4A           DEC       A
   \   000033 20 04        JRA       ??SaveInfoInFlash_1
   1260              }
   1261              else if( FindIdInFlash_return_num <= MAXLEARNNUM )
   \                     ??SaveInfoInFlash_0:
   \   000035 A1 0B        CP        A, #0xb
   \   000037 24 03        JRNC      L:??SaveInfoInFlash_2
   \                     ??SaveInfoInFlash_1:
   \   000039 C7 ....      LD        L:IdNum, A
   1262              {                 
   1263                  IdNum = FindIdInFlash_return_num;
   1264              }               
   1265              //判断在学习模式时，选择的是哪个回路        
   1266              if(Choose_Line == 1)           
   \                     ??SaveInfoInFlash_2:
   \   00003C C6 ....      LD        A, L:Radio_Data + 6
   \   00003F B7 ..        LD        S:?b0, A
   \   000041 C6 ....      LD        A, L:Choose_Line
   \   000044 A1 01        CP        A, #0x1
   \   000046 26 3C        JRNE      L:??SaveInfoInFlash_3
   1267              {
   1268                  //TODO 将开关的按键操作写入Flash
   1269                  switch(Radio_Data[6])      //开关中的DATA位包含按键的键值   
   \   000048 B6 ..        LD        A, S:?b0
   \   00004A A1 10        CP        A, #0x10
   \   00004C 27 12        JREQ      L:??SaveInfoInFlash_4
   \   00004E A1 20        CP        A, #0x20
   \   000050 27 20        JREQ      L:??SaveInfoInFlash_5
   \   000052 A1 30        CP        A, #0x30
   \   000054 27 0A        JREQ      L:??SaveInfoInFlash_4
   \   000056 A1 50        CP        A, #0x50
   \   000058 27 0F        JREQ      L:??SaveInfoInFlash_6
   \   00005A A1 70        CP        A, #0x70
   \   00005C 27 0B        JREQ      L:??SaveInfoInFlash_6
   \   00005E 20 1D        JRA       L:??SaveInfoInFlash_7
   1270                  {
   1271                      case AI:       //AI
   1272                      {  WriteKeyOperationInFlash(A_LINE1,IdNum);  break;}                                                           
   1273                      case AO:       //AO
   1274                      {  WriteKeyOperationInFlash(A_LINE1,IdNum);  break;}                                                              
   \                     ??SaveInfoInFlash_4:
   \   000060 C6 ....      LD        A, L:IdNum
   \   000063 B7 ..        LD        S:?b0, A
   \   000065 A6 11        LD        A, #0x11
   \   000067 20 10        JRA       ??SaveInfoInFlash_8
   1275                      case BI:       //BI
   1276                      {  WriteKeyOperationInFlash(B_LINE1,IdNum);  break;}                             
   1277                      case BO:       //BO
   1278                      {  WriteKeyOperationInFlash(B_LINE1,IdNum);  break;} 
   \                     ??SaveInfoInFlash_6:
   \   000069 C6 ....      LD        A, L:IdNum
   \   00006C B7 ..        LD        S:?b0, A
   \   00006E A6 12        LD        A, #0x12
   \   000070 20 07        JRA       ??SaveInfoInFlash_8
   1279                                       
   1280                      case ABIO_TOOGLE:       
   1281                      {  WriteKeyOperationInFlash(ABIO_TOOGLE_LINE1,IdNum);  break;  }               
   \                     ??SaveInfoInFlash_5:
   \   000072 C6 ....      LD        A, L:IdNum
   \   000075 B7 ..        LD        S:?b0, A
   \   000077 A6 18        LD        A, #0x18
   \                     ??SaveInfoInFlash_8:
   \   000079 8D ......    CALLF     WriteKeyOperationInFlash
   1282                      default:{}                            
   1283                  }                       
   1284                  OPEN_LINE1;          //打开Line1
   \                     ??SaveInfoInFlash_7:
   \   00007D A6 80        LD        A, #0x80
   \   00007F AE 5005      LDW       X, #0x5005
   \   000082 20 3E        JRA       ??SaveInfoInFlash_9
   1285                  Led1_Off();          //关闭两个LED灯   
   1286                  Led2_Off();                     
   1287              }    
   1288              else if(Choose_Line==2)
   \                     ??SaveInfoInFlash_3:
   \   000084 A1 02        CP        A, #0x2
   \   000086 26 42        JRNE      L:??CrossCallReturnLabel_56
   1289              {
   1290                  switch(Radio_Data[6])       //开关中的DATA位   
   \   000088 B6 ..        LD        A, S:?b0
   \   00008A A1 10        CP        A, #0x10
   \   00008C 27 12        JREQ      L:??SaveInfoInFlash_10
   \   00008E A1 20        CP        A, #0x20
   \   000090 27 20        JREQ      L:??SaveInfoInFlash_11
   \   000092 A1 30        CP        A, #0x30
   \   000094 27 0A        JREQ      L:??SaveInfoInFlash_10
   \   000096 A1 50        CP        A, #0x50
   \   000098 27 0F        JREQ      L:??SaveInfoInFlash_12
   \   00009A A1 70        CP        A, #0x70
   \   00009C 27 0B        JREQ      L:??SaveInfoInFlash_12
   \   00009E 20 1D        JRA       L:??SaveInfoInFlash_13
   1291                  {
   1292                      case AI:       // AI
   1293                      {  WriteKeyOperationInFlash(A_LINE2,IdNum);  break;}                                                             
   1294                      case AO:       //AO
   1295                      {  WriteKeyOperationInFlash(A_LINE2,IdNum);  break;}                                                              
   \                     ??SaveInfoInFlash_10:
   \   0000A0 C6 ....      LD        A, L:IdNum
   \   0000A3 B7 ..        LD        S:?b0, A
   \   0000A5 A6 13        LD        A, #0x13
   \   0000A7 20 10        JRA       ??SaveInfoInFlash_14
   1296                      case BI:       //BI
   1297                      {  WriteKeyOperationInFlash(B_LINE2,IdNum);  break;}                             
   1298                      case BO:       //BO
   1299                      {  WriteKeyOperationInFlash(B_LINE2,IdNum);  break;} 
   \                     ??SaveInfoInFlash_12:
   \   0000A9 C6 ....      LD        A, L:IdNum
   \   0000AC B7 ..        LD        S:?b0, A
   \   0000AE A6 14        LD        A, #0x14
   \   0000B0 20 07        JRA       ??SaveInfoInFlash_14
   1300                      case ABIO_TOOGLE:       
   1301                      {  WriteKeyOperationInFlash(ABIO_TOOGLE_LINE2,IdNum);  break;  }             
   \                     ??SaveInfoInFlash_11:
   \   0000B2 C6 ....      LD        A, L:IdNum
   \   0000B5 B7 ..        LD        S:?b0, A
   \   0000B7 A6 19        LD        A, #0x19
   \                     ??SaveInfoInFlash_14:
   \   0000B9 8D ......    CALLF     WriteKeyOperationInFlash
   1302                      default:{}    
   1303                  }
   1304                  OPEN_LINE2;         //打开Line2
   \                     ??SaveInfoInFlash_13:
   \   0000BD A6 10        LD        A, #0x10
   \   0000BF AE 500A      LDW       X, #0x500a
   \                     ??SaveInfoInFlash_9:
   \   0000C2 8D ......    CALLF     GPIO_SetBits
   1305                  Led1_Off();         //关闭两个LED灯   
   \   0000C6 8D ......    CALLF     ?Subroutine32
   1306                  Led2_Off();                     
   1307              }              
   1308          }
   \                     ??CrossCallReturnLabel_56:
   \   0000CA AC ......    JPF       L:?epilogue_l2

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine50:
   \   000000 45 .. ..     MOV       S:?b2, S:?b11
   \   000003 45 .. ..     MOV       S:?b1, S:?b10
   \   000006 45 .. ..     MOV       S:?b0, S:?b9
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B 87           RETF
   1309          
   1310          
   1311          /**
   1312          @function： 报文接收正确后  正常工作模式   执行对继电器的操作 
   1313          @parameter：Key_num 接收到的报文对应的键值
   1314          @parameter：AdressOfData 接收的报文在Flash中条目的编号
   1315          **/

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000 A6 80        LD        A, #0x80
   \   000002 8D ......    CALLF     ??Subroutine108_0
   \                     ??CrossCallReturnLabel_279:
   \   000006              REQUIRE ??Subroutine84_0
   \   000006              ;               // Fall through to label ??Subroutine84_0

   \                                 In section .far_func.text, align 1
   1316          void CommonMode_OperateLine(INT8U Key_num,INT8U AdressOfData)
   1317          {
   \                     CommonMode_OperateLine:
   \   000000 8D ......    CALLF     L:?push_w4
   1318               //LINE-1
   1319               if((Key_num == AI) && (ABIO_Function[AdressOfData].AI_Line1 == AI))
   \   000004 905F         CLRW      Y
   \   000006 61           EXG       A, YL
   \   000007 B6 ..        LD        A, S:?b0
   \   000009 61           EXG       A, YL
   \   00000A 8D ......    CALLF     ?Subroutine31
   \                     ??CrossCallReturnLabel_50:
   \   00000E A1 10        CP        A, #0x10
   \   000010 26 1A        JRNE      L:??CommonMode_OperateLine_0
   \   000012 92C6 ..      LD        A, [S:?w4.w]
   \   000015 A1 10        CP        A, #0x10
   \   000017 26 04        JRNE      L:??CrossCallReturnLabel_61
   1320               { CLOSE_LINE1;  Led1_Off();  }
   \   000019 8D ......    CALLF     ?Subroutine33
   \                     ??CrossCallReturnLabel_61:
   \   00001D BE ..        LDW       X, S:?w4
   \   00001F 1C 0005      ADDW      X, #0x5
   \   000022 F6           LD        A, (X)
   \   000023 A1 10        CP        A, #0x10
   \   000025 27 03        JREQ      ??lb_6
   \   000027 CC ....      JP        L:??CommonMode_OperateLine_1
   \                     ??lb_6:
   \   00002A 20 34        JRA       L:??CommonMode_OperateLine_2
   1321               if((Key_num == AO) && (ABIO_Function[AdressOfData].AO_Line1 == AO))
   \                     ??CommonMode_OperateLine_0:
   \   00002C A1 30        CP        A, #0x30
   \   00002E 26 16        JRNE      L:??CommonMode_OperateLine_3
   \   000030 5C           INCW      X
   \   000031 F6           LD        A, (X)
   \   000032 A1 30        CP        A, #0x30
   \   000034 26 04        JRNE      L:??CrossCallReturnLabel_154
   1322               { OPEN_LINE1;   LED1_GREEN; }       
   \   000036 8D ......    CALLF     ?Subroutine3
   \                     ??CrossCallReturnLabel_154:
   \   00003A BE ..        LDW       X, S:?w4
   \   00003C 1C 0006      ADDW      X, #0x6
   \   00003F F6           LD        A, (X)
   \   000040 A1 30        CP        A, #0x30
   \   000042 26 74        JRNE      L:??CommonMode_OperateLine_1
   \   000044 20 3C        JRA       L:??CommonMode_OperateLine_4
   1323               if((Key_num == BI) && (ABIO_Function[AdressOfData].BI_Line1 == BI))
   \                     ??CommonMode_OperateLine_3:
   \   000046 A1 50        CP        A, #0x50
   \   000048 26 1E        JRNE      L:??CommonMode_OperateLine_5
   \   00004A 1C 0002      ADDW      X, #0x2
   \   00004D F6           LD        A, (X)
   \   00004E A1 50        CP        A, #0x50
   \   000050 26 04        JRNE      L:??CrossCallReturnLabel_60
   1324               { CLOSE_LINE1;  Led1_Off();}
   \   000052 8D ......    CALLF     ?Subroutine33
   \                     ??CrossCallReturnLabel_60:
   \   000056 BE ..        LDW       X, S:?w4
   \   000058 1C 0007      ADDW      X, #0x7
   \   00005B F6           LD        A, (X)
   \   00005C A1 50        CP        A, #0x50
   \   00005E 26 58        JRNE      L:??CommonMode_OperateLine_1
   1325               if((Key_num == BO) && (ABIO_Function[AdressOfData].BO_Line1 == BO))
   1326               { OPEN_LINE1;   LED1_GREEN;}  
   1327               if((Key_num == ABIO_TOOGLE) && (ABIO_Function[AdressOfData].TOOGLE_Line1 == ABIO_TOOGLE))
   1328               { //TOOGLE_LINE1; 
   1329                 GPIO_ToggleBits(LED1_GREEN_PORT,LED1_GREEN_PIN); }                  
   1330               //LINE-2
   1331               if((Key_num == AI) && (ABIO_Function[AdressOfData].AI_Line2 == AI))
   1332               { CLOSE_LINE2;  Led2_Off();}
   1333               if((Key_num == AO) && (ABIO_Function[AdressOfData].AO_Line2 == AO))
   1334               { OPEN_LINE2;   LED2_GREEN;}       
   1335               if((Key_num == BI) && (ABIO_Function[AdressOfData].BI_Line2 == BI))
   1336               { CLOSE_LINE2;  Led2_Off();}
   \                     ??CommonMode_OperateLine_2:
   \   000060 8D ......    CALLF     ?Subroutine14
   \                     ??CrossCallReturnLabel_21:
   \   000064 AC ......    JPF       L:?epilogue_w4
   \                     ??CommonMode_OperateLine_5:
   \   000068 A1 70        CP        A, #0x70
   \   00006A 26 24        JRNE      L:??CommonMode_OperateLine_6
   \   00006C 1C 0003      ADDW      X, #0x3
   \   00006F F6           LD        A, (X)
   \   000070 A1 70        CP        A, #0x70
   \   000072 26 04        JRNE      L:??CrossCallReturnLabel_153
   \   000074 8D ......    CALLF     ?Subroutine3
   \                     ??CrossCallReturnLabel_153:
   \   000078 BE ..        LDW       X, S:?w4
   \   00007A 1C 0008      ADDW      X, #0x8
   \   00007D F6           LD        A, (X)
   \   00007E A1 70        CP        A, #0x70
   \   000080 26 36        JRNE      L:??CommonMode_OperateLine_1
   1337               if((Key_num == BO) && (ABIO_Function[AdressOfData].BO_Line2 == BO))
   1338               { OPEN_LINE2;   LED2_GREEN;}
   \                     ??CommonMode_OperateLine_4:
   \   000082 A6 10        LD        A, #0x10
   \   000084 8D ......    CALLF     ??Subroutine104_0
   \                     ??CrossCallReturnLabel_254:
   \   000088 8D ......    CALLF     ?Subroutine9
   \                     ??CrossCallReturnLabel_257:
   \   00008C AC ......    JPF       L:?epilogue_w4
   \                     ??CommonMode_OperateLine_6:
   \   000090 A1 20        CP        A, #0x20
   \   000092 26 24        JRNE      L:??CommonMode_OperateLine_1
   \   000094 1C 0004      ADDW      X, #0x4
   \   000097 F6           LD        A, (X)
   \   000098 A1 20        CP        A, #0x20
   \   00009A 26 09        JRNE      L:??CommonMode_OperateLine_7
   \   00009C A6 04        LD        A, #0x4
   \   00009E AE 5000      LDW       X, #0x5000
   \   0000A1 8D ......    CALLF     GPIO_ToggleBits
   \                     ??CommonMode_OperateLine_7:
   \   0000A5 BE ..        LDW       X, S:?w4
   \   0000A7 1C 0009      ADDW      X, #0x9
   \   0000AA F6           LD        A, (X)
   \   0000AB A1 20        CP        A, #0x20
   \   0000AD 26 09        JRNE      L:??CommonMode_OperateLine_1
   1339               if((Key_num == ABIO_TOOGLE) && (ABIO_Function[AdressOfData].TOOGLE_Line2 == ABIO_TOOGLE))
   1340               { //TOOGLE_LINE2;  
   1341                 GPIO_ToggleBits(LED2_GREEN_PORT,LED2_GREEN_PIN); } 
   \   0000AF A6 40        LD        A, #0x40
   \   0000B1 AE 500A      LDW       X, #0x500a
   \   0000B4 8D ......    CALLF     GPIO_ToggleBits
   1342          }
   \                     ??CommonMode_OperateLine_1:
   \   0000B8 AC ......    JPF       L:?epilogue_w4
   1343          
   1344          /**
   1345          @function： 应答请求  设备Flash中已存  所有  信息报文  
   1346          @parameter：AdressOfData  信息条目的编号 从0开始
   1347          **/

   \                                 In section .far_func.text, align 1
   1348          void Reply_RequestFlashData(INT8U AdressOfData,INT8U Master_Id_1,INT8U Master_Id_2,INT8U Master_Id_3,INT8U Master_Id_4)
   1349          {     
   \                     Reply_RequestFlashData:
   \   000000 52 18        SUB       SP, #0x18
   \   000002 B7 ..        LD        S:?b4, A
   1350              //回复请求端的数据                        目标设备ID                设备自身ID                                      ID区域                   Line1区域                Line2区域
   1351              INT8U  Reply_ALL_DataInFlash[24] = {0x6 ,0x00,0x00,0x00,0x00,0x00,DEVICE_ID_1,DEVICE_ID_2,DEVICE_ID_3,DEVICE_ID_4,0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,   0x00,0x00,0x00,0x00,0x00};     
   \   000004 90AE ....    LDW       Y, #?_2
   \   000008 96           LDW       X, SP
   \   000009 5C           INCW      X
   \   00000A 89           PUSHW     X
   \   00000B A6 18        LD        A, #0x18
   \   00000D 8D ......    CALLF     L:?move1616_v_x_y_a
   \   000011 85           POPW      X
   1352              const INT8U  adressofstruct = AdressOfData;
   1353                                           
   1354              if(adressofstruct < Public_learned_ID_num)
   \   000012 B6 ..        LD        A, S:?b4
   \   000014 C1 ....      CP        A, L:Public_learned_ID_num
   \   000017 25 03        JRC       ??lb_5
   \   000019 CC ....      JP        L:??Reply_RequestFlashData_0
   1355              {
   1356                   //主机ID
   1357                   Reply_ALL_DataInFlash[1] = Master_Id_1;
   \                     ??lb_5:
   \   00001C B6 ..        LD        A, S:?b0
   \   00001E 6B 02        LD        (0x2,SP), A
   1358                   Reply_ALL_DataInFlash[2] = Master_Id_2;
   \   000020 B6 ..        LD        A, S:?b1
   \   000022 6B 03        LD        (0x3,SP), A
   1359                   Reply_ALL_DataInFlash[3] = Master_Id_3;
   \   000024 B6 ..        LD        A, S:?b2
   \   000026 6B 04        LD        (0x4,SP), A
   1360                   Reply_ALL_DataInFlash[4] = Master_Id_4;
   \   000028 B6 ..        LD        A, S:?b3
   \   00002A 6B 05        LD        (0x5,SP), A
   1361                   
   1362                   Reply_ALL_DataInFlash[5] = adressofstruct;
   \   00002C B6 ..        LD        A, S:?b4
   \   00002E 6B 06        LD        (0x6,SP), A
   1363                   //Flash中数据区域
   1364                   Reply_ALL_DataInFlash[10] = AllRadio[adressofstruct].Id_part_1; 
   \   000030 5F           CLRW      X
   \   000031 41           EXG       A, XL
   \   000032 BF ..        LDW       S:?w1, X
   \   000034 AE 0007      LDW       X, #0x7
   \   000037 BF ..        LDW       S:?w0, X
   \   000039 BE ..        LDW       X, S:?w1
   \   00003B 8D ......    CALLF     ?Subroutine83
   \                     ??CrossCallReturnLabel_174:
   \   00003F 9093         LDW       Y, X
   \   000041 905C         INCW      Y
   \   000043 90F6         LD        A, (Y)
   \   000045 6B 0B        LD        (0xb,SP), A
   1365                   Reply_ALL_DataInFlash[11] = AllRadio[adressofstruct].Id_part_2;
   \   000047 8D ......    CALLF     ??Subroutine88_0
   \                     ??CrossCallReturnLabel_166:
   \   00004B 90F6         LD        A, (Y)
   \   00004D 6B 0C        LD        (0xc,SP), A
   1366                   Reply_ALL_DataInFlash[12] = AllRadio[adressofstruct].Id_part_3;
   \   00004F 8D ......    CALLF     ??Subroutine87_0
   \                     ??CrossCallReturnLabel_161:
   \   000053 90F6         LD        A, (Y)
   \   000055 6B 0D        LD        (0xd,SP), A
   1367                   Reply_ALL_DataInFlash[13] = AllRadio[adressofstruct].Id_part_4;
   \   000057 1C 0004      ADDW      X, #0x4
   \   00005A F6           LD        A, (X)
   \   00005B 6B 0E        LD        (0xe,SP), A
   1368                   
   1369                   Reply_ALL_DataInFlash[14] = ABIO_Function[adressofstruct].AI_Line1;
   \   00005D AE 000A      LDW       X, #0xa
   \   000060 BF ..        LDW       S:?w0, X
   \   000062 BE ..        LDW       X, S:?w1
   \   000064 8D ......    CALLF     ??Subroutine90_0
   \                     ??CrossCallReturnLabel_177:
   \   000068 F6           LD        A, (X)
   \   000069 6B 0F        LD        (0xf,SP), A
   1370                   Reply_ALL_DataInFlash[15] = ABIO_Function[adressofstruct].AO_Line1;
   \   00006B 9093         LDW       Y, X
   \   00006D 905C         INCW      Y
   \   00006F 90F6         LD        A, (Y)
   \   000071 6B 10        LD        (0x10,SP), A
   1371                   Reply_ALL_DataInFlash[16] = ABIO_Function[adressofstruct].BI_Line1;
   \   000073 8D ......    CALLF     ??Subroutine88_0
   \                     ??CrossCallReturnLabel_167:
   \   000077 90F6         LD        A, (Y)
   \   000079 6B 11        LD        (0x11,SP), A
   1372                   Reply_ALL_DataInFlash[17] = ABIO_Function[adressofstruct].BO_Line1;
   \   00007B 8D ......    CALLF     ??Subroutine87_0
   \                     ??CrossCallReturnLabel_162:
   \   00007F 90F6         LD        A, (Y)
   \   000081 6B 12        LD        (0x12,SP), A
   1373                   Reply_ALL_DataInFlash[18] = ABIO_Function[adressofstruct].TOOGLE_Line1;
   \   000083 9093         LDW       Y, X
   \   000085 72A9 0004    ADDW      Y, #0x4
   \   000089 90F6         LD        A, (Y)
   \   00008B 6B 13        LD        (0x13,SP), A
   1374                     
   1375                   Reply_ALL_DataInFlash[19] = ABIO_Function[adressofstruct].AI_Line2;
   \   00008D 9093         LDW       Y, X
   \   00008F 72A9 0005    ADDW      Y, #0x5
   \   000093 90F6         LD        A, (Y)
   \   000095 6B 14        LD        (0x14,SP), A
   1376                   Reply_ALL_DataInFlash[20] = ABIO_Function[adressofstruct].AO_Line2;
   \   000097 9093         LDW       Y, X
   \   000099 72A9 0006    ADDW      Y, #0x6
   \   00009D 90F6         LD        A, (Y)
   \   00009F 6B 15        LD        (0x15,SP), A
   1377                   Reply_ALL_DataInFlash[21] = ABIO_Function[adressofstruct].BI_Line2;
   \   0000A1 9093         LDW       Y, X
   \   0000A3 72A9 0007    ADDW      Y, #0x7
   \   0000A7 90F6         LD        A, (Y)
   \   0000A9 6B 16        LD        (0x16,SP), A
   1378                   Reply_ALL_DataInFlash[22] = ABIO_Function[adressofstruct].BO_Line2;
   \   0000AB 9093         LDW       Y, X
   \   0000AD 72A9 0008    ADDW      Y, #0x8
   \   0000B1 90F6         LD        A, (Y)
   \   0000B3 6B 17        LD        (0x17,SP), A
   1379                   Reply_ALL_DataInFlash[23] = ABIO_Function[adressofstruct].TOOGLE_Line2;               
   \   0000B5 1C 0009      ADDW      X, #0x9
   \   0000B8 F6           LD        A, (X)
   \   0000B9 6B 18        LD        (0x18,SP), A
   1380                  
   1381                   //开始发送
   1382                   timer2_delay(50);  
   \   0000BB AE 0032      LDW       X, #0x32
   \   0000BE 8D ......    CALLF     ??Subroutine103_0
   1383                   halRfSendPacket( Reply_ALL_DataInFlash, 24 );          
   \                     ??CrossCallReturnLabel_244:
   \   0000C2 A6 18        LD        A, #0x18
   \   0000C4 96           LDW       X, SP
   \   0000C5 5C           INCW      X
   \   0000C6 8D ......    CALLF     halRfSendPacket
   1384              }
   1385          }
   \                     ??Reply_RequestFlashData_0:
   \   0000CA 5B 18        ADD       SP, #0x18
   \   0000CC 87           RETF
   1386          
   1387          
   1388          /**
   1389          @function：报文 接收  处理函数  
   1390          **/

   \                                 In section .far_func.text, align 1
   1391          void  Radio_Recive(void)
   1392          {   
   1393              receiveflag = 0;                       //复位接收中断标志 
   \                     Radio_Recive:
   \   000000 725F ....    CLR       L:receiveflag
   1394              if(LearnModeWaitForConfirm == OFF)     // 若为ON 说明已经接收到了一个报文 ，学习模式
   \   000004 C6 ....      LD        A, L:LearnModeWaitForConfirm
   \   000007 A1 10        CP        A, #0x10
   \   000009 26 10        JRNE      L:??Radio_Recive_0
   1395              {        
   1396                   __disable_interrupt();
   \   00000B 9B           SIM
   1397              //     receive_radio_length = SI446X_READ_PACKET( Radio_Data );        
   1398                   receive_radio_length = halRfReceivePacket(Radio_Data,&receive_radio_length);
   \   00000C 90AE ....    LDW       Y, #receive_radio_length
   \   000010 AE ....      LDW       X, #Radio_Data
   \   000013 8D ......    CALLF     halRfReceivePacket
   \   000017 C7 ....      LD        L:receive_radio_length, A
   1399                   __enable_interrupt();
   \   00001A 9A           RIM
   1400              }
   1401              //TODO  else if(LearnModeWaitForConfirm == ON){}              
   1402              /**  学习模式 **/
   1403              if(learn_mode == ON)  
   \                     ??Radio_Recive_0:
   \   00001B C6 ....      LD        A, L:learn_mode
   \   00001E A1 11        CP        A, #0x11
   \   000020 26 17        JRNE      L:??Radio_Recive_1
   1404              {
   1405                  if((Radio_Data[0] == 7) && (Radio_Data[5] < 2))    
   \   000022 C6 ....      LD        A, L:Radio_Data
   \   000025 A1 07        CP        A, #0x7
   \   000027 26 61        JRNE      L:??Radio_Recive_2
   \   000029 C6 ....      LD        A, L:Radio_Data + 5
   \   00002C A1 02        CP        A, #0x2
   \   00002E 24 5A        JRNC      L:??Radio_Recive_2
   1406                  {         
   1407                      LearnModeWaitForConfirm = ON;          //进入 等待确认 
   \   000030 35 11 ....   MOV       L:LearnModeWaitForConfirm, #0x11
   1408                      WaitForConfirm_time     = 0;           //自动退出学习确认等待时间 清零   
   \   000034 8D ......    CALLF     ?Subroutine29
   1409                  }                     
   1410              }        
   \                     ??CrossCallReturnLabel_46:
   \   000038 87           RETF
   1411              /**  工作模式  **/
   1412              if( learn_mode == OFF )  
   \                     ??Radio_Recive_1:
   \   000039 A1 10        CP        A, #0x10
   \   00003B 26 4D        JRNE      L:??Radio_Recive_2
   1413              {      
   1414                  switch(receive_radio_length)
   \   00003D C6 ....      LD        A, L:receive_radio_length
   \   000040 A0 05        SUB       A, #0x5
   \   000042 27 22        JREQ      L:??Radio_Recive_3
   \   000044 4A           DEC       A
   \   000045 27 19        JREQ      L:??Radio_Recive_4
   \   000047 4A           DEC       A
   \   000048 27 0A        JREQ      L:??Radio_Recive_5
   \   00004A A0 03        SUB       A, #0x3
   \   00004C 27 0C        JREQ      L:??Radio_Recive_6
   \   00004E A0 0A        SUB       A, #0xa
   \   000050 27 1A        JREQ      L:??Radio_Recive_7
   \   000052 20 2B        JRA       L:??Radio_Recive_8
   1415                  {          
   1416                      /*****  常规报文以及 远程控制报文  *****/
   1417                      case 7:
   1418                      {                     
   1419                          length7function();
   \                     ??Radio_Recive_5:
   \   000054 8D ......    CALLF     length7function
   1420                          break;                                                                          
   \   000058 20 25        JRA       L:??Radio_Recive_8
   1421                      }                
   1422                      /*****  主机向从机发送传输数据的请求  *****/
   1423                      case 10:
   1424                      {
   1425                          length10function();
   \                     ??Radio_Recive_6:
   \   00005A 8D ......    CALLF     length10function
   1426                          break;
   \   00005E 20 1F        JRA       L:??Radio_Recive_8
   1427                      }       
   1428                      case 6:
   1429                      {
   1430                          length6function();
   \                     ??Radio_Recive_4:
   \   000060 8D ......    CALLF     length6function
   1431                          break;
   \   000064 20 19        JRA       L:??Radio_Recive_8
   1432                      }
   1433                      /*****  主机向从机查询回路状态的请求  *****/
   1434                      case 5:
   1435                      {
   1436                          length5function();
   \                     ??Radio_Recive_3:
   \   000066 8D ......    CALLF     length5function
   1437                          break;            
   \   00006A 20 13        JRA       L:??Radio_Recive_8
   1438                      }        
   1439                      /*****  报文长度为 20 则为远程学习报文  *****/ 
   1440                      case 20:
   1441                      {
   1442                          length20function();
   \                     ??Radio_Recive_7:
   \   00006C 8D ......    CALLF     length20function
   1443                          break;
   \   000070 20 0D        JRA       L:??Radio_Recive_8
   1444                          //TODO  将写入Flash的结果发送给请求端 
   1445                      }           
   1446                      default:{break;}                           
   1447                  }
   1448                  for(;clear_num < RECEIVE_DATA_LENGTH;clear_num ++) //操作完成，清空Radio_Data[]
   1449                  {
   1450                      Radio_Data[clear_num]=0;
   \                     ??Radio_Recive_9:
   \   000072 5F           CLRW      X
   \   000073 97           LD        XL, A
   \   000074 4F           CLR       A
   \   000075 D7 ....      LD        (L:Radio_Data,X), A
   1451                  }
   \   000078 C6 ....      LD        A, L:clear_num
   \   00007B 4C           INC       A
   \   00007C C7 ....      LD        L:clear_num, A
   \                     ??Radio_Recive_8:
   \   00007F C6 ....      LD        A, L:clear_num
   \   000082 A1 21        CP        A, #0x21
   \   000084 25 EC        JRC       L:??Radio_Recive_9
   1452                  clear_num = 0;
   \   000086 725F ....    CLR       L:clear_num
   1453              }
   1454          }
   \                     ??Radio_Recive_2:
   \   00008A 87           RETF
   1455          
   1456          /**
   1457          @function：报文长度为 7 时执行函数
   1458          **/

   \                                 In section .far_func.text, align 1
   1459          void length7function(void)
   1460          {
   1461              /***** 常规操作：Radio-type要求为0x7（开关） 被转发次数要求不超过2次 *****/
   1462              if((Radio_Data[0] == 0x07) && (Radio_Data[5] < 2))    
   \                     length7function:
   \   000000 C6 ....      LD        A, L:Radio_Data
   \   000003 A1 07        CP        A, #0x7
   \   000005 26 29        JRNE      L:??length7function_0
   \   000007 C6 ....      LD        A, L:Radio_Data + 5
   \   00000A A1 02        CP        A, #0x2
   \   00000C 24 6C        JRNC      L:??length7function_1
   1463              {                                                                                                                                             
   1464                  Return_FindInFlash = FindIdInFlash(Radio_Data[1],Radio_Data[2],Radio_Data[3],Radio_Data[4]);                     
   \   00000E 8D ......    CALLF     ?Subroutine35
   \                     ??CrossCallReturnLabel_65:
   \   000012 C7 ....      LD        L:Return_FindInFlash, A
   1465                  if(Return_FindInFlash != FINDINFLASH_FAIL )   //在flash中查找到有此ID
   \   000015 A1 77        CP        A, #0x77
   \   000017 27 61        JREQ      L:??length7function_1
   1466                  { 
   1467                       if((Radio_Can_Operated == 1))   
   \   000019 C6 ....      LD        A, L:Radio_Can_Operated
   \   00001C A1 01        CP        A, #0x1
   \   00001E 26 5A        JRNE      L:??length7function_1
   1468                       {      
   1469                            CommonMode_OperateLine(Radio_Data[6],Return_FindInFlash); 
   \   000020 C6 ....      LD        A, L:Return_FindInFlash
   \   000023 B7 ..        LD        S:?b0, A
   \   000025 C6 ....      LD        A, L:Radio_Data + 6
   \   000028 8D ......    CALLF     CommonMode_OperateLine
   1470                            Radio_Can_Operated = 0;       //转为不可操作          
   \   00002C 725F ....    CLR       L:Radio_Can_Operated
   1471                       }                                                                         
   1472                  }
   1473              }
   1474              /*****  远程操作执行器， Radio-type = 0x9 *****/
   1475              if(Radio_Data[0] == 0x09)
   \                     ??length7function_0:
   \   000030 C6 ....      LD        A, L:Radio_Data
   \   000033 A1 09        CP        A, #0x9
   \   000035 26 43        JRNE      L:??length7function_1
   1476              {
   1477                switch(Radio_Data[5])
   \   000037 C6 ....      LD        A, L:Radio_Data + 5
   \   00003A A0 10        SUB       A, #0x10
   \   00003C 27 08        JREQ      L:??length7function_2
   \   00003E 4A           DEC       A
   \   00003F 27 09        JREQ      L:??CrossCallReturnLabel_72
   \   000041 4A           DEC       A
   \   000042 27 0A        JREQ      L:??CrossCallReturnLabel_155
   \   000044 20 11        JRA       L:??length7function_3
   1478                {
   1479                    case 0x00:
   1480                    {break;}
   1481                    case 0x10:
   1482                    {CLOSE_LINE1;}
   \                     ??length7function_2:
   \   000046 8D ......    CALLF     ?Subroutine39
   1483                    case 0x11:
   1484                    {OPEN_LINE1;}
   \                     ??CrossCallReturnLabel_72:
   \   00004A 8D ......    CALLF     ?Subroutine10
   1485                    case 0x12:
   1486                    {TOOGLE_LINE1;}     
   \                     ??CrossCallReturnLabel_155:
   \   00004E A6 80        LD        A, #0x80
   \   000050 AE 5005      LDW       X, #0x5005
   \   000053 8D ......    CALLF     GPIO_ToggleBits
   1487                }
   1488                switch(Radio_Data[6])
   \                     ??length7function_3:
   \   000057 C6 ....      LD        A, L:Radio_Data + 6
   \   00005A A0 10        SUB       A, #0x10
   \   00005C 27 07        JREQ      L:??length7function_4
   \   00005E 4A           DEC       A
   \   00005F 27 0A        JREQ      L:??CrossCallReturnLabel_300
   \   000061 4A           DEC       A
   \   000062 27 0D        JREQ      L:??CrossCallReturnLabel_255
   \   000064 87           RETF
   1489                {
   1490                    case 0x00:
   1491                    {break;}
   1492                    case 0x10:
   1493                    {CLOSE_LINE2;}
   \                     ??length7function_4:
   \   000065 A6 10        LD        A, #0x10
   \   000067 8D ......    CALLF     ??Subroutine112_0
   1494                    case 0x11:
   1495                    {OPEN_LINE2;}
   \                     ??CrossCallReturnLabel_300:
   \   00006B A6 10        LD        A, #0x10
   \   00006D 8D ......    CALLF     ??Subroutine104_0
   1496                    case 0x12:
   1497                    {TOOGLE_LINE2;}     
   \                     ??CrossCallReturnLabel_255:
   \   000071 A6 10        LD        A, #0x10
   \   000073 AE 500A      LDW       X, #0x500a
   \   000076 8D ......    CALLF     GPIO_ToggleBits
   1498                }      
   1499              }
   1500          }
   \                     ??length7function_1:
   \   00007A 87           RETF
   1501          
   1502          /**
   1503          @function：报文长度为 10 时执行函数
   1504                    主机向从机发送传输数据的请求 
   1505          **/

   \                                 In section .far_func.text, align 1
   1506          void length10function(void)
   1507          {
   1508              //请求回复设备中存储的信息： 0x2报文类型)  0x？:0x？:0x？:0x？(从设备ID)   0x？  （从机数据区地址）
   1509              if( (Radio_Data[0]==0x2) &&  (Radio_Data[1] == DEVICE_ID_1 ) &&  (Radio_Data[2] == DEVICE_ID_2 ) &&  (Radio_Data[3] == DEVICE_ID_3 ) &&  (Radio_Data[4] == DEVICE_ID_4 ) ) 
   \                     length10function:
   \   000000 C6 ....      LD        A, L:Radio_Data
   \   000003 A1 02        CP        A, #0x2
   \   000005 26 37        JRNE      L:??length10function_0
   \   000007 C6 ....      LD        A, L:Radio_Data + 1
   \   00000A A1 43        CP        A, #0x43
   \   00000C 26 30        JRNE      L:??length10function_0
   \   00000E C6 ....      LD        A, L:Radio_Data + 2
   \   000011 A1 20        CP        A, #0x20
   \   000013 26 29        JRNE      L:??length10function_0
   \   000015 C6 ....      LD        A, L:Radio_Data + 3
   \   000018 A1 05        CP        A, #0x5
   \   00001A 26 22        JRNE      L:??length10function_0
   \   00001C C6 ....      LD        A, L:Radio_Data + 4
   \   00001F A1 15        CP        A, #0x15
   \   000021 26 1B        JRNE      L:??length10function_0
   1510              {         
   1511                  Reply_RequestFlashData(Radio_Data[9],Radio_Data[5],Radio_Data[6],Radio_Data[7],Radio_Data[8]);                                                             
   \   000023 C6 ....      LD        A, L:Radio_Data + 8
   \   000026 B7 ..        LD        S:?b3, A
   \   000028 C6 ....      LD        A, L:Radio_Data + 7
   \   00002B B7 ..        LD        S:?b2, A
   \   00002D C6 ....      LD        A, L:Radio_Data + 6
   \   000030 B7 ..        LD        S:?b1, A
   \   000032 C6 ....      LD        A, L:Radio_Data + 5
   \   000035 B7 ..        LD        S:?b0, A
   \   000037 C6 ....      LD        A, L:Radio_Data + 9
   \   00003A 8D ......    CALLF     Reply_RequestFlashData
   1512              }   
   1513          }
   \                     ??length10function_0:
   \   00003E 87           RETF
   1514          
   1515          
   1516          /**
   1517          @function：报文长度为 6 时执行函数
   1518                    主机发送的广播请求 
   1519          **/

   \                                 In section .far_func.text, align 1
   1520          void length6function(void)
   1521          {
   1522              //广播报文， 从机进行应答
   1523              if( (Radio_Data[0]==0x00) &&  (Radio_Data[1] == DEVICE_ID_1 ) &&  (Radio_Data[2] == DEVICE_ID_2 ) &&  (Radio_Data[3] == DEVICE_ID_3 ) &&  (Radio_Data[4] == DEVICE_ID_4 ) ) 
   \                     length6function:
   \   000000 C6 ....      LD        A, L:Radio_Data
   \   000003 26 20        JRNE      L:??length6function_0
   \   000005 C6 ....      LD        A, L:Radio_Data + 1
   \   000008 A1 43        CP        A, #0x43
   \   00000A 26 19        JRNE      L:??length6function_0
   \   00000C C6 ....      LD        A, L:Radio_Data + 2
   \   00000F A1 20        CP        A, #0x20
   \   000011 26 12        JRNE      L:??length6function_0
   \   000013 C6 ....      LD        A, L:Radio_Data + 3
   \   000016 A1 05        CP        A, #0x5
   \   000018 26 0B        JRNE      L:??length6function_0
   \   00001A C6 ....      LD        A, L:Radio_Data + 4
   \   00001D A1 15        CP        A, #0x15
   \   00001F 26 04        JRNE      L:??length6function_0
   1524              {         
   1525                  reply_broadcast();                                                      
   \   000021 8D ......    CALLF     reply_broadcast
   1526              }   
   1527          }
   \                     ??length6function_0:
   \   000025 87           RETF
   1528          
   1529          
   1530          /**
   1531          @function：应答主设备的广播报文
   1532          **/

   \                                 In section .far_func.text, align 1
   1533          void reply_broadcast(void)
   1534          {
   \                     reply_broadcast:
   \   000000 52 0A        SUB       SP, #0xa
   1535              INT8U  Reply_BroadcastData[10] = {0x00 ,Radio_Data[1],Radio_Data[2],Radio_Data[3],Radio_Data[4],DEVICE_ID_1,DEVICE_ID_2,DEVICE_ID_3,DEVICE_ID_4,DEVICE_TYPE};
   \   000002 90AE ....    LDW       Y, #?_3
   \   000006 96           LDW       X, SP
   \   000007 5C           INCW      X
   \   000008 89           PUSHW     X
   \   000009 A6 0A        LD        A, #0xa
   \   00000B 8D ......    CALLF     L:?move1616_v_x_y_a
   \   00000F 85           POPW      X
   \   000010 C6 ....      LD        A, L:Radio_Data + 1
   \   000013 6B 02        LD        (0x2,SP), A
   \   000015 C6 ....      LD        A, L:Radio_Data + 2
   \   000018 6B 03        LD        (0x3,SP), A
   \   00001A C6 ....      LD        A, L:Radio_Data + 3
   \   00001D 6B 04        LD        (0x4,SP), A
   \   00001F C6 ....      LD        A, L:Radio_Data + 4
   \   000022 6B 05        LD        (0x5,SP), A
   1536              
   1537              timer2_delay(DEVICE_ID_4*10);  //随机延时   
   \   000024 AE 00D2      LDW       X, #0xd2
   \   000027 8D ......    CALLF     ??Subroutine103_0
   1538              halRfSendPacket( Reply_BroadcastData, 10 );    
   \                     ??CrossCallReturnLabel_243:
   \   00002B A6 0A        LD        A, #0xa
   \   00002D 96           LDW       X, SP
   \   00002E 5C           INCW      X
   \   00002F 8D ......    CALLF     halRfSendPacket
   1539          }
   \   000033 5B 0A        ADD       SP, #0xa
   \   000035 87           RETF

   \                                 In section .near.rodata, align 1
   \                     ?_3:
   \   000000 00 00 00 00  DC8 0, 0, 0, 0, 0, 67, 32, 5, 21, 33
   \          00 43 20 05 
   1540          
   1541          
   1542          
   1543          
   1544          
   1545          /**
   1546          @function：报文长度为 5 时执行函数
   1547                     查询执行器回路状态
   1548          **/

   \                                 In section .far_func.text, align 1
   1549          void length5function(void)
   1550          {
   \                     length5function:
   \   000000 52 0B        SUB       SP, #0xb
   1551              INT8U ReplayLineInfoData[11] = {0x10,Radio_Data[1],Radio_Data[2],Radio_Data[3],Radio_Data[4],DEVICE_ID_1,DEVICE_ID_2,DEVICE_ID_3,DEVICE_ID_4,0x00,0x00};
   \   000002 90AE ....    LDW       Y, #?_4
   \   000006 96           LDW       X, SP
   \   000007 5C           INCW      X
   \   000008 89           PUSHW     X
   \   000009 A6 0B        LD        A, #0xb
   \   00000B 8D ......    CALLF     L:?move1616_v_x_y_a
   \   00000F 85           POPW      X
   \   000010 C6 ....      LD        A, L:Radio_Data + 1
   \   000013 6B 02        LD        (0x2,SP), A
   \   000015 C6 ....      LD        A, L:Radio_Data + 2
   \   000018 6B 03        LD        (0x3,SP), A
   \   00001A C6 ....      LD        A, L:Radio_Data + 3
   \   00001D 6B 04        LD        (0x4,SP), A
   \   00001F C6 ....      LD        A, L:Radio_Data + 4
   \   000022 6B 05        LD        (0x5,SP), A
   1552              if(GPIO_ReadInputDataBit(LINE1_PORT,  LINE1_PIN) )
   \   000024 8D ......    CALLF     ?Subroutine38
   \                     ??CrossCallReturnLabel_70:
   \   000028 27 04        JREQ      L:??length5function_0
   1553              {
   1554                  ReplayLineInfoData[9] = 0x11;
   \   00002A A6 11        LD        A, #0x11
   \   00002C 20 02        JRA       ??length5function_1
   1555              }
   1556              else{
   1557                  ReplayLineInfoData[9] = 0x10;
   \                     ??length5function_0:
   \   00002E A6 10        LD        A, #0x10
   \                     ??length5function_1:
   \   000030 6B 0A        LD        (0xa,SP), A
   1558              }
   1559              if(GPIO_ReadInputDataBit(LINE2_PORT,  LINE2_PIN) )
   \   000032 A6 10        LD        A, #0x10
   \   000034 AE 500A      LDW       X, #0x500a
   \   000037 8D ......    CALLF     GPIO_ReadInputDataBit
   \   00003B A1 00        CP        A, #0x0
   \   00003D 27 04        JREQ      L:??length5function_2
   1560              {
   1561                  ReplayLineInfoData[10] = 0x11;
   \   00003F A6 11        LD        A, #0x11
   \   000041 20 02        JRA       ??length5function_3
   1562              }
   1563              else{
   1564                  ReplayLineInfoData[10] = 0x10;
   \                     ??length5function_2:
   \   000043 A6 10        LD        A, #0x10
   \                     ??length5function_3:
   \   000045 6B 0B        LD        (0xb,SP), A
   1565              } 
   1566              halRfSendPacket( ReplayLineInfoData, 11 );
   \   000047 A6 0B        LD        A, #0xb
   \   000049 96           LDW       X, SP
   \   00004A 5C           INCW      X
   \   00004B 8D ......    CALLF     halRfSendPacket
   1567          }
   \   00004F 5B 0B        ADD       SP, #0xb
   \   000051 87           RETF

   \                                 In section .near.rodata, align 1
   \                     ?_4:
   \   000000 10 00 00 00  DC8 16, 0, 0, 0, 0, 67, 32, 5, 21, 0, 0
   \          00 43 20 05 
   1568          
   1569          
   1570          /**
   1571          @function：报文长度为  20 时执行函数
   1572                     报文长度为 20 则为远程学习报文
   1573          **/

   \                                 In section .far_func.text, align 1
   1574          void length20function(void)
   1575          {
   1576              /*03(远程学习报文头)    （目标设备ID）  （操作类型：写入 & 删除）      (操作数据)*/   
   1577              if((Radio_Data[0]==0x3)&&(DEVICE_ID_1==Radio_Data[4])&&(DEVICE_ID_2==Radio_Data[3])&&(DEVICE_ID_3==Radio_Data[2])&&(DEVICE_ID_4==Radio_Data[1]))  //确认目标设备为自身
   \                     length20function:
   \   000000 C6 ....      LD        A, L:Radio_Data
   \   000003 A1 03        CP        A, #0x3
   \   000005 27 03        JREQ      ??lb_0
   \   000007 CC ....      JP        L:??length20function_0
   \                     ??lb_0:
   \   00000A C6 ....      LD        A, L:Radio_Data + 4
   \   00000D A1 43        CP        A, #0x43
   \   00000F 27 03        JREQ      ??lb_1
   \   000011 CC ....      JP        L:??length20function_0
   \                     ??lb_1:
   \   000014 C6 ....      LD        A, L:Radio_Data + 3
   \   000017 A1 20        CP        A, #0x20
   \   000019 27 03        JREQ      ??lb_2
   \   00001B CC ....      JP        L:??length20function_0
   \                     ??lb_2:
   \   00001E C6 ....      LD        A, L:Radio_Data + 2
   \   000021 A1 05        CP        A, #0x5
   \   000023 27 03        JREQ      ??lb_3
   \   000025 CC ....      JP        L:??length20function_0
   \                     ??lb_3:
   \   000028 C6 ....      LD        A, L:Radio_Data + 1
   \   00002B A1 15        CP        A, #0x15
   \   00002D 27 03        JREQ      ??lb_4
   \   00002F CC ....      JP        L:??length20function_0
   1578              {
   1579                  if(Radio_Data[5] == 0x1)  //远程学习 操作类型：写入命令
   \                     ??lb_4:
   \   000032 C6 ....      LD        A, L:Radio_Data + 5
   \   000035 A1 01        CP        A, #0x1
   \   000037 26 5B        JRNE      L:??length20function_1
   1580                  {
   1581                      Return_FindInFlash = FindIdInFlash(Radio_Data[6],Radio_Data[7],Radio_Data[8],Radio_Data[9]);
   \   000039 8D ......    CALLF     ?Subroutine34
   1582                      //写数据
   1583                      ControlByAirLearn_NewWriteInFlash(Radio_Data[10],Radio_Data[11],Radio_Data[12],Radio_Data[13],Radio_Data[14], LINE_1 ,Public_learned_ID_num);
   \                     ??CrossCallReturnLabel_62:
   \   00003D C6 ....      LD        A, L:Public_learned_ID_num
   \   000040 B7 ..        LD        S:?b5, A
   \   000042 35 16 ....   MOV       S:?b4, #0x16
   \   000046 C6 ....      LD        A, L:Radio_Data + 14
   \   000049 B7 ..        LD        S:?b3, A
   \   00004B C6 ....      LD        A, L:Radio_Data + 13
   \   00004E B7 ..        LD        S:?b2, A
   \   000050 C6 ....      LD        A, L:Radio_Data + 12
   \   000053 B7 ..        LD        S:?b1, A
   \   000055 C6 ....      LD        A, L:Radio_Data + 11
   \   000058 B7 ..        LD        S:?b0, A
   \   00005A C6 ....      LD        A, L:Radio_Data + 10
   \   00005D 8D ......    CALLF     ControlByAirLearn_NewWriteInFlash
   1584                      ControlByAirLearn_NewWriteInFlash(Radio_Data[15],Radio_Data[16],Radio_Data[17],Radio_Data[18],Radio_Data[19], LINE_2 ,Public_learned_ID_num);                        
   \   000061 C6 ....      LD        A, L:Public_learned_ID_num
   \   000064 B7 ..        LD        S:?b5, A
   \   000066 35 17 ....   MOV       S:?b4, #0x17
   \   00006A C6 ....      LD        A, L:Radio_Data + 19
   \   00006D B7 ..        LD        S:?b3, A
   \   00006F C6 ....      LD        A, L:Radio_Data + 18
   \   000072 B7 ..        LD        S:?b2, A
   \   000074 C6 ....      LD        A, L:Radio_Data + 17
   \   000077 B7 ..        LD        S:?b1, A
   \   000079 C6 ....      LD        A, L:Radio_Data + 16
   \   00007C B7 ..        LD        S:?b0, A
   \   00007E C6 ....      LD        A, L:Radio_Data + 15
   \   000081 8D ......    CALLF     ControlByAirLearn_NewWriteInFlash
   1585                      if(Return_FindInFlash == FINDINFLASH_FAIL)                 //在Flash中没有找到此ID  ==FINDINFLASH_FAIL
   \   000085 C6 ....      LD        A, L:Return_FindInFlash
   \   000088 A1 77        CP        A, #0x77
   \   00008A 26 08        JRNE      L:??length20function_1
   1586                      {
   1587                         WriteIdInFlash(Radio_Data[6],Radio_Data[7],Radio_Data[8],Radio_Data[9]);       //将ID写入Flash                            
   \   00008C 8D ......    CALLF     ?Subroutine64
   1588                      }
   1589                      else   //Flash中已经存在该ID
   1590                      {}           
   1591                      //TODO 操作成功，则进行应答
   1592                  }                       
   \                     ??CrossCallReturnLabel_123:
   \   000090 8D ......    CALLF     WriteIdInFlash
   1593                  if(Radio_Data[5] == 0x2)  //远程学习 操作类型：删除该条目录
   \                     ??length20function_1:
   \   000094 C6 ....      LD        A, L:Radio_Data + 5
   \   000097 A1 02        CP        A, #0x2
   \   000099 26 1E        JRNE      L:??length20function_0
   1594                  {
   1595                      Return_FindInFlash = FindIdInFlash(Radio_Data[6],Radio_Data[7],Radio_Data[8],Radio_Data[9]);
   \   00009B 8D ......    CALLF     ?Subroutine34
   1596                      if(Return_FindInFlash == FINDINFLASH_FAIL)         //在Flash中没有找到此ID  ==FINDINFLASH_FAIL
   \                     ??CrossCallReturnLabel_63:
   \   00009F A1 77        CP        A, #0x77
   \   0000A1 27 16        JREQ      L:??length20function_0
   1597                      {
   1598                      //TODO 不存在该条目                         
   1599                      }
   1600                      else if(Return_FindInFlash != FINDINFLASH_FAIL)
   1601                      {
   1602                          ControlByAirLearn_NewWriteInFlash(0x00,0x00,0x00,0x00,0x00, LINE_1, Return_FindInFlash );  //对数据区域写 0x00
   \   0000A3 B7 ..        LD        S:?b5, A
   \   0000A5 8D ......    CALLF     ?Subroutine36
   1603                          ControlByAirLearn_NewWriteInFlash(0x00,0x00,0x00,0x00,0x00, LINE_2, Return_FindInFlash );                               
   \                     ??CrossCallReturnLabel_66:
   \   0000A9 C6 ....      LD        A, L:Return_FindInFlash
   \   0000AC B7 ..        LD        S:?b5, A
   \   0000AE 8D ......    CALLF     ?Subroutine37
   1604                          //更新Flash中所有条目的排位
   1605                          UpdateDatasAdressInFlash(Return_FindInFlash);                               
   \                     ??CrossCallReturnLabel_68:
   \   0000B2 C6 ....      LD        A, L:Return_FindInFlash
   \   0000B5 8D ......    CALLF     UpdateDatasAdressInFlash
   1606                      }
   1607                  }                                        
   1608              }
   1609          }
   \                     ??length20function_0:
   \   0000B9 87           RETF

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine34:
   \   000000 8D ......    CALLF     ?Subroutine64
   \                     ??CrossCallReturnLabel_124:
   \   000004 8D ......    CALLF     FindIdInFlash
   \   000008 C7 ....      LD        L:Return_FindInFlash, A
   \   00000B 87           RETF

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine64:
   \   000000 C6 ....      LD        A, L:Radio_Data + 9
   \   000003 B7 ..        LD        S:?b2, A
   \   000005 C6 ....      LD        A, L:Radio_Data + 8
   \   000008 B7 ..        LD        S:?b1, A
   \   00000A C6 ....      LD        A, L:Radio_Data + 7
   \   00000D B7 ..        LD        S:?b0, A
   \   00000F C6 ....      LD        A, L:Radio_Data + 6
   \   000012 87           RETF
   1610          
   1611          
   1612          
   1613          /************  主函数入口  ******************/

   \                                 In section .far_func.text, align 1
   1614          void main(void)   
   1615          {    
   1616              InitAllGpio();                           //初始化IO口          
   \                     main:
   \   000000 8D ......    CALLF     InitAllGpio
   1617              InitRegister();                          //配置寄存器
   \   000004 8D ......    CALLF     InitRegister
   1618              
   1619              enableInterrupts();                      //使能中断
   \   000008 9A           RIM
   1620              IWDG_Enable();
   \   000009 8D ......    CALLF     IWDG_Enable
   1621              
   1622              Reset_CC1100();                          //复位cc1101          
   \   00000D 8D ......    CALLF     Reset_CC1100
   1623              RadioSettings();                         //配置cc1101寄存器 
   \   000011 8D ......    CALLF     RadioSettings
   1624          
   1625              FirstPower();                            //判断是否是第一次开机   
   \   000015 8D ......    CALLF     FirstPower
   1626              ReadIdInFlash();                         //读Flash中ID   
   \   000019 8D ......    CALLF     ReadIdInFlash
   1627              
   1628              LED1_GREEN;LED2_GREEN;                   //开机LED提示
   \   00001D 8D ......    CALLF     ??Subroutine84_0
   \                     ??CrossCallReturnLabel_152:
   \   000021 8D ......    CALLF     ?Subroutine9
   1629              delay(300);     
   \                     ??CrossCallReturnLabel_258:
   \   000025 AE 012C      LDW       X, #0x12c
   \   000028 8D ......    CALLF     ?Subroutine19
   1630              Led1_Off();Led2_Off();
   \                     ??CrossCallReturnLabel_31:
   \   00002C 8D ......    CALLF     ?Subroutine32
   1631              
   1632              IWDG_Enable(); 
   \                     ??CrossCallReturnLabel_57:
   \   000030 8D ......    CALLF     IWDG_Enable
   \   000034 20 3A        JRA       L:??main_0
   1633                
   1634              while(1)
   1635              {    
   1636                   
   1637                  IWDG_ReloadCounter();    //喂狗
   1638                  if((rtc_flag == 1) && (receiveflag == 0) && (learn_mode == OFF))    
   1639                  {  
   1640                    rtc_flag = 0;
   1641                    halSpiStrobe(0x36);halSpiStrobe(0x34);timer2_delay(1);       //矫正时钟
   1642                    receiveflag = 0;
   1643                  }
   1644                  else
   1645                  {rtc_flag = 0;}
   \                     ??main_1:
   \   000036 725F ....    CLR       L:rtc_flag
   1646                
   1647                  if(receiveflag )        //报文接收处理函数                 
   \   00003A C6 ....      LD        A, L:receiveflag
   \   00003D 27 04        JREQ      L:??main_2
   1648                  { 
   1649                    Radio_Recive();
   \   00003F 8D ......    CALLF     Radio_Recive
   1650                  }
   1651                  
   1652                  if(check_key1 == 1)     //按键1扫描
   \                     ??main_2:
   \   000043 C6 ....      LD        A, L:check_key1
   \   000046 A1 01        CP        A, #0x1
   \   000048 26 08        JRNE      L:??main_3
   1653                  {
   1654                    check_key1 = 0;
   \   00004A 725F ....    CLR       L:check_key1
   1655                    Key1_Function();
   \   00004E 8D ......    CALLF     Key1_Function
   1656                  }
   1657                  if(check_key2 == 1)     //按键2扫描
   \                     ??main_3:
   \   000052 C6 ....      LD        A, L:check_key2
   \   000055 A1 01        CP        A, #0x1
   \   000057 26 08        JRNE      L:??main_4
   1658                  {
   1659                    check_key2 = 0;
   \   000059 725F ....    CLR       L:check_key2
   1660                    Key2_Function();
   \   00005D 8D ......    CALLF     Key2_Function
   1661                  }
   1662                                        
   1663                  if(learn_mode == ON)    //学习模式处理
   \                     ??main_4:
   \   000061 C6 ....      LD        A, L:learn_mode
   \   000064 A1 11        CP        A, #0x11
   \   000066 26 08        JRNE      L:??main_0
   1664                  {                                                
   1665                    Auto_Exit_LearnMode_Function();      
   \   000068 8D ......    CALLF     Auto_Exit_LearnMode_Function
   1666                    LearnMode_Function();            
   \   00006C 8D ......    CALLF     LearnMode_Function
   1667                  }          
   \                     ??main_0:
   \   000070 8D ......    CALLF     IWDG_ReloadCounter
   \   000074 C6 ....      LD        A, L:rtc_flag
   \   000077 A1 01        CP        A, #0x1
   \   000079 26 BB        JRNE      L:??main_1
   \   00007B C6 ....      LD        A, L:receiveflag
   \   00007E 26 B6        JRNE      L:??main_1
   \   000080 C6 ....      LD        A, L:learn_mode
   \   000083 A1 10        CP        A, #0x10
   \   000085 35 00 ....   MOV       L:rtc_flag, #0x0
   \   000089 26 B8        JRNE      L:??main_2
   \   00008B 8D ......    CALLF     ?Subroutine15
   \                     ??CrossCallReturnLabel_231:
   \   00008F 725F ....    CLR       L:receiveflag
   \   000093 20 AE        JRA       L:??main_2
   1668              } 
   1669          }

   \                                 In section .near.rodata, align 1
   \                     ?_0:
   \   000000 C5 C5 C5 C5  DC8 197, 197, 197, 197, 197, 197, 197, 197
   \          C5 C5 C5 C5 

   \                                 In section .near.rodata, align 1
   \                     ?_1:
   \   000000 01 15 05 20  DC8 1, 21, 5, 32, 67, 33
   \          43 21       

   \                                 In section .near.rodata, align 1
   \                     ?_2:
   \   000000 06 00 00 00  DC8 6, 0, 0, 0, 0, 0, 67, 32, 5, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \          00 00 43 20 
   \   000016 00 00        DC8 0, 0

   Section sizes:

   Bytes  Function/Label
   -----  --------------
       5  ??Subroutine100_0
       7  ??Subroutine101_0
       5  ??Subroutine102_0
       5  ??Subroutine103_0
       7  ??Subroutine104_0
      10  ??Subroutine105_0
      10  ??Subroutine106_0
       5  ??Subroutine107_0
       7  ??Subroutine108_0
       7  ??Subroutine109_0
       5  ??Subroutine110_0
       7  ??Subroutine111_0
       5  ??Subroutine112_0
       7  ??Subroutine113_0
       2  ??Subroutine84_0
       7  ??Subroutine85_0
       5  ??Subroutine86_0
       7  ??Subroutine87_0
       7  ??Subroutine88_0
       9  ??Subroutine89_0
       8  ??Subroutine90_0
       5  ??Subroutine91_0
       4  ??Subroutine92_0
       4  ??Subroutine93_0
       7  ??Subroutine94_0
       7  ??Subroutine95_0
       5  ??Subroutine96_0
       2  ??Subroutine97_0
      17  ??Subroutine98_0
       3  ??Subroutine99_0
      16  ?Subroutine0
      23  ?Subroutine1
       2  ?Subroutine10
      33  ?Subroutine11
      31  ?Subroutine12
       9  ?Subroutine13
      10  ?Subroutine14
      12  ?Subroutine15
       7  ?Subroutine16
       5  ?Subroutine17
       3  ?Subroutine18
       9  ?Subroutine19
       2  ?Subroutine2
      11  ?Subroutine20
       5  ?Subroutine21
       2  ?Subroutine22
       7  ?Subroutine23
       6  ?Subroutine24
       3  ?Subroutine25
       7  ?Subroutine26
      80  ?Subroutine27
      21  ?Subroutine28
       8  ?Subroutine29
       6  ?Subroutine3
       1  ?Subroutine30
       7  ?Subroutine31
       8  ?Subroutine32
       8  ?Subroutine33
      12  ?Subroutine34
      22  ?Subroutine35
       9  ?Subroutine36
       9  ?Subroutine37
      12  ?Subroutine38
       5  ?Subroutine39
       7  ?Subroutine4
       2  ?Subroutine40
       9  ?Subroutine41
       2  ?Subroutine42
       9  ?Subroutine43
       5  ?Subroutine44
      11  ?Subroutine45
       8  ?Subroutine46
       2  ?Subroutine47
       2  ?Subroutine48
       9  ?Subroutine49
      20  ?Subroutine5
      12  ?Subroutine50
       5  ?Subroutine51
       6  ?Subroutine52
       6  ?Subroutine53
       5  ?Subroutine54
       7  ?Subroutine55
       7  ?Subroutine56
       7  ?Subroutine57
       2  ?Subroutine58
       3  ?Subroutine59
       4  ?Subroutine6
       7  ?Subroutine60
       2  ?Subroutine61
       2  ?Subroutine62
       7  ?Subroutine63
      19  ?Subroutine64
      13  ?Subroutine65
      28  ?Subroutine66
       1  ?Subroutine67
       7  ?Subroutine68
       4  ?Subroutine69
      12  ?Subroutine7
      12  ?Subroutine70
      15  ?Subroutine71
      10  ?Subroutine72
      13  ?Subroutine73
       2  ?Subroutine74
      11  ?Subroutine75
       6  ?Subroutine76
       9  ?Subroutine77
       9  ?Subroutine78
       8  ?Subroutine79
       2  ?Subroutine8
      12  ?Subroutine80
       1  ?Subroutine81
       9  ?Subroutine82
       8  ?Subroutine83
       2  ?Subroutine9
       8  ?_0
       6  ?_1
      24  ?_2
      10  ?_3
      11  ?_4
     100  ABIO_Function
      70  AllRadio
      83  Auto_Exit_LearnMode_Function
      27  Broadcast_info
       2  CalculateRssi
       1  Choose_Line
     117  ClearFlash
     188  CommonMode_OperateLine
     191  ControlByAirLearn_NewWriteInFlash
      68  FindIdInFlash
       1  FindIdInFlash_return_num
      49  FirstPower
       1  IdNum
       2  IdStartAddress
     235  InitAllGpio
     247  InitRegister
     100  Key1_Function
       1  Key1_InterruptPushflag
       1  Key1_Short_Pushed
     148  Key2_Function
       1  Key2_InterruptPushflag
       1  Key2_Short_Pushed
       1  LearnModeWaitForConfirm
     436  LearnMode_Function
      19  Led1_Off
      19  Led2_Off
       1  Public_learned_ID_num
     247  RadioSettings
       1  Radio_Can_Operated
      33  Radio_Data
     139  Radio_Recive
     129  ReadIdInFlash
     205  Reply_RequestFlashData
      19  Reset_CC1100
       1  Return_FindInFlash
     206  SaveInfoInFlash
      90  SpiTxRxByte
     348  UpdateDatasAdressInFlash
       4  WaitForConfirm_time
     123  WriteIdInFlash
     189  WriteKeyOperationInFlash
       4  auto_exit_time
       1  check_key1
       1  check_key2
       1  clear_num
      39  delay
       1  firstpower
     144  halRfReceivePacket
      57  halRfSendPacket
      71  halSpiReadBurstReg
      23  halSpiReadReg
      23  halSpiReadStatus
      23  halSpiStrobe
      63  halSpiWriteBurstReg
      35  halSpiWriteReg
       4  key1_time_count
       4  key2_time_count
       1  learn_mode
       1  led_blink_time
       1  led_flash
      63  length10function
     186  length20function
      82  length5function
      38  length6function
     123  length7function
     149  main
       1  receive_radio_length
       1  receiveflag
      54  reply_broadcast
       1  rtc_flag
      82  timer2_delay
       4  timer2_delay_time
       1  timer2_need_delay
       4  timer3_Operate_time

 
 5 862 bytes in section .far_func.text
   244 bytes in section .near.bss
     7 bytes in section .near.data
    59 bytes in section .near.rodata
 
 5 862 bytes of CODE  memory
    59 bytes of CONST memory
   251 bytes of DATA  memory

Errors: none
Warnings: none
